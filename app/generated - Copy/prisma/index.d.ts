
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model barcode
 * 
 */
export type barcode = $Result.DefaultSelection<Prisma.$barcodePayload>
/**
 * Model billing
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type billing = $Result.DefaultSelection<Prisma.$billingPayload>
/**
 * Model billing_log
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type billing_log = $Result.DefaultSelection<Prisma.$billing_logPayload>
/**
 * Model bloodgroup_details
 * 
 */
export type bloodgroup_details = $Result.DefaultSelection<Prisma.$bloodgroup_detailsPayload>
/**
 * Model city
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type city = $Result.DefaultSelection<Prisma.$cityPayload>
/**
 * Model clinic_module_activation_request
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type clinic_module_activation_request = $Result.DefaultSelection<Prisma.$clinic_module_activation_requestPayload>
/**
 * Model clinical_parameters
 * 
 */
export type clinical_parameters = $Result.DefaultSelection<Prisma.$clinical_parametersPayload>
/**
 * Model contact
 * 
 */
export type contact = $Result.DefaultSelection<Prisma.$contactPayload>
/**
 * Model country
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type country = $Result.DefaultSelection<Prisma.$countryPayload>
/**
 * Model files
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type files = $Result.DefaultSelection<Prisma.$filesPayload>
/**
 * Model investigation_details
 * 
 */
export type investigation_details = $Result.DefaultSelection<Prisma.$investigation_detailsPayload>
/**
 * Model investigation_file
 * 
 */
export type investigation_file = $Result.DefaultSelection<Prisma.$investigation_filePayload>
/**
 * Model investigation_test_details
 * 
 */
export type investigation_test_details = $Result.DefaultSelection<Prisma.$investigation_test_detailsPayload>
/**
 * Model lab_leaves
 * 
 */
export type lab_leaves = $Result.DefaultSelection<Prisma.$lab_leavesPayload>
/**
 * Model lab_tests_price_updates
 * 
 */
export type lab_tests_price_updates = $Result.DefaultSelection<Prisma.$lab_tests_price_updatesPayload>
/**
 * Model lab_timings
 * 
 */
export type lab_timings = $Result.DefaultSelection<Prisma.$lab_timingsPayload>
/**
 * Model laboratory_details
 * 
 */
export type laboratory_details = $Result.DefaultSelection<Prisma.$laboratory_detailsPayload>
/**
 * Model laboratory_doctors
 * 
 */
export type laboratory_doctors = $Result.DefaultSelection<Prisma.$laboratory_doctorsPayload>
/**
 * Model laboratory_test_details
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type laboratory_test_details = $Result.DefaultSelection<Prisma.$laboratory_test_detailsPayload>
/**
 * Model locality
 * 
 */
export type locality = $Result.DefaultSelection<Prisma.$localityPayload>
/**
 * Model login_details
 * 
 */
export type login_details = $Result.DefaultSelection<Prisma.$login_detailsPayload>
/**
 * Model medicine
 * 
 */
export type medicine = $Result.DefaultSelection<Prisma.$medicinePayload>
/**
 * Model notification_keys
 * 
 */
export type notification_keys = $Result.DefaultSelection<Prisma.$notification_keysPayload>
/**
 * Model notificationattempt
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type notificationattempt = $Result.DefaultSelection<Prisma.$notificationattemptPayload>
/**
 * Model Renamedpackage
 * This model has been renamed to 'Renamedpackage' during introspection, because the original name 'package' is reserved.
 */
export type Renamedpackage = $Result.DefaultSelection<Prisma.$RenamedpackagePayload>
/**
 * Model package_contains
 * 
 */
export type package_contains = $Result.DefaultSelection<Prisma.$package_containsPayload>
/**
 * Model package_labs
 * 
 */
export type package_labs = $Result.DefaultSelection<Prisma.$package_labsPayload>
/**
 * Model package_queue
 * 
 */
export type package_queue = $Result.DefaultSelection<Prisma.$package_queuePayload>
/**
 * Model patient_dep_details
 * 
 */
export type patient_dep_details = $Result.DefaultSelection<Prisma.$patient_dep_detailsPayload>
/**
 * Model patient_doctor_mapping
 * 
 */
export type patient_doctor_mapping = $Result.DefaultSelection<Prisma.$patient_doctor_mappingPayload>
/**
 * Model patient_parameter
 * 
 */
export type patient_parameter = $Result.DefaultSelection<Prisma.$patient_parameterPayload>
/**
 * Model patientqueue
 * 
 */
export type patientqueue = $Result.DefaultSelection<Prisma.$patientqueuePayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model phy_admin
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type phy_admin = $Result.DefaultSelection<Prisma.$phy_adminPayload>
/**
 * Model physician_appointment
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type physician_appointment = $Result.DefaultSelection<Prisma.$physician_appointmentPayload>
/**
 * Model physician_clinic_timings
 * 
 */
export type physician_clinic_timings = $Result.DefaultSelection<Prisma.$physician_clinic_timingsPayload>
/**
 * Model physician_leaves
 * 
 */
export type physician_leaves = $Result.DefaultSelection<Prisma.$physician_leavesPayload>
/**
 * Model physician_timings
 * 
 */
export type physician_timings = $Result.DefaultSelection<Prisma.$physician_timingsPayload>
/**
 * Model preferredlabs
 * 
 */
export type preferredlabs = $Result.DefaultSelection<Prisma.$preferredlabsPayload>
/**
 * Model prescription
 * 
 */
export type prescription = $Result.DefaultSelection<Prisma.$prescriptionPayload>
/**
 * Model prescription_medicine
 * 
 */
export type prescription_medicine = $Result.DefaultSelection<Prisma.$prescription_medicinePayload>
/**
 * Model qualification
 * 
 */
export type qualification = $Result.DefaultSelection<Prisma.$qualificationPayload>
/**
 * Model qualification_mapping
 * 
 */
export type qualification_mapping = $Result.DefaultSelection<Prisma.$qualification_mappingPayload>
/**
 * Model referral_confirmation_details
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type referral_confirmation_details = $Result.DefaultSelection<Prisma.$referral_confirmation_detailsPayload>
/**
 * Model referral_confirmation_details1
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type referral_confirmation_details1 = $Result.DefaultSelection<Prisma.$referral_confirmation_details1Payload>
/**
 * Model referral_patient_details
 * 
 */
export type referral_patient_details = $Result.DefaultSelection<Prisma.$referral_patient_detailsPayload>
/**
 * Model referral_patient_test_details
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type referral_patient_test_details = $Result.DefaultSelection<Prisma.$referral_patient_test_detailsPayload>
/**
 * Model relationship
 * 
 */
export type relationship = $Result.DefaultSelection<Prisma.$relationshipPayload>
/**
 * Model report_template
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type report_template = $Result.DefaultSelection<Prisma.$report_templatePayload>
/**
 * Model sample_results
 * 
 */
export type sample_results = $Result.DefaultSelection<Prisma.$sample_resultsPayload>
/**
 * Model ssconsultation_billing
 * 
 */
export type ssconsultation_billing = $Result.DefaultSelection<Prisma.$ssconsultation_billingPayload>
/**
 * Model ssconsultation_log
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ssconsultation_log = $Result.DefaultSelection<Prisma.$ssconsultation_logPayload>
/**
 * Model state
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type state = $Result.DefaultSelection<Prisma.$statePayload>
/**
 * Model status_master
 * 
 */
export type status_master = $Result.DefaultSelection<Prisma.$status_masterPayload>
/**
 * Model super_speciality
 * 
 */
export type super_speciality = $Result.DefaultSelection<Prisma.$super_specialityPayload>
/**
 * Model superspeciality_consultation
 * 
 */
export type superspeciality_consultation = $Result.DefaultSelection<Prisma.$superspeciality_consultationPayload>
/**
 * Model superspeciality_details
 * 
 */
export type superspeciality_details = $Result.DefaultSelection<Prisma.$superspeciality_detailsPayload>
/**
 * Model test_report_notes
 * 
 */
export type test_report_notes = $Result.DefaultSelection<Prisma.$test_report_notesPayload>
/**
 * Model update_labs
 * 
 */
export type update_labs = $Result.DefaultSelection<Prisma.$update_labsPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const files_status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type files_status = (typeof files_status)[keyof typeof files_status]


export const lab_timings_work_type: {
  WORKING_DAY: 'WORKING_DAY',
  HOLI_DAY: 'HOLI_DAY'
};

export type lab_timings_work_type = (typeof lab_timings_work_type)[keyof typeof lab_timings_work_type]


export const laboratory_test_details_status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type laboratory_test_details_status = (typeof laboratory_test_details_status)[keyof typeof laboratory_test_details_status]


export const physician_clinic_timings_work_type: {
  WORKING_DAY: 'WORKING_DAY',
  HOLI_DAY: 'HOLI_DAY'
};

export type physician_clinic_timings_work_type = (typeof physician_clinic_timings_work_type)[keyof typeof physician_clinic_timings_work_type]


export const physician_timings_work_type: {
  WORKING_DAY: 'WORKING_DAY',
  HOLI_DAY: 'HOLI_DAY'
};

export type physician_timings_work_type = (typeof physician_timings_work_type)[keyof typeof physician_timings_work_type]


export const referral_confirmation_details_ref_type: {
  I: 'I',
  P: 'P'
};

export type referral_confirmation_details_ref_type = (typeof referral_confirmation_details_ref_type)[keyof typeof referral_confirmation_details_ref_type]


export const referral_confirmation_details1_ref_type: {
  I: 'I',
  P: 'P'
};

export type referral_confirmation_details1_ref_type = (typeof referral_confirmation_details1_ref_type)[keyof typeof referral_confirmation_details1_ref_type]

}

export type files_status = $Enums.files_status

export const files_status: typeof $Enums.files_status

export type lab_timings_work_type = $Enums.lab_timings_work_type

export const lab_timings_work_type: typeof $Enums.lab_timings_work_type

export type laboratory_test_details_status = $Enums.laboratory_test_details_status

export const laboratory_test_details_status: typeof $Enums.laboratory_test_details_status

export type physician_clinic_timings_work_type = $Enums.physician_clinic_timings_work_type

export const physician_clinic_timings_work_type: typeof $Enums.physician_clinic_timings_work_type

export type physician_timings_work_type = $Enums.physician_timings_work_type

export const physician_timings_work_type: typeof $Enums.physician_timings_work_type

export type referral_confirmation_details_ref_type = $Enums.referral_confirmation_details_ref_type

export const referral_confirmation_details_ref_type: typeof $Enums.referral_confirmation_details_ref_type

export type referral_confirmation_details1_ref_type = $Enums.referral_confirmation_details1_ref_type

export const referral_confirmation_details1_ref_type: typeof $Enums.referral_confirmation_details1_ref_type

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Barcodes
 * const barcodes = await prisma.barcode.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Barcodes
   * const barcodes = await prisma.barcode.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.barcode`: Exposes CRUD operations for the **barcode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Barcodes
    * const barcodes = await prisma.barcode.findMany()
    * ```
    */
  get barcode(): Prisma.barcodeDelegate<ExtArgs>;

  /**
   * `prisma.billing`: Exposes CRUD operations for the **billing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billings
    * const billings = await prisma.billing.findMany()
    * ```
    */
  get billing(): Prisma.billingDelegate<ExtArgs>;

  /**
   * `prisma.billing_log`: Exposes CRUD operations for the **billing_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billing_logs
    * const billing_logs = await prisma.billing_log.findMany()
    * ```
    */
  get billing_log(): Prisma.billing_logDelegate<ExtArgs>;

  /**
   * `prisma.bloodgroup_details`: Exposes CRUD operations for the **bloodgroup_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bloodgroup_details
    * const bloodgroup_details = await prisma.bloodgroup_details.findMany()
    * ```
    */
  get bloodgroup_details(): Prisma.bloodgroup_detailsDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **city** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.cityDelegate<ExtArgs>;

  /**
   * `prisma.clinic_module_activation_request`: Exposes CRUD operations for the **clinic_module_activation_request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinic_module_activation_requests
    * const clinic_module_activation_requests = await prisma.clinic_module_activation_request.findMany()
    * ```
    */
  get clinic_module_activation_request(): Prisma.clinic_module_activation_requestDelegate<ExtArgs>;

  /**
   * `prisma.clinical_parameters`: Exposes CRUD operations for the **clinical_parameters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinical_parameters
    * const clinical_parameters = await prisma.clinical_parameters.findMany()
    * ```
    */
  get clinical_parameters(): Prisma.clinical_parametersDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.contactDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.countryDelegate<ExtArgs>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.filesDelegate<ExtArgs>;

  /**
   * `prisma.investigation_details`: Exposes CRUD operations for the **investigation_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investigation_details
    * const investigation_details = await prisma.investigation_details.findMany()
    * ```
    */
  get investigation_details(): Prisma.investigation_detailsDelegate<ExtArgs>;

  /**
   * `prisma.investigation_file`: Exposes CRUD operations for the **investigation_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investigation_files
    * const investigation_files = await prisma.investigation_file.findMany()
    * ```
    */
  get investigation_file(): Prisma.investigation_fileDelegate<ExtArgs>;

  /**
   * `prisma.investigation_test_details`: Exposes CRUD operations for the **investigation_test_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investigation_test_details
    * const investigation_test_details = await prisma.investigation_test_details.findMany()
    * ```
    */
  get investigation_test_details(): Prisma.investigation_test_detailsDelegate<ExtArgs>;

  /**
   * `prisma.lab_leaves`: Exposes CRUD operations for the **lab_leaves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_leaves
    * const lab_leaves = await prisma.lab_leaves.findMany()
    * ```
    */
  get lab_leaves(): Prisma.lab_leavesDelegate<ExtArgs>;

  /**
   * `prisma.lab_tests_price_updates`: Exposes CRUD operations for the **lab_tests_price_updates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_tests_price_updates
    * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findMany()
    * ```
    */
  get lab_tests_price_updates(): Prisma.lab_tests_price_updatesDelegate<ExtArgs>;

  /**
   * `prisma.lab_timings`: Exposes CRUD operations for the **lab_timings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_timings
    * const lab_timings = await prisma.lab_timings.findMany()
    * ```
    */
  get lab_timings(): Prisma.lab_timingsDelegate<ExtArgs>;

  /**
   * `prisma.laboratory_details`: Exposes CRUD operations for the **laboratory_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Laboratory_details
    * const laboratory_details = await prisma.laboratory_details.findMany()
    * ```
    */
  get laboratory_details(): Prisma.laboratory_detailsDelegate<ExtArgs>;

  /**
   * `prisma.laboratory_doctors`: Exposes CRUD operations for the **laboratory_doctors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Laboratory_doctors
    * const laboratory_doctors = await prisma.laboratory_doctors.findMany()
    * ```
    */
  get laboratory_doctors(): Prisma.laboratory_doctorsDelegate<ExtArgs>;

  /**
   * `prisma.laboratory_test_details`: Exposes CRUD operations for the **laboratory_test_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Laboratory_test_details
    * const laboratory_test_details = await prisma.laboratory_test_details.findMany()
    * ```
    */
  get laboratory_test_details(): Prisma.laboratory_test_detailsDelegate<ExtArgs>;

  /**
   * `prisma.locality`: Exposes CRUD operations for the **locality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Localities
    * const localities = await prisma.locality.findMany()
    * ```
    */
  get locality(): Prisma.localityDelegate<ExtArgs>;

  /**
   * `prisma.login_details`: Exposes CRUD operations for the **login_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Login_details
    * const login_details = await prisma.login_details.findMany()
    * ```
    */
  get login_details(): Prisma.login_detailsDelegate<ExtArgs>;

  /**
   * `prisma.medicine`: Exposes CRUD operations for the **medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicines
    * const medicines = await prisma.medicine.findMany()
    * ```
    */
  get medicine(): Prisma.medicineDelegate<ExtArgs>;

  /**
   * `prisma.notification_keys`: Exposes CRUD operations for the **notification_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_keys
    * const notification_keys = await prisma.notification_keys.findMany()
    * ```
    */
  get notification_keys(): Prisma.notification_keysDelegate<ExtArgs>;

  /**
   * `prisma.notificationattempt`: Exposes CRUD operations for the **notificationattempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificationattempts
    * const notificationattempts = await prisma.notificationattempt.findMany()
    * ```
    */
  get notificationattempt(): Prisma.notificationattemptDelegate<ExtArgs>;

  /**
   * `prisma.renamedpackage`: Exposes CRUD operations for the **Renamedpackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Renamedpackages
    * const renamedpackages = await prisma.renamedpackage.findMany()
    * ```
    */
  get renamedpackage(): Prisma.RenamedpackageDelegate<ExtArgs>;

  /**
   * `prisma.package_contains`: Exposes CRUD operations for the **package_contains** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Package_contains
    * const package_contains = await prisma.package_contains.findMany()
    * ```
    */
  get package_contains(): Prisma.package_containsDelegate<ExtArgs>;

  /**
   * `prisma.package_labs`: Exposes CRUD operations for the **package_labs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Package_labs
    * const package_labs = await prisma.package_labs.findMany()
    * ```
    */
  get package_labs(): Prisma.package_labsDelegate<ExtArgs>;

  /**
   * `prisma.package_queue`: Exposes CRUD operations for the **package_queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Package_queues
    * const package_queues = await prisma.package_queue.findMany()
    * ```
    */
  get package_queue(): Prisma.package_queueDelegate<ExtArgs>;

  /**
   * `prisma.patient_dep_details`: Exposes CRUD operations for the **patient_dep_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_dep_details
    * const patient_dep_details = await prisma.patient_dep_details.findMany()
    * ```
    */
  get patient_dep_details(): Prisma.patient_dep_detailsDelegate<ExtArgs>;

  /**
   * `prisma.patient_doctor_mapping`: Exposes CRUD operations for the **patient_doctor_mapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_doctor_mappings
    * const patient_doctor_mappings = await prisma.patient_doctor_mapping.findMany()
    * ```
    */
  get patient_doctor_mapping(): Prisma.patient_doctor_mappingDelegate<ExtArgs>;

  /**
   * `prisma.patient_parameter`: Exposes CRUD operations for the **patient_parameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_parameters
    * const patient_parameters = await prisma.patient_parameter.findMany()
    * ```
    */
  get patient_parameter(): Prisma.patient_parameterDelegate<ExtArgs>;

  /**
   * `prisma.patientqueue`: Exposes CRUD operations for the **patientqueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patientqueues
    * const patientqueues = await prisma.patientqueue.findMany()
    * ```
    */
  get patientqueue(): Prisma.patientqueueDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs>;

  /**
   * `prisma.phy_admin`: Exposes CRUD operations for the **phy_admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phy_admins
    * const phy_admins = await prisma.phy_admin.findMany()
    * ```
    */
  get phy_admin(): Prisma.phy_adminDelegate<ExtArgs>;

  /**
   * `prisma.physician_appointment`: Exposes CRUD operations for the **physician_appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physician_appointments
    * const physician_appointments = await prisma.physician_appointment.findMany()
    * ```
    */
  get physician_appointment(): Prisma.physician_appointmentDelegate<ExtArgs>;

  /**
   * `prisma.physician_clinic_timings`: Exposes CRUD operations for the **physician_clinic_timings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physician_clinic_timings
    * const physician_clinic_timings = await prisma.physician_clinic_timings.findMany()
    * ```
    */
  get physician_clinic_timings(): Prisma.physician_clinic_timingsDelegate<ExtArgs>;

  /**
   * `prisma.physician_leaves`: Exposes CRUD operations for the **physician_leaves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physician_leaves
    * const physician_leaves = await prisma.physician_leaves.findMany()
    * ```
    */
  get physician_leaves(): Prisma.physician_leavesDelegate<ExtArgs>;

  /**
   * `prisma.physician_timings`: Exposes CRUD operations for the **physician_timings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physician_timings
    * const physician_timings = await prisma.physician_timings.findMany()
    * ```
    */
  get physician_timings(): Prisma.physician_timingsDelegate<ExtArgs>;

  /**
   * `prisma.preferredlabs`: Exposes CRUD operations for the **preferredlabs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferredlabs
    * const preferredlabs = await prisma.preferredlabs.findMany()
    * ```
    */
  get preferredlabs(): Prisma.preferredlabsDelegate<ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.prescriptionDelegate<ExtArgs>;

  /**
   * `prisma.prescription_medicine`: Exposes CRUD operations for the **prescription_medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescription_medicines
    * const prescription_medicines = await prisma.prescription_medicine.findMany()
    * ```
    */
  get prescription_medicine(): Prisma.prescription_medicineDelegate<ExtArgs>;

  /**
   * `prisma.qualification`: Exposes CRUD operations for the **qualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualifications
    * const qualifications = await prisma.qualification.findMany()
    * ```
    */
  get qualification(): Prisma.qualificationDelegate<ExtArgs>;

  /**
   * `prisma.qualification_mapping`: Exposes CRUD operations for the **qualification_mapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualification_mappings
    * const qualification_mappings = await prisma.qualification_mapping.findMany()
    * ```
    */
  get qualification_mapping(): Prisma.qualification_mappingDelegate<ExtArgs>;

  /**
   * `prisma.referral_confirmation_details`: Exposes CRUD operations for the **referral_confirmation_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_confirmation_details
    * const referral_confirmation_details = await prisma.referral_confirmation_details.findMany()
    * ```
    */
  get referral_confirmation_details(): Prisma.referral_confirmation_detailsDelegate<ExtArgs>;

  /**
   * `prisma.referral_confirmation_details1`: Exposes CRUD operations for the **referral_confirmation_details1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_confirmation_details1s
    * const referral_confirmation_details1s = await prisma.referral_confirmation_details1.findMany()
    * ```
    */
  get referral_confirmation_details1(): Prisma.referral_confirmation_details1Delegate<ExtArgs>;

  /**
   * `prisma.referral_patient_details`: Exposes CRUD operations for the **referral_patient_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_patient_details
    * const referral_patient_details = await prisma.referral_patient_details.findMany()
    * ```
    */
  get referral_patient_details(): Prisma.referral_patient_detailsDelegate<ExtArgs>;

  /**
   * `prisma.referral_patient_test_details`: Exposes CRUD operations for the **referral_patient_test_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_patient_test_details
    * const referral_patient_test_details = await prisma.referral_patient_test_details.findMany()
    * ```
    */
  get referral_patient_test_details(): Prisma.referral_patient_test_detailsDelegate<ExtArgs>;

  /**
   * `prisma.relationship`: Exposes CRUD operations for the **relationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relationships
    * const relationships = await prisma.relationship.findMany()
    * ```
    */
  get relationship(): Prisma.relationshipDelegate<ExtArgs>;

  /**
   * `prisma.report_template`: Exposes CRUD operations for the **report_template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_templates
    * const report_templates = await prisma.report_template.findMany()
    * ```
    */
  get report_template(): Prisma.report_templateDelegate<ExtArgs>;

  /**
   * `prisma.sample_results`: Exposes CRUD operations for the **sample_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sample_results
    * const sample_results = await prisma.sample_results.findMany()
    * ```
    */
  get sample_results(): Prisma.sample_resultsDelegate<ExtArgs>;

  /**
   * `prisma.ssconsultation_billing`: Exposes CRUD operations for the **ssconsultation_billing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ssconsultation_billings
    * const ssconsultation_billings = await prisma.ssconsultation_billing.findMany()
    * ```
    */
  get ssconsultation_billing(): Prisma.ssconsultation_billingDelegate<ExtArgs>;

  /**
   * `prisma.ssconsultation_log`: Exposes CRUD operations for the **ssconsultation_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ssconsultation_logs
    * const ssconsultation_logs = await prisma.ssconsultation_log.findMany()
    * ```
    */
  get ssconsultation_log(): Prisma.ssconsultation_logDelegate<ExtArgs>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.stateDelegate<ExtArgs>;

  /**
   * `prisma.status_master`: Exposes CRUD operations for the **status_master** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Status_masters
    * const status_masters = await prisma.status_master.findMany()
    * ```
    */
  get status_master(): Prisma.status_masterDelegate<ExtArgs>;

  /**
   * `prisma.super_speciality`: Exposes CRUD operations for the **super_speciality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Super_specialities
    * const super_specialities = await prisma.super_speciality.findMany()
    * ```
    */
  get super_speciality(): Prisma.super_specialityDelegate<ExtArgs>;

  /**
   * `prisma.superspeciality_consultation`: Exposes CRUD operations for the **superspeciality_consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Superspeciality_consultations
    * const superspeciality_consultations = await prisma.superspeciality_consultation.findMany()
    * ```
    */
  get superspeciality_consultation(): Prisma.superspeciality_consultationDelegate<ExtArgs>;

  /**
   * `prisma.superspeciality_details`: Exposes CRUD operations for the **superspeciality_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Superspeciality_details
    * const superspeciality_details = await prisma.superspeciality_details.findMany()
    * ```
    */
  get superspeciality_details(): Prisma.superspeciality_detailsDelegate<ExtArgs>;

  /**
   * `prisma.test_report_notes`: Exposes CRUD operations for the **test_report_notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_report_notes
    * const test_report_notes = await prisma.test_report_notes.findMany()
    * ```
    */
  get test_report_notes(): Prisma.test_report_notesDelegate<ExtArgs>;

  /**
   * `prisma.update_labs`: Exposes CRUD operations for the **update_labs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Update_labs
    * const update_labs = await prisma.update_labs.findMany()
    * ```
    */
  get update_labs(): Prisma.update_labsDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    barcode: 'barcode',
    billing: 'billing',
    billing_log: 'billing_log',
    bloodgroup_details: 'bloodgroup_details',
    city: 'city',
    clinic_module_activation_request: 'clinic_module_activation_request',
    clinical_parameters: 'clinical_parameters',
    contact: 'contact',
    country: 'country',
    files: 'files',
    investigation_details: 'investigation_details',
    investigation_file: 'investigation_file',
    investigation_test_details: 'investigation_test_details',
    lab_leaves: 'lab_leaves',
    lab_tests_price_updates: 'lab_tests_price_updates',
    lab_timings: 'lab_timings',
    laboratory_details: 'laboratory_details',
    laboratory_doctors: 'laboratory_doctors',
    laboratory_test_details: 'laboratory_test_details',
    locality: 'locality',
    login_details: 'login_details',
    medicine: 'medicine',
    notification_keys: 'notification_keys',
    notificationattempt: 'notificationattempt',
    Renamedpackage: 'Renamedpackage',
    package_contains: 'package_contains',
    package_labs: 'package_labs',
    package_queue: 'package_queue',
    patient_dep_details: 'patient_dep_details',
    patient_doctor_mapping: 'patient_doctor_mapping',
    patient_parameter: 'patient_parameter',
    patientqueue: 'patientqueue',
    payment: 'payment',
    phy_admin: 'phy_admin',
    physician_appointment: 'physician_appointment',
    physician_clinic_timings: 'physician_clinic_timings',
    physician_leaves: 'physician_leaves',
    physician_timings: 'physician_timings',
    preferredlabs: 'preferredlabs',
    prescription: 'prescription',
    prescription_medicine: 'prescription_medicine',
    qualification: 'qualification',
    qualification_mapping: 'qualification_mapping',
    referral_confirmation_details: 'referral_confirmation_details',
    referral_confirmation_details1: 'referral_confirmation_details1',
    referral_patient_details: 'referral_patient_details',
    referral_patient_test_details: 'referral_patient_test_details',
    relationship: 'relationship',
    report_template: 'report_template',
    sample_results: 'sample_results',
    ssconsultation_billing: 'ssconsultation_billing',
    ssconsultation_log: 'ssconsultation_log',
    state: 'state',
    status_master: 'status_master',
    super_speciality: 'super_speciality',
    superspeciality_consultation: 'superspeciality_consultation',
    superspeciality_details: 'superspeciality_details',
    test_report_notes: 'test_report_notes',
    update_labs: 'update_labs',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "barcode" | "billing" | "billing_log" | "bloodgroup_details" | "city" | "clinic_module_activation_request" | "clinical_parameters" | "contact" | "country" | "files" | "investigation_details" | "investigation_file" | "investigation_test_details" | "lab_leaves" | "lab_tests_price_updates" | "lab_timings" | "laboratory_details" | "laboratory_doctors" | "laboratory_test_details" | "locality" | "login_details" | "medicine" | "notification_keys" | "notificationattempt" | "renamedpackage" | "package_contains" | "package_labs" | "package_queue" | "patient_dep_details" | "patient_doctor_mapping" | "patient_parameter" | "patientqueue" | "payment" | "phy_admin" | "physician_appointment" | "physician_clinic_timings" | "physician_leaves" | "physician_timings" | "preferredlabs" | "prescription" | "prescription_medicine" | "qualification" | "qualification_mapping" | "referral_confirmation_details" | "referral_confirmation_details1" | "referral_patient_details" | "referral_patient_test_details" | "relationship" | "report_template" | "sample_results" | "ssconsultation_billing" | "ssconsultation_log" | "state" | "status_master" | "super_speciality" | "superspeciality_consultation" | "superspeciality_details" | "test_report_notes" | "update_labs" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      barcode: {
        payload: Prisma.$barcodePayload<ExtArgs>
        fields: Prisma.barcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.barcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.barcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          findFirst: {
            args: Prisma.barcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.barcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          findMany: {
            args: Prisma.barcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>[]
          }
          create: {
            args: Prisma.barcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          createMany: {
            args: Prisma.barcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.barcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          update: {
            args: Prisma.barcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          deleteMany: {
            args: Prisma.barcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.barcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.barcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barcodePayload>
          }
          aggregate: {
            args: Prisma.BarcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarcode>
          }
          groupBy: {
            args: Prisma.barcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.barcodeCountArgs<ExtArgs>
            result: $Utils.Optional<BarcodeCountAggregateOutputType> | number
          }
        }
      }
      billing: {
        payload: Prisma.$billingPayload<ExtArgs>
        fields: Prisma.billingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.billingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.billingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          findFirst: {
            args: Prisma.billingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.billingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          findMany: {
            args: Prisma.billingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>[]
          }
          create: {
            args: Prisma.billingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          createMany: {
            args: Prisma.billingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.billingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          update: {
            args: Prisma.billingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          deleteMany: {
            args: Prisma.billingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.billingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.billingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billingPayload>
          }
          aggregate: {
            args: Prisma.BillingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilling>
          }
          groupBy: {
            args: Prisma.billingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingGroupByOutputType>[]
          }
          count: {
            args: Prisma.billingCountArgs<ExtArgs>
            result: $Utils.Optional<BillingCountAggregateOutputType> | number
          }
        }
      }
      billing_log: {
        payload: Prisma.$billing_logPayload<ExtArgs>
        fields: Prisma.billing_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.billing_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.billing_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          findFirst: {
            args: Prisma.billing_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.billing_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          findMany: {
            args: Prisma.billing_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>[]
          }
          create: {
            args: Prisma.billing_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          createMany: {
            args: Prisma.billing_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.billing_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          update: {
            args: Prisma.billing_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          deleteMany: {
            args: Prisma.billing_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.billing_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.billing_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_logPayload>
          }
          aggregate: {
            args: Prisma.Billing_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilling_log>
          }
          groupBy: {
            args: Prisma.billing_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Billing_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.billing_logCountArgs<ExtArgs>
            result: $Utils.Optional<Billing_logCountAggregateOutputType> | number
          }
        }
      }
      bloodgroup_details: {
        payload: Prisma.$bloodgroup_detailsPayload<ExtArgs>
        fields: Prisma.bloodgroup_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bloodgroup_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bloodgroup_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          findFirst: {
            args: Prisma.bloodgroup_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bloodgroup_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          findMany: {
            args: Prisma.bloodgroup_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>[]
          }
          create: {
            args: Prisma.bloodgroup_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          createMany: {
            args: Prisma.bloodgroup_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bloodgroup_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          update: {
            args: Prisma.bloodgroup_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          deleteMany: {
            args: Prisma.bloodgroup_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bloodgroup_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bloodgroup_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bloodgroup_detailsPayload>
          }
          aggregate: {
            args: Prisma.Bloodgroup_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBloodgroup_details>
          }
          groupBy: {
            args: Prisma.bloodgroup_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bloodgroup_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bloodgroup_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Bloodgroup_detailsCountAggregateOutputType> | number
          }
        }
      }
      city: {
        payload: Prisma.$cityPayload<ExtArgs>
        fields: Prisma.cityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          findFirst: {
            args: Prisma.cityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          findMany: {
            args: Prisma.cityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>[]
          }
          create: {
            args: Prisma.cityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          createMany: {
            args: Prisma.cityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          update: {
            args: Prisma.cityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          deleteMany: {
            args: Prisma.cityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.cityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.cityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      clinic_module_activation_request: {
        payload: Prisma.$clinic_module_activation_requestPayload<ExtArgs>
        fields: Prisma.clinic_module_activation_requestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinic_module_activation_requestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinic_module_activation_requestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          findFirst: {
            args: Prisma.clinic_module_activation_requestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinic_module_activation_requestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          findMany: {
            args: Prisma.clinic_module_activation_requestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>[]
          }
          create: {
            args: Prisma.clinic_module_activation_requestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          createMany: {
            args: Prisma.clinic_module_activation_requestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clinic_module_activation_requestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          update: {
            args: Prisma.clinic_module_activation_requestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          deleteMany: {
            args: Prisma.clinic_module_activation_requestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinic_module_activation_requestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clinic_module_activation_requestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_module_activation_requestPayload>
          }
          aggregate: {
            args: Prisma.Clinic_module_activation_requestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic_module_activation_request>
          }
          groupBy: {
            args: Prisma.clinic_module_activation_requestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clinic_module_activation_requestGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinic_module_activation_requestCountArgs<ExtArgs>
            result: $Utils.Optional<Clinic_module_activation_requestCountAggregateOutputType> | number
          }
        }
      }
      clinical_parameters: {
        payload: Prisma.$clinical_parametersPayload<ExtArgs>
        fields: Prisma.clinical_parametersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinical_parametersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinical_parametersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          findFirst: {
            args: Prisma.clinical_parametersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinical_parametersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          findMany: {
            args: Prisma.clinical_parametersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>[]
          }
          create: {
            args: Prisma.clinical_parametersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          createMany: {
            args: Prisma.clinical_parametersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clinical_parametersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          update: {
            args: Prisma.clinical_parametersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          deleteMany: {
            args: Prisma.clinical_parametersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinical_parametersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clinical_parametersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinical_parametersPayload>
          }
          aggregate: {
            args: Prisma.Clinical_parametersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinical_parameters>
          }
          groupBy: {
            args: Prisma.clinical_parametersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clinical_parametersGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinical_parametersCountArgs<ExtArgs>
            result: $Utils.Optional<Clinical_parametersCountAggregateOutputType> | number
          }
        }
      }
      contact: {
        payload: Prisma.$contactPayload<ExtArgs>
        fields: Prisma.contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findFirst: {
            args: Prisma.contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findMany: {
            args: Prisma.contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>[]
          }
          create: {
            args: Prisma.contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          createMany: {
            args: Prisma.contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          update: {
            args: Prisma.contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          deleteMany: {
            args: Prisma.contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      country: {
        payload: Prisma.$countryPayload<ExtArgs>
        fields: Prisma.countryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          findFirst: {
            args: Prisma.countryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          findMany: {
            args: Prisma.countryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>[]
          }
          create: {
            args: Prisma.countryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          createMany: {
            args: Prisma.countryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.countryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          update: {
            args: Prisma.countryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          deleteMany: {
            args: Prisma.countryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.countryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.countryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.countryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.countryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      files: {
        payload: Prisma.$filesPayload<ExtArgs>
        fields: Prisma.filesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findFirst: {
            args: Prisma.filesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findMany: {
            args: Prisma.filesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>[]
          }
          create: {
            args: Prisma.filesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          createMany: {
            args: Prisma.filesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.filesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          update: {
            args: Prisma.filesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          deleteMany: {
            args: Prisma.filesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.filesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.filesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          aggregate: {
            args: Prisma.FilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles>
          }
          groupBy: {
            args: Prisma.filesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.filesCountArgs<ExtArgs>
            result: $Utils.Optional<FilesCountAggregateOutputType> | number
          }
        }
      }
      investigation_details: {
        payload: Prisma.$investigation_detailsPayload<ExtArgs>
        fields: Prisma.investigation_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investigation_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investigation_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          findFirst: {
            args: Prisma.investigation_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investigation_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          findMany: {
            args: Prisma.investigation_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>[]
          }
          create: {
            args: Prisma.investigation_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          createMany: {
            args: Prisma.investigation_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.investigation_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          update: {
            args: Prisma.investigation_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          deleteMany: {
            args: Prisma.investigation_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investigation_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.investigation_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_detailsPayload>
          }
          aggregate: {
            args: Prisma.Investigation_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigation_details>
          }
          groupBy: {
            args: Prisma.investigation_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Investigation_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.investigation_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Investigation_detailsCountAggregateOutputType> | number
          }
        }
      }
      investigation_file: {
        payload: Prisma.$investigation_filePayload<ExtArgs>
        fields: Prisma.investigation_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investigation_fileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investigation_fileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          findFirst: {
            args: Prisma.investigation_fileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investigation_fileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          findMany: {
            args: Prisma.investigation_fileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>[]
          }
          create: {
            args: Prisma.investigation_fileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          createMany: {
            args: Prisma.investigation_fileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.investigation_fileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          update: {
            args: Prisma.investigation_fileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          deleteMany: {
            args: Prisma.investigation_fileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investigation_fileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.investigation_fileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_filePayload>
          }
          aggregate: {
            args: Prisma.Investigation_fileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigation_file>
          }
          groupBy: {
            args: Prisma.investigation_fileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Investigation_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.investigation_fileCountArgs<ExtArgs>
            result: $Utils.Optional<Investigation_fileCountAggregateOutputType> | number
          }
        }
      }
      investigation_test_details: {
        payload: Prisma.$investigation_test_detailsPayload<ExtArgs>
        fields: Prisma.investigation_test_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investigation_test_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investigation_test_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          findFirst: {
            args: Prisma.investigation_test_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investigation_test_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          findMany: {
            args: Prisma.investigation_test_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>[]
          }
          create: {
            args: Prisma.investigation_test_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          createMany: {
            args: Prisma.investigation_test_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.investigation_test_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          update: {
            args: Prisma.investigation_test_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          deleteMany: {
            args: Prisma.investigation_test_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investigation_test_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.investigation_test_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investigation_test_detailsPayload>
          }
          aggregate: {
            args: Prisma.Investigation_test_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigation_test_details>
          }
          groupBy: {
            args: Prisma.investigation_test_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Investigation_test_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.investigation_test_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Investigation_test_detailsCountAggregateOutputType> | number
          }
        }
      }
      lab_leaves: {
        payload: Prisma.$lab_leavesPayload<ExtArgs>
        fields: Prisma.lab_leavesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_leavesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_leavesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          findFirst: {
            args: Prisma.lab_leavesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_leavesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          findMany: {
            args: Prisma.lab_leavesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>[]
          }
          create: {
            args: Prisma.lab_leavesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          createMany: {
            args: Prisma.lab_leavesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lab_leavesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          update: {
            args: Prisma.lab_leavesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          deleteMany: {
            args: Prisma.lab_leavesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_leavesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lab_leavesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_leavesPayload>
          }
          aggregate: {
            args: Prisma.Lab_leavesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_leaves>
          }
          groupBy: {
            args: Prisma.lab_leavesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_leavesGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_leavesCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_leavesCountAggregateOutputType> | number
          }
        }
      }
      lab_tests_price_updates: {
        payload: Prisma.$lab_tests_price_updatesPayload<ExtArgs>
        fields: Prisma.lab_tests_price_updatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_tests_price_updatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_tests_price_updatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          findFirst: {
            args: Prisma.lab_tests_price_updatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_tests_price_updatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          findMany: {
            args: Prisma.lab_tests_price_updatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>[]
          }
          create: {
            args: Prisma.lab_tests_price_updatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          createMany: {
            args: Prisma.lab_tests_price_updatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lab_tests_price_updatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          update: {
            args: Prisma.lab_tests_price_updatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          deleteMany: {
            args: Prisma.lab_tests_price_updatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_tests_price_updatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lab_tests_price_updatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_tests_price_updatesPayload>
          }
          aggregate: {
            args: Prisma.Lab_tests_price_updatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_tests_price_updates>
          }
          groupBy: {
            args: Prisma.lab_tests_price_updatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_tests_price_updatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_tests_price_updatesCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_tests_price_updatesCountAggregateOutputType> | number
          }
        }
      }
      lab_timings: {
        payload: Prisma.$lab_timingsPayload<ExtArgs>
        fields: Prisma.lab_timingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_timingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_timingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          findFirst: {
            args: Prisma.lab_timingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_timingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          findMany: {
            args: Prisma.lab_timingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>[]
          }
          create: {
            args: Prisma.lab_timingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          createMany: {
            args: Prisma.lab_timingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lab_timingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          update: {
            args: Prisma.lab_timingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          deleteMany: {
            args: Prisma.lab_timingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_timingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lab_timingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_timingsPayload>
          }
          aggregate: {
            args: Prisma.Lab_timingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_timings>
          }
          groupBy: {
            args: Prisma.lab_timingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_timingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_timingsCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_timingsCountAggregateOutputType> | number
          }
        }
      }
      laboratory_details: {
        payload: Prisma.$laboratory_detailsPayload<ExtArgs>
        fields: Prisma.laboratory_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.laboratory_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.laboratory_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          findFirst: {
            args: Prisma.laboratory_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.laboratory_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          findMany: {
            args: Prisma.laboratory_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>[]
          }
          create: {
            args: Prisma.laboratory_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          createMany: {
            args: Prisma.laboratory_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.laboratory_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          update: {
            args: Prisma.laboratory_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          deleteMany: {
            args: Prisma.laboratory_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.laboratory_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.laboratory_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_detailsPayload>
          }
          aggregate: {
            args: Prisma.Laboratory_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaboratory_details>
          }
          groupBy: {
            args: Prisma.laboratory_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.laboratory_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_detailsCountAggregateOutputType> | number
          }
        }
      }
      laboratory_doctors: {
        payload: Prisma.$laboratory_doctorsPayload<ExtArgs>
        fields: Prisma.laboratory_doctorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.laboratory_doctorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.laboratory_doctorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          findFirst: {
            args: Prisma.laboratory_doctorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.laboratory_doctorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          findMany: {
            args: Prisma.laboratory_doctorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>[]
          }
          create: {
            args: Prisma.laboratory_doctorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          createMany: {
            args: Prisma.laboratory_doctorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.laboratory_doctorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          update: {
            args: Prisma.laboratory_doctorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          deleteMany: {
            args: Prisma.laboratory_doctorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.laboratory_doctorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.laboratory_doctorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_doctorsPayload>
          }
          aggregate: {
            args: Prisma.Laboratory_doctorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaboratory_doctors>
          }
          groupBy: {
            args: Prisma.laboratory_doctorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_doctorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.laboratory_doctorsCountArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_doctorsCountAggregateOutputType> | number
          }
        }
      }
      laboratory_test_details: {
        payload: Prisma.$laboratory_test_detailsPayload<ExtArgs>
        fields: Prisma.laboratory_test_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.laboratory_test_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.laboratory_test_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          findFirst: {
            args: Prisma.laboratory_test_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.laboratory_test_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          findMany: {
            args: Prisma.laboratory_test_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>[]
          }
          create: {
            args: Prisma.laboratory_test_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          createMany: {
            args: Prisma.laboratory_test_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.laboratory_test_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          update: {
            args: Prisma.laboratory_test_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          deleteMany: {
            args: Prisma.laboratory_test_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.laboratory_test_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.laboratory_test_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$laboratory_test_detailsPayload>
          }
          aggregate: {
            args: Prisma.Laboratory_test_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaboratory_test_details>
          }
          groupBy: {
            args: Prisma.laboratory_test_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_test_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.laboratory_test_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Laboratory_test_detailsCountAggregateOutputType> | number
          }
        }
      }
      locality: {
        payload: Prisma.$localityPayload<ExtArgs>
        fields: Prisma.localityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.localityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.localityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          findFirst: {
            args: Prisma.localityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.localityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          findMany: {
            args: Prisma.localityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>[]
          }
          create: {
            args: Prisma.localityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          createMany: {
            args: Prisma.localityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.localityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          update: {
            args: Prisma.localityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          deleteMany: {
            args: Prisma.localityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.localityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.localityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localityPayload>
          }
          aggregate: {
            args: Prisma.LocalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocality>
          }
          groupBy: {
            args: Prisma.localityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.localityCountArgs<ExtArgs>
            result: $Utils.Optional<LocalityCountAggregateOutputType> | number
          }
        }
      }
      login_details: {
        payload: Prisma.$login_detailsPayload<ExtArgs>
        fields: Prisma.login_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.login_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.login_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          findFirst: {
            args: Prisma.login_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.login_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          findMany: {
            args: Prisma.login_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>[]
          }
          create: {
            args: Prisma.login_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          createMany: {
            args: Prisma.login_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.login_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          update: {
            args: Prisma.login_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          deleteMany: {
            args: Prisma.login_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.login_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.login_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_detailsPayload>
          }
          aggregate: {
            args: Prisma.Login_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogin_details>
          }
          groupBy: {
            args: Prisma.login_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Login_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.login_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Login_detailsCountAggregateOutputType> | number
          }
        }
      }
      medicine: {
        payload: Prisma.$medicinePayload<ExtArgs>
        fields: Prisma.medicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          findFirst: {
            args: Prisma.medicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          findMany: {
            args: Prisma.medicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>[]
          }
          create: {
            args: Prisma.medicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          createMany: {
            args: Prisma.medicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.medicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          update: {
            args: Prisma.medicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          deleteMany: {
            args: Prisma.medicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicinePayload>
          }
          aggregate: {
            args: Prisma.MedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicine>
          }
          groupBy: {
            args: Prisma.medicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineCountAggregateOutputType> | number
          }
        }
      }
      notification_keys: {
        payload: Prisma.$notification_keysPayload<ExtArgs>
        fields: Prisma.notification_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          findFirst: {
            args: Prisma.notification_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          findMany: {
            args: Prisma.notification_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>[]
          }
          create: {
            args: Prisma.notification_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          createMany: {
            args: Prisma.notification_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notification_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          update: {
            args: Prisma.notification_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          deleteMany: {
            args: Prisma.notification_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notification_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_keysPayload>
          }
          aggregate: {
            args: Prisma.Notification_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_keys>
          }
          groupBy: {
            args: Prisma.notification_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_keysCountAggregateOutputType> | number
          }
        }
      }
      notificationattempt: {
        payload: Prisma.$notificationattemptPayload<ExtArgs>
        fields: Prisma.notificationattemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationattemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationattemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          findFirst: {
            args: Prisma.notificationattemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationattemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          findMany: {
            args: Prisma.notificationattemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>[]
          }
          create: {
            args: Prisma.notificationattemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          createMany: {
            args: Prisma.notificationattemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationattemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          update: {
            args: Prisma.notificationattemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          deleteMany: {
            args: Prisma.notificationattemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationattemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationattemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationattemptPayload>
          }
          aggregate: {
            args: Prisma.NotificationattemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationattempt>
          }
          groupBy: {
            args: Prisma.notificationattemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationattemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationattemptCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationattemptCountAggregateOutputType> | number
          }
        }
      }
      Renamedpackage: {
        payload: Prisma.$RenamedpackagePayload<ExtArgs>
        fields: Prisma.RenamedpackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RenamedpackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RenamedpackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          findFirst: {
            args: Prisma.RenamedpackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RenamedpackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          findMany: {
            args: Prisma.RenamedpackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>[]
          }
          create: {
            args: Prisma.RenamedpackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          createMany: {
            args: Prisma.RenamedpackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RenamedpackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          update: {
            args: Prisma.RenamedpackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          deleteMany: {
            args: Prisma.RenamedpackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RenamedpackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RenamedpackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RenamedpackagePayload>
          }
          aggregate: {
            args: Prisma.RenamedpackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRenamedpackage>
          }
          groupBy: {
            args: Prisma.RenamedpackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RenamedpackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RenamedpackageCountArgs<ExtArgs>
            result: $Utils.Optional<RenamedpackageCountAggregateOutputType> | number
          }
        }
      }
      package_contains: {
        payload: Prisma.$package_containsPayload<ExtArgs>
        fields: Prisma.package_containsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.package_containsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.package_containsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          findFirst: {
            args: Prisma.package_containsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.package_containsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          findMany: {
            args: Prisma.package_containsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>[]
          }
          create: {
            args: Prisma.package_containsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          createMany: {
            args: Prisma.package_containsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.package_containsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          update: {
            args: Prisma.package_containsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          deleteMany: {
            args: Prisma.package_containsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.package_containsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.package_containsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_containsPayload>
          }
          aggregate: {
            args: Prisma.Package_containsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage_contains>
          }
          groupBy: {
            args: Prisma.package_containsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Package_containsGroupByOutputType>[]
          }
          count: {
            args: Prisma.package_containsCountArgs<ExtArgs>
            result: $Utils.Optional<Package_containsCountAggregateOutputType> | number
          }
        }
      }
      package_labs: {
        payload: Prisma.$package_labsPayload<ExtArgs>
        fields: Prisma.package_labsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.package_labsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.package_labsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          findFirst: {
            args: Prisma.package_labsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.package_labsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          findMany: {
            args: Prisma.package_labsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>[]
          }
          create: {
            args: Prisma.package_labsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          createMany: {
            args: Prisma.package_labsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.package_labsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          update: {
            args: Prisma.package_labsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          deleteMany: {
            args: Prisma.package_labsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.package_labsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.package_labsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_labsPayload>
          }
          aggregate: {
            args: Prisma.Package_labsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage_labs>
          }
          groupBy: {
            args: Prisma.package_labsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Package_labsGroupByOutputType>[]
          }
          count: {
            args: Prisma.package_labsCountArgs<ExtArgs>
            result: $Utils.Optional<Package_labsCountAggregateOutputType> | number
          }
        }
      }
      package_queue: {
        payload: Prisma.$package_queuePayload<ExtArgs>
        fields: Prisma.package_queueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.package_queueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.package_queueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          findFirst: {
            args: Prisma.package_queueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.package_queueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          findMany: {
            args: Prisma.package_queueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>[]
          }
          create: {
            args: Prisma.package_queueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          createMany: {
            args: Prisma.package_queueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.package_queueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          update: {
            args: Prisma.package_queueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          deleteMany: {
            args: Prisma.package_queueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.package_queueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.package_queueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$package_queuePayload>
          }
          aggregate: {
            args: Prisma.Package_queueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage_queue>
          }
          groupBy: {
            args: Prisma.package_queueGroupByArgs<ExtArgs>
            result: $Utils.Optional<Package_queueGroupByOutputType>[]
          }
          count: {
            args: Prisma.package_queueCountArgs<ExtArgs>
            result: $Utils.Optional<Package_queueCountAggregateOutputType> | number
          }
        }
      }
      patient_dep_details: {
        payload: Prisma.$patient_dep_detailsPayload<ExtArgs>
        fields: Prisma.patient_dep_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_dep_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_dep_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          findFirst: {
            args: Prisma.patient_dep_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_dep_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          findMany: {
            args: Prisma.patient_dep_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>[]
          }
          create: {
            args: Prisma.patient_dep_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          createMany: {
            args: Prisma.patient_dep_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.patient_dep_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          update: {
            args: Prisma.patient_dep_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          deleteMany: {
            args: Prisma.patient_dep_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_dep_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.patient_dep_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_dep_detailsPayload>
          }
          aggregate: {
            args: Prisma.Patient_dep_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_dep_details>
          }
          groupBy: {
            args: Prisma.patient_dep_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_dep_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_dep_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_dep_detailsCountAggregateOutputType> | number
          }
        }
      }
      patient_doctor_mapping: {
        payload: Prisma.$patient_doctor_mappingPayload<ExtArgs>
        fields: Prisma.patient_doctor_mappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_doctor_mappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_doctor_mappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          findFirst: {
            args: Prisma.patient_doctor_mappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_doctor_mappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          findMany: {
            args: Prisma.patient_doctor_mappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>[]
          }
          create: {
            args: Prisma.patient_doctor_mappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          createMany: {
            args: Prisma.patient_doctor_mappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.patient_doctor_mappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          update: {
            args: Prisma.patient_doctor_mappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          deleteMany: {
            args: Prisma.patient_doctor_mappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_doctor_mappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.patient_doctor_mappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_doctor_mappingPayload>
          }
          aggregate: {
            args: Prisma.Patient_doctor_mappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_doctor_mapping>
          }
          groupBy: {
            args: Prisma.patient_doctor_mappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_doctor_mappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_doctor_mappingCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_doctor_mappingCountAggregateOutputType> | number
          }
        }
      }
      patient_parameter: {
        payload: Prisma.$patient_parameterPayload<ExtArgs>
        fields: Prisma.patient_parameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_parameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_parameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          findFirst: {
            args: Prisma.patient_parameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_parameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          findMany: {
            args: Prisma.patient_parameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>[]
          }
          create: {
            args: Prisma.patient_parameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          createMany: {
            args: Prisma.patient_parameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.patient_parameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          update: {
            args: Prisma.patient_parameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          deleteMany: {
            args: Prisma.patient_parameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_parameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.patient_parameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_parameterPayload>
          }
          aggregate: {
            args: Prisma.Patient_parameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_parameter>
          }
          groupBy: {
            args: Prisma.patient_parameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_parameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_parameterCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_parameterCountAggregateOutputType> | number
          }
        }
      }
      patientqueue: {
        payload: Prisma.$patientqueuePayload<ExtArgs>
        fields: Prisma.patientqueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientqueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientqueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          findFirst: {
            args: Prisma.patientqueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientqueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          findMany: {
            args: Prisma.patientqueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>[]
          }
          create: {
            args: Prisma.patientqueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          createMany: {
            args: Prisma.patientqueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.patientqueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          update: {
            args: Prisma.patientqueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          deleteMany: {
            args: Prisma.patientqueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientqueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.patientqueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientqueuePayload>
          }
          aggregate: {
            args: Prisma.PatientqueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientqueue>
          }
          groupBy: {
            args: Prisma.patientqueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientqueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientqueueCountArgs<ExtArgs>
            result: $Utils.Optional<PatientqueueCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      phy_admin: {
        payload: Prisma.$phy_adminPayload<ExtArgs>
        fields: Prisma.phy_adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.phy_adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.phy_adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          findFirst: {
            args: Prisma.phy_adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.phy_adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          findMany: {
            args: Prisma.phy_adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>[]
          }
          create: {
            args: Prisma.phy_adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          createMany: {
            args: Prisma.phy_adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.phy_adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          update: {
            args: Prisma.phy_adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          deleteMany: {
            args: Prisma.phy_adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.phy_adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.phy_adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$phy_adminPayload>
          }
          aggregate: {
            args: Prisma.Phy_adminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhy_admin>
          }
          groupBy: {
            args: Prisma.phy_adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<Phy_adminGroupByOutputType>[]
          }
          count: {
            args: Prisma.phy_adminCountArgs<ExtArgs>
            result: $Utils.Optional<Phy_adminCountAggregateOutputType> | number
          }
        }
      }
      physician_appointment: {
        payload: Prisma.$physician_appointmentPayload<ExtArgs>
        fields: Prisma.physician_appointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.physician_appointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.physician_appointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          findFirst: {
            args: Prisma.physician_appointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.physician_appointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          findMany: {
            args: Prisma.physician_appointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>[]
          }
          create: {
            args: Prisma.physician_appointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          createMany: {
            args: Prisma.physician_appointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.physician_appointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          update: {
            args: Prisma.physician_appointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          deleteMany: {
            args: Prisma.physician_appointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.physician_appointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.physician_appointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_appointmentPayload>
          }
          aggregate: {
            args: Prisma.Physician_appointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysician_appointment>
          }
          groupBy: {
            args: Prisma.physician_appointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Physician_appointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.physician_appointmentCountArgs<ExtArgs>
            result: $Utils.Optional<Physician_appointmentCountAggregateOutputType> | number
          }
        }
      }
      physician_clinic_timings: {
        payload: Prisma.$physician_clinic_timingsPayload<ExtArgs>
        fields: Prisma.physician_clinic_timingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.physician_clinic_timingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.physician_clinic_timingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          findFirst: {
            args: Prisma.physician_clinic_timingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.physician_clinic_timingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          findMany: {
            args: Prisma.physician_clinic_timingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>[]
          }
          create: {
            args: Prisma.physician_clinic_timingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          createMany: {
            args: Prisma.physician_clinic_timingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.physician_clinic_timingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          update: {
            args: Prisma.physician_clinic_timingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          deleteMany: {
            args: Prisma.physician_clinic_timingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.physician_clinic_timingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.physician_clinic_timingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_clinic_timingsPayload>
          }
          aggregate: {
            args: Prisma.Physician_clinic_timingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysician_clinic_timings>
          }
          groupBy: {
            args: Prisma.physician_clinic_timingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Physician_clinic_timingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.physician_clinic_timingsCountArgs<ExtArgs>
            result: $Utils.Optional<Physician_clinic_timingsCountAggregateOutputType> | number
          }
        }
      }
      physician_leaves: {
        payload: Prisma.$physician_leavesPayload<ExtArgs>
        fields: Prisma.physician_leavesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.physician_leavesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.physician_leavesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          findFirst: {
            args: Prisma.physician_leavesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.physician_leavesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          findMany: {
            args: Prisma.physician_leavesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>[]
          }
          create: {
            args: Prisma.physician_leavesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          createMany: {
            args: Prisma.physician_leavesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.physician_leavesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          update: {
            args: Prisma.physician_leavesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          deleteMany: {
            args: Prisma.physician_leavesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.physician_leavesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.physician_leavesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_leavesPayload>
          }
          aggregate: {
            args: Prisma.Physician_leavesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysician_leaves>
          }
          groupBy: {
            args: Prisma.physician_leavesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Physician_leavesGroupByOutputType>[]
          }
          count: {
            args: Prisma.physician_leavesCountArgs<ExtArgs>
            result: $Utils.Optional<Physician_leavesCountAggregateOutputType> | number
          }
        }
      }
      physician_timings: {
        payload: Prisma.$physician_timingsPayload<ExtArgs>
        fields: Prisma.physician_timingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.physician_timingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.physician_timingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          findFirst: {
            args: Prisma.physician_timingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.physician_timingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          findMany: {
            args: Prisma.physician_timingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>[]
          }
          create: {
            args: Prisma.physician_timingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          createMany: {
            args: Prisma.physician_timingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.physician_timingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          update: {
            args: Prisma.physician_timingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          deleteMany: {
            args: Prisma.physician_timingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.physician_timingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.physician_timingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$physician_timingsPayload>
          }
          aggregate: {
            args: Prisma.Physician_timingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysician_timings>
          }
          groupBy: {
            args: Prisma.physician_timingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Physician_timingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.physician_timingsCountArgs<ExtArgs>
            result: $Utils.Optional<Physician_timingsCountAggregateOutputType> | number
          }
        }
      }
      preferredlabs: {
        payload: Prisma.$preferredlabsPayload<ExtArgs>
        fields: Prisma.preferredlabsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preferredlabsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preferredlabsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          findFirst: {
            args: Prisma.preferredlabsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preferredlabsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          findMany: {
            args: Prisma.preferredlabsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>[]
          }
          create: {
            args: Prisma.preferredlabsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          createMany: {
            args: Prisma.preferredlabsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.preferredlabsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          update: {
            args: Prisma.preferredlabsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          deleteMany: {
            args: Prisma.preferredlabsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preferredlabsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.preferredlabsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferredlabsPayload>
          }
          aggregate: {
            args: Prisma.PreferredlabsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreferredlabs>
          }
          groupBy: {
            args: Prisma.preferredlabsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreferredlabsGroupByOutputType>[]
          }
          count: {
            args: Prisma.preferredlabsCountArgs<ExtArgs>
            result: $Utils.Optional<PreferredlabsCountAggregateOutputType> | number
          }
        }
      }
      prescription: {
        payload: Prisma.$prescriptionPayload<ExtArgs>
        fields: Prisma.prescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          findFirst: {
            args: Prisma.prescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          findMany: {
            args: Prisma.prescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>[]
          }
          create: {
            args: Prisma.prescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          createMany: {
            args: Prisma.prescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.prescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          update: {
            args: Prisma.prescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          deleteMany: {
            args: Prisma.prescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.prescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.prescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      prescription_medicine: {
        payload: Prisma.$prescription_medicinePayload<ExtArgs>
        fields: Prisma.prescription_medicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prescription_medicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prescription_medicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          findFirst: {
            args: Prisma.prescription_medicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prescription_medicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          findMany: {
            args: Prisma.prescription_medicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>[]
          }
          create: {
            args: Prisma.prescription_medicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          createMany: {
            args: Prisma.prescription_medicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.prescription_medicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          update: {
            args: Prisma.prescription_medicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          deleteMany: {
            args: Prisma.prescription_medicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prescription_medicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prescription_medicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescription_medicinePayload>
          }
          aggregate: {
            args: Prisma.Prescription_medicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription_medicine>
          }
          groupBy: {
            args: Prisma.prescription_medicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prescription_medicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.prescription_medicineCountArgs<ExtArgs>
            result: $Utils.Optional<Prescription_medicineCountAggregateOutputType> | number
          }
        }
      }
      qualification: {
        payload: Prisma.$qualificationPayload<ExtArgs>
        fields: Prisma.qualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          findFirst: {
            args: Prisma.qualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          findMany: {
            args: Prisma.qualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>[]
          }
          create: {
            args: Prisma.qualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          createMany: {
            args: Prisma.qualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          update: {
            args: Prisma.qualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          deleteMany: {
            args: Prisma.qualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualificationPayload>
          }
          aggregate: {
            args: Prisma.QualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualification>
          }
          groupBy: {
            args: Prisma.qualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.qualificationCountArgs<ExtArgs>
            result: $Utils.Optional<QualificationCountAggregateOutputType> | number
          }
        }
      }
      qualification_mapping: {
        payload: Prisma.$qualification_mappingPayload<ExtArgs>
        fields: Prisma.qualification_mappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qualification_mappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qualification_mappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          findFirst: {
            args: Prisma.qualification_mappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qualification_mappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          findMany: {
            args: Prisma.qualification_mappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>[]
          }
          create: {
            args: Prisma.qualification_mappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          createMany: {
            args: Prisma.qualification_mappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qualification_mappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          update: {
            args: Prisma.qualification_mappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          deleteMany: {
            args: Prisma.qualification_mappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qualification_mappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qualification_mappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualification_mappingPayload>
          }
          aggregate: {
            args: Prisma.Qualification_mappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualification_mapping>
          }
          groupBy: {
            args: Prisma.qualification_mappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qualification_mappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.qualification_mappingCountArgs<ExtArgs>
            result: $Utils.Optional<Qualification_mappingCountAggregateOutputType> | number
          }
        }
      }
      referral_confirmation_details: {
        payload: Prisma.$referral_confirmation_detailsPayload<ExtArgs>
        fields: Prisma.referral_confirmation_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_confirmation_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_confirmation_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          findFirst: {
            args: Prisma.referral_confirmation_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_confirmation_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          findMany: {
            args: Prisma.referral_confirmation_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>[]
          }
          create: {
            args: Prisma.referral_confirmation_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          createMany: {
            args: Prisma.referral_confirmation_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.referral_confirmation_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          update: {
            args: Prisma.referral_confirmation_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          deleteMany: {
            args: Prisma.referral_confirmation_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_confirmation_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.referral_confirmation_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_detailsPayload>
          }
          aggregate: {
            args: Prisma.Referral_confirmation_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_confirmation_details>
          }
          groupBy: {
            args: Prisma.referral_confirmation_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_confirmation_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_confirmation_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Referral_confirmation_detailsCountAggregateOutputType> | number
          }
        }
      }
      referral_confirmation_details1: {
        payload: Prisma.$referral_confirmation_details1Payload<ExtArgs>
        fields: Prisma.referral_confirmation_details1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_confirmation_details1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_confirmation_details1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          findFirst: {
            args: Prisma.referral_confirmation_details1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_confirmation_details1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          findMany: {
            args: Prisma.referral_confirmation_details1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>[]
          }
          create: {
            args: Prisma.referral_confirmation_details1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          createMany: {
            args: Prisma.referral_confirmation_details1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.referral_confirmation_details1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          update: {
            args: Prisma.referral_confirmation_details1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          deleteMany: {
            args: Prisma.referral_confirmation_details1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_confirmation_details1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.referral_confirmation_details1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_confirmation_details1Payload>
          }
          aggregate: {
            args: Prisma.Referral_confirmation_details1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_confirmation_details1>
          }
          groupBy: {
            args: Prisma.referral_confirmation_details1GroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_confirmation_details1GroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_confirmation_details1CountArgs<ExtArgs>
            result: $Utils.Optional<Referral_confirmation_details1CountAggregateOutputType> | number
          }
        }
      }
      referral_patient_details: {
        payload: Prisma.$referral_patient_detailsPayload<ExtArgs>
        fields: Prisma.referral_patient_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_patient_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_patient_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          findFirst: {
            args: Prisma.referral_patient_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_patient_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          findMany: {
            args: Prisma.referral_patient_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>[]
          }
          create: {
            args: Prisma.referral_patient_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          createMany: {
            args: Prisma.referral_patient_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.referral_patient_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          update: {
            args: Prisma.referral_patient_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          deleteMany: {
            args: Prisma.referral_patient_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_patient_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.referral_patient_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_detailsPayload>
          }
          aggregate: {
            args: Prisma.Referral_patient_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_patient_details>
          }
          groupBy: {
            args: Prisma.referral_patient_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_patient_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_patient_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Referral_patient_detailsCountAggregateOutputType> | number
          }
        }
      }
      referral_patient_test_details: {
        payload: Prisma.$referral_patient_test_detailsPayload<ExtArgs>
        fields: Prisma.referral_patient_test_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_patient_test_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_patient_test_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          findFirst: {
            args: Prisma.referral_patient_test_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_patient_test_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          findMany: {
            args: Prisma.referral_patient_test_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>[]
          }
          create: {
            args: Prisma.referral_patient_test_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          createMany: {
            args: Prisma.referral_patient_test_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.referral_patient_test_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          update: {
            args: Prisma.referral_patient_test_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          deleteMany: {
            args: Prisma.referral_patient_test_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_patient_test_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.referral_patient_test_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_patient_test_detailsPayload>
          }
          aggregate: {
            args: Prisma.Referral_patient_test_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_patient_test_details>
          }
          groupBy: {
            args: Prisma.referral_patient_test_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_patient_test_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_patient_test_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Referral_patient_test_detailsCountAggregateOutputType> | number
          }
        }
      }
      relationship: {
        payload: Prisma.$relationshipPayload<ExtArgs>
        fields: Prisma.relationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.relationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.relationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          findFirst: {
            args: Prisma.relationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.relationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          findMany: {
            args: Prisma.relationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>[]
          }
          create: {
            args: Prisma.relationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          createMany: {
            args: Prisma.relationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.relationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          update: {
            args: Prisma.relationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          deleteMany: {
            args: Prisma.relationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.relationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.relationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$relationshipPayload>
          }
          aggregate: {
            args: Prisma.RelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationship>
          }
          groupBy: {
            args: Prisma.relationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.relationshipCountArgs<ExtArgs>
            result: $Utils.Optional<RelationshipCountAggregateOutputType> | number
          }
        }
      }
      report_template: {
        payload: Prisma.$report_templatePayload<ExtArgs>
        fields: Prisma.report_templateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.report_templateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.report_templateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          findFirst: {
            args: Prisma.report_templateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.report_templateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          findMany: {
            args: Prisma.report_templateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>[]
          }
          create: {
            args: Prisma.report_templateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          createMany: {
            args: Prisma.report_templateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.report_templateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          update: {
            args: Prisma.report_templateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          deleteMany: {
            args: Prisma.report_templateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.report_templateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.report_templateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_templatePayload>
          }
          aggregate: {
            args: Prisma.Report_templateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport_template>
          }
          groupBy: {
            args: Prisma.report_templateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Report_templateGroupByOutputType>[]
          }
          count: {
            args: Prisma.report_templateCountArgs<ExtArgs>
            result: $Utils.Optional<Report_templateCountAggregateOutputType> | number
          }
        }
      }
      sample_results: {
        payload: Prisma.$sample_resultsPayload<ExtArgs>
        fields: Prisma.sample_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sample_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sample_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          findFirst: {
            args: Prisma.sample_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sample_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          findMany: {
            args: Prisma.sample_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>[]
          }
          create: {
            args: Prisma.sample_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          createMany: {
            args: Prisma.sample_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sample_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          update: {
            args: Prisma.sample_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          deleteMany: {
            args: Prisma.sample_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sample_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sample_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sample_resultsPayload>
          }
          aggregate: {
            args: Prisma.Sample_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSample_results>
          }
          groupBy: {
            args: Prisma.sample_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sample_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sample_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Sample_resultsCountAggregateOutputType> | number
          }
        }
      }
      ssconsultation_billing: {
        payload: Prisma.$ssconsultation_billingPayload<ExtArgs>
        fields: Prisma.ssconsultation_billingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ssconsultation_billingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ssconsultation_billingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          findFirst: {
            args: Prisma.ssconsultation_billingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ssconsultation_billingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          findMany: {
            args: Prisma.ssconsultation_billingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>[]
          }
          create: {
            args: Prisma.ssconsultation_billingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          createMany: {
            args: Prisma.ssconsultation_billingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ssconsultation_billingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          update: {
            args: Prisma.ssconsultation_billingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          deleteMany: {
            args: Prisma.ssconsultation_billingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ssconsultation_billingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ssconsultation_billingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_billingPayload>
          }
          aggregate: {
            args: Prisma.Ssconsultation_billingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSsconsultation_billing>
          }
          groupBy: {
            args: Prisma.ssconsultation_billingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ssconsultation_billingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ssconsultation_billingCountArgs<ExtArgs>
            result: $Utils.Optional<Ssconsultation_billingCountAggregateOutputType> | number
          }
        }
      }
      ssconsultation_log: {
        payload: Prisma.$ssconsultation_logPayload<ExtArgs>
        fields: Prisma.ssconsultation_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ssconsultation_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ssconsultation_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          findFirst: {
            args: Prisma.ssconsultation_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ssconsultation_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          findMany: {
            args: Prisma.ssconsultation_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>[]
          }
          create: {
            args: Prisma.ssconsultation_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          createMany: {
            args: Prisma.ssconsultation_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ssconsultation_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          update: {
            args: Prisma.ssconsultation_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          deleteMany: {
            args: Prisma.ssconsultation_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ssconsultation_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ssconsultation_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ssconsultation_logPayload>
          }
          aggregate: {
            args: Prisma.Ssconsultation_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSsconsultation_log>
          }
          groupBy: {
            args: Prisma.ssconsultation_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ssconsultation_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.ssconsultation_logCountArgs<ExtArgs>
            result: $Utils.Optional<Ssconsultation_logCountAggregateOutputType> | number
          }
        }
      }
      state: {
        payload: Prisma.$statePayload<ExtArgs>
        fields: Prisma.stateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          findFirst: {
            args: Prisma.stateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          findMany: {
            args: Prisma.stateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>[]
          }
          create: {
            args: Prisma.stateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          createMany: {
            args: Prisma.stateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.stateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          update: {
            args: Prisma.stateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          deleteMany: {
            args: Prisma.stateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.stateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          aggregate: {
            args: Prisma.StateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateState>
          }
          groupBy: {
            args: Prisma.stateGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateGroupByOutputType>[]
          }
          count: {
            args: Prisma.stateCountArgs<ExtArgs>
            result: $Utils.Optional<StateCountAggregateOutputType> | number
          }
        }
      }
      status_master: {
        payload: Prisma.$status_masterPayload<ExtArgs>
        fields: Prisma.status_masterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.status_masterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.status_masterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          findFirst: {
            args: Prisma.status_masterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.status_masterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          findMany: {
            args: Prisma.status_masterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>[]
          }
          create: {
            args: Prisma.status_masterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          createMany: {
            args: Prisma.status_masterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.status_masterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          update: {
            args: Prisma.status_masterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          deleteMany: {
            args: Prisma.status_masterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.status_masterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.status_masterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_masterPayload>
          }
          aggregate: {
            args: Prisma.Status_masterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatus_master>
          }
          groupBy: {
            args: Prisma.status_masterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Status_masterGroupByOutputType>[]
          }
          count: {
            args: Prisma.status_masterCountArgs<ExtArgs>
            result: $Utils.Optional<Status_masterCountAggregateOutputType> | number
          }
        }
      }
      super_speciality: {
        payload: Prisma.$super_specialityPayload<ExtArgs>
        fields: Prisma.super_specialityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.super_specialityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.super_specialityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          findFirst: {
            args: Prisma.super_specialityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.super_specialityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          findMany: {
            args: Prisma.super_specialityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>[]
          }
          create: {
            args: Prisma.super_specialityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          createMany: {
            args: Prisma.super_specialityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.super_specialityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          update: {
            args: Prisma.super_specialityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          deleteMany: {
            args: Prisma.super_specialityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.super_specialityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.super_specialityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$super_specialityPayload>
          }
          aggregate: {
            args: Prisma.Super_specialityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuper_speciality>
          }
          groupBy: {
            args: Prisma.super_specialityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Super_specialityGroupByOutputType>[]
          }
          count: {
            args: Prisma.super_specialityCountArgs<ExtArgs>
            result: $Utils.Optional<Super_specialityCountAggregateOutputType> | number
          }
        }
      }
      superspeciality_consultation: {
        payload: Prisma.$superspeciality_consultationPayload<ExtArgs>
        fields: Prisma.superspeciality_consultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.superspeciality_consultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.superspeciality_consultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          findFirst: {
            args: Prisma.superspeciality_consultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.superspeciality_consultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          findMany: {
            args: Prisma.superspeciality_consultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>[]
          }
          create: {
            args: Prisma.superspeciality_consultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          createMany: {
            args: Prisma.superspeciality_consultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.superspeciality_consultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          update: {
            args: Prisma.superspeciality_consultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          deleteMany: {
            args: Prisma.superspeciality_consultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.superspeciality_consultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.superspeciality_consultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_consultationPayload>
          }
          aggregate: {
            args: Prisma.Superspeciality_consultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperspeciality_consultation>
          }
          groupBy: {
            args: Prisma.superspeciality_consultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Superspeciality_consultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.superspeciality_consultationCountArgs<ExtArgs>
            result: $Utils.Optional<Superspeciality_consultationCountAggregateOutputType> | number
          }
        }
      }
      superspeciality_details: {
        payload: Prisma.$superspeciality_detailsPayload<ExtArgs>
        fields: Prisma.superspeciality_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.superspeciality_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.superspeciality_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          findFirst: {
            args: Prisma.superspeciality_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.superspeciality_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          findMany: {
            args: Prisma.superspeciality_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>[]
          }
          create: {
            args: Prisma.superspeciality_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          createMany: {
            args: Prisma.superspeciality_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.superspeciality_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          update: {
            args: Prisma.superspeciality_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          deleteMany: {
            args: Prisma.superspeciality_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.superspeciality_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.superspeciality_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superspeciality_detailsPayload>
          }
          aggregate: {
            args: Prisma.Superspeciality_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperspeciality_details>
          }
          groupBy: {
            args: Prisma.superspeciality_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Superspeciality_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.superspeciality_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Superspeciality_detailsCountAggregateOutputType> | number
          }
        }
      }
      test_report_notes: {
        payload: Prisma.$test_report_notesPayload<ExtArgs>
        fields: Prisma.test_report_notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_report_notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_report_notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          findFirst: {
            args: Prisma.test_report_notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_report_notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          findMany: {
            args: Prisma.test_report_notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>[]
          }
          create: {
            args: Prisma.test_report_notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          createMany: {
            args: Prisma.test_report_notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_report_notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          update: {
            args: Prisma.test_report_notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          deleteMany: {
            args: Prisma.test_report_notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_report_notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_report_notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_report_notesPayload>
          }
          aggregate: {
            args: Prisma.Test_report_notesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_report_notes>
          }
          groupBy: {
            args: Prisma.test_report_notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_report_notesGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_report_notesCountArgs<ExtArgs>
            result: $Utils.Optional<Test_report_notesCountAggregateOutputType> | number
          }
        }
      }
      update_labs: {
        payload: Prisma.$update_labsPayload<ExtArgs>
        fields: Prisma.update_labsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.update_labsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.update_labsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          findFirst: {
            args: Prisma.update_labsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.update_labsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          findMany: {
            args: Prisma.update_labsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>[]
          }
          create: {
            args: Prisma.update_labsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          createMany: {
            args: Prisma.update_labsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.update_labsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          update: {
            args: Prisma.update_labsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          deleteMany: {
            args: Prisma.update_labsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.update_labsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.update_labsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$update_labsPayload>
          }
          aggregate: {
            args: Prisma.Update_labsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdate_labs>
          }
          groupBy: {
            args: Prisma.update_labsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Update_labsGroupByOutputType>[]
          }
          count: {
            args: Prisma.update_labsCountArgs<ExtArgs>
            result: $Utils.Optional<Update_labsCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Investigation_detailsCountOutputType
   */

  export type Investigation_detailsCountOutputType = {
    investigation_test_details: number
  }

  export type Investigation_detailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigation_test_details?: boolean | Investigation_detailsCountOutputTypeCountInvestigation_test_detailsArgs
  }

  // Custom InputTypes
  /**
   * Investigation_detailsCountOutputType without action
   */
  export type Investigation_detailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation_detailsCountOutputType
     */
    select?: Investigation_detailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Investigation_detailsCountOutputType without action
   */
  export type Investigation_detailsCountOutputTypeCountInvestigation_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investigation_test_detailsWhereInput
  }


  /**
   * Count Type Laboratory_detailsCountOutputType
   */

  export type Laboratory_detailsCountOutputType = {
    laboratory_test_details: number
  }

  export type Laboratory_detailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laboratory_test_details?: boolean | Laboratory_detailsCountOutputTypeCountLaboratory_test_detailsArgs
  }

  // Custom InputTypes
  /**
   * Laboratory_detailsCountOutputType without action
   */
  export type Laboratory_detailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laboratory_detailsCountOutputType
     */
    select?: Laboratory_detailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Laboratory_detailsCountOutputType without action
   */
  export type Laboratory_detailsCountOutputTypeCountLaboratory_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: laboratory_test_detailsWhereInput
  }


  /**
   * Count Type Physician_appointmentCountOutputType
   */

  export type Physician_appointmentCountOutputType = {
    phy_admin: number
  }

  export type Physician_appointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phy_admin?: boolean | Physician_appointmentCountOutputTypeCountPhy_adminArgs
  }

  // Custom InputTypes
  /**
   * Physician_appointmentCountOutputType without action
   */
  export type Physician_appointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician_appointmentCountOutputType
     */
    select?: Physician_appointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Physician_appointmentCountOutputType without action
   */
  export type Physician_appointmentCountOutputTypeCountPhy_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: phy_adminWhereInput
  }


  /**
   * Models
   */

  /**
   * Model barcode
   */

  export type AggregateBarcode = {
    _count: BarcodeCountAggregateOutputType | null
    _avg: BarcodeAvgAggregateOutputType | null
    _sum: BarcodeSumAggregateOutputType | null
    _min: BarcodeMinAggregateOutputType | null
    _max: BarcodeMaxAggregateOutputType | null
  }

  export type BarcodeAvgAggregateOutputType = {
    barcode_id: number | null
    billing_id: number | null
  }

  export type BarcodeSumAggregateOutputType = {
    barcode_id: number | null
    billing_id: number | null
  }

  export type BarcodeMinAggregateOutputType = {
    barcode_id: number | null
    billing_id: number | null
    barcode: string | null
    barcode_image: string | null
    created_date: Date | null
  }

  export type BarcodeMaxAggregateOutputType = {
    barcode_id: number | null
    billing_id: number | null
    barcode: string | null
    barcode_image: string | null
    created_date: Date | null
  }

  export type BarcodeCountAggregateOutputType = {
    barcode_id: number
    billing_id: number
    barcode: number
    barcode_image: number
    created_date: number
    _all: number
  }


  export type BarcodeAvgAggregateInputType = {
    barcode_id?: true
    billing_id?: true
  }

  export type BarcodeSumAggregateInputType = {
    barcode_id?: true
    billing_id?: true
  }

  export type BarcodeMinAggregateInputType = {
    barcode_id?: true
    billing_id?: true
    barcode?: true
    barcode_image?: true
    created_date?: true
  }

  export type BarcodeMaxAggregateInputType = {
    barcode_id?: true
    billing_id?: true
    barcode?: true
    barcode_image?: true
    created_date?: true
  }

  export type BarcodeCountAggregateInputType = {
    barcode_id?: true
    billing_id?: true
    barcode?: true
    barcode_image?: true
    created_date?: true
    _all?: true
  }

  export type BarcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barcode to aggregate.
     */
    where?: barcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodes to fetch.
     */
    orderBy?: barcodeOrderByWithRelationInput | barcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: barcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned barcodes
    **/
    _count?: true | BarcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarcodeMaxAggregateInputType
  }

  export type GetBarcodeAggregateType<T extends BarcodeAggregateArgs> = {
        [P in keyof T & keyof AggregateBarcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarcode[P]>
      : GetScalarType<T[P], AggregateBarcode[P]>
  }




  export type barcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: barcodeWhereInput
    orderBy?: barcodeOrderByWithAggregationInput | barcodeOrderByWithAggregationInput[]
    by: BarcodeScalarFieldEnum[] | BarcodeScalarFieldEnum
    having?: barcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarcodeCountAggregateInputType | true
    _avg?: BarcodeAvgAggregateInputType
    _sum?: BarcodeSumAggregateInputType
    _min?: BarcodeMinAggregateInputType
    _max?: BarcodeMaxAggregateInputType
  }

  export type BarcodeGroupByOutputType = {
    barcode_id: number
    billing_id: number
    barcode: string
    barcode_image: string
    created_date: Date
    _count: BarcodeCountAggregateOutputType | null
    _avg: BarcodeAvgAggregateOutputType | null
    _sum: BarcodeSumAggregateOutputType | null
    _min: BarcodeMinAggregateOutputType | null
    _max: BarcodeMaxAggregateOutputType | null
  }

  type GetBarcodeGroupByPayload<T extends barcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarcodeGroupByOutputType[P]>
            : GetScalarType<T[P], BarcodeGroupByOutputType[P]>
        }
      >
    >


  export type barcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    barcode_id?: boolean
    billing_id?: boolean
    barcode?: boolean
    barcode_image?: boolean
    created_date?: boolean
  }, ExtArgs["result"]["barcode"]>


  export type barcodeSelectScalar = {
    barcode_id?: boolean
    billing_id?: boolean
    barcode?: boolean
    barcode_image?: boolean
    created_date?: boolean
  }


  export type $barcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "barcode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      barcode_id: number
      billing_id: number
      barcode: string
      barcode_image: string
      created_date: Date
    }, ExtArgs["result"]["barcode"]>
    composites: {}
  }

  type barcodeGetPayload<S extends boolean | null | undefined | barcodeDefaultArgs> = $Result.GetResult<Prisma.$barcodePayload, S>

  type barcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<barcodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BarcodeCountAggregateInputType | true
    }

  export interface barcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['barcode'], meta: { name: 'barcode' } }
    /**
     * Find zero or one Barcode that matches the filter.
     * @param {barcodeFindUniqueArgs} args - Arguments to find a Barcode
     * @example
     * // Get one Barcode
     * const barcode = await prisma.barcode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends barcodeFindUniqueArgs>(args: SelectSubset<T, barcodeFindUniqueArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Barcode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {barcodeFindUniqueOrThrowArgs} args - Arguments to find a Barcode
     * @example
     * // Get one Barcode
     * const barcode = await prisma.barcode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends barcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, barcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Barcode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeFindFirstArgs} args - Arguments to find a Barcode
     * @example
     * // Get one Barcode
     * const barcode = await prisma.barcode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends barcodeFindFirstArgs>(args?: SelectSubset<T, barcodeFindFirstArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Barcode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeFindFirstOrThrowArgs} args - Arguments to find a Barcode
     * @example
     * // Get one Barcode
     * const barcode = await prisma.barcode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends barcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, barcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Barcodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barcodes
     * const barcodes = await prisma.barcode.findMany()
     * 
     * // Get first 10 Barcodes
     * const barcodes = await prisma.barcode.findMany({ take: 10 })
     * 
     * // Only select the `barcode_id`
     * const barcodeWithBarcode_idOnly = await prisma.barcode.findMany({ select: { barcode_id: true } })
     * 
     */
    findMany<T extends barcodeFindManyArgs>(args?: SelectSubset<T, barcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Barcode.
     * @param {barcodeCreateArgs} args - Arguments to create a Barcode.
     * @example
     * // Create one Barcode
     * const Barcode = await prisma.barcode.create({
     *   data: {
     *     // ... data to create a Barcode
     *   }
     * })
     * 
     */
    create<T extends barcodeCreateArgs>(args: SelectSubset<T, barcodeCreateArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Barcodes.
     * @param {barcodeCreateManyArgs} args - Arguments to create many Barcodes.
     * @example
     * // Create many Barcodes
     * const barcode = await prisma.barcode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends barcodeCreateManyArgs>(args?: SelectSubset<T, barcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Barcode.
     * @param {barcodeDeleteArgs} args - Arguments to delete one Barcode.
     * @example
     * // Delete one Barcode
     * const Barcode = await prisma.barcode.delete({
     *   where: {
     *     // ... filter to delete one Barcode
     *   }
     * })
     * 
     */
    delete<T extends barcodeDeleteArgs>(args: SelectSubset<T, barcodeDeleteArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Barcode.
     * @param {barcodeUpdateArgs} args - Arguments to update one Barcode.
     * @example
     * // Update one Barcode
     * const barcode = await prisma.barcode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends barcodeUpdateArgs>(args: SelectSubset<T, barcodeUpdateArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Barcodes.
     * @param {barcodeDeleteManyArgs} args - Arguments to filter Barcodes to delete.
     * @example
     * // Delete a few Barcodes
     * const { count } = await prisma.barcode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends barcodeDeleteManyArgs>(args?: SelectSubset<T, barcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Barcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barcodes
     * const barcode = await prisma.barcode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends barcodeUpdateManyArgs>(args: SelectSubset<T, barcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Barcode.
     * @param {barcodeUpsertArgs} args - Arguments to update or create a Barcode.
     * @example
     * // Update or create a Barcode
     * const barcode = await prisma.barcode.upsert({
     *   create: {
     *     // ... data to create a Barcode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barcode we want to update
     *   }
     * })
     */
    upsert<T extends barcodeUpsertArgs>(args: SelectSubset<T, barcodeUpsertArgs<ExtArgs>>): Prisma__barcodeClient<$Result.GetResult<Prisma.$barcodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Barcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeCountArgs} args - Arguments to filter Barcodes to count.
     * @example
     * // Count the number of Barcodes
     * const count = await prisma.barcode.count({
     *   where: {
     *     // ... the filter for the Barcodes we want to count
     *   }
     * })
    **/
    count<T extends barcodeCountArgs>(
      args?: Subset<T, barcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Barcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarcodeAggregateArgs>(args: Subset<T, BarcodeAggregateArgs>): Prisma.PrismaPromise<GetBarcodeAggregateType<T>>

    /**
     * Group by Barcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends barcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: barcodeGroupByArgs['orderBy'] }
        : { orderBy?: barcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, barcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the barcode model
   */
  readonly fields: barcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for barcode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__barcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the barcode model
   */ 
  interface barcodeFieldRefs {
    readonly barcode_id: FieldRef<"barcode", 'Int'>
    readonly billing_id: FieldRef<"barcode", 'Int'>
    readonly barcode: FieldRef<"barcode", 'String'>
    readonly barcode_image: FieldRef<"barcode", 'String'>
    readonly created_date: FieldRef<"barcode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * barcode findUnique
   */
  export type barcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter, which barcode to fetch.
     */
    where: barcodeWhereUniqueInput
  }

  /**
   * barcode findUniqueOrThrow
   */
  export type barcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter, which barcode to fetch.
     */
    where: barcodeWhereUniqueInput
  }

  /**
   * barcode findFirst
   */
  export type barcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter, which barcode to fetch.
     */
    where?: barcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodes to fetch.
     */
    orderBy?: barcodeOrderByWithRelationInput | barcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barcodes.
     */
    cursor?: barcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barcodes.
     */
    distinct?: BarcodeScalarFieldEnum | BarcodeScalarFieldEnum[]
  }

  /**
   * barcode findFirstOrThrow
   */
  export type barcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter, which barcode to fetch.
     */
    where?: barcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodes to fetch.
     */
    orderBy?: barcodeOrderByWithRelationInput | barcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barcodes.
     */
    cursor?: barcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barcodes.
     */
    distinct?: BarcodeScalarFieldEnum | BarcodeScalarFieldEnum[]
  }

  /**
   * barcode findMany
   */
  export type barcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter, which barcodes to fetch.
     */
    where?: barcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barcodes to fetch.
     */
    orderBy?: barcodeOrderByWithRelationInput | barcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing barcodes.
     */
    cursor?: barcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barcodes.
     */
    skip?: number
    distinct?: BarcodeScalarFieldEnum | BarcodeScalarFieldEnum[]
  }

  /**
   * barcode create
   */
  export type barcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * The data needed to create a barcode.
     */
    data: XOR<barcodeCreateInput, barcodeUncheckedCreateInput>
  }

  /**
   * barcode createMany
   */
  export type barcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many barcodes.
     */
    data: barcodeCreateManyInput | barcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * barcode update
   */
  export type barcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * The data needed to update a barcode.
     */
    data: XOR<barcodeUpdateInput, barcodeUncheckedUpdateInput>
    /**
     * Choose, which barcode to update.
     */
    where: barcodeWhereUniqueInput
  }

  /**
   * barcode updateMany
   */
  export type barcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update barcodes.
     */
    data: XOR<barcodeUpdateManyMutationInput, barcodeUncheckedUpdateManyInput>
    /**
     * Filter which barcodes to update
     */
    where?: barcodeWhereInput
  }

  /**
   * barcode upsert
   */
  export type barcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * The filter to search for the barcode to update in case it exists.
     */
    where: barcodeWhereUniqueInput
    /**
     * In case the barcode found by the `where` argument doesn't exist, create a new barcode with this data.
     */
    create: XOR<barcodeCreateInput, barcodeUncheckedCreateInput>
    /**
     * In case the barcode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<barcodeUpdateInput, barcodeUncheckedUpdateInput>
  }

  /**
   * barcode delete
   */
  export type barcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
    /**
     * Filter which barcode to delete.
     */
    where: barcodeWhereUniqueInput
  }

  /**
   * barcode deleteMany
   */
  export type barcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barcodes to delete
     */
    where?: barcodeWhereInput
  }

  /**
   * barcode without action
   */
  export type barcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barcode
     */
    select?: barcodeSelect<ExtArgs> | null
  }


  /**
   * Model billing
   */

  export type AggregateBilling = {
    _count: BillingCountAggregateOutputType | null
    _avg: BillingAvgAggregateOutputType | null
    _sum: BillingSumAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  export type BillingAvgAggregateOutputType = {
    billing_id: number | null
    discount_type: number | null
    lab_id: number | null
  }

  export type BillingSumAggregateOutputType = {
    billing_id: number | null
    discount_type: number | null
    lab_id: number | null
  }

  export type BillingMinAggregateOutputType = {
    billing_id: number | null
    laboratory_tests: string | null
    medical_num: string | null
    patient_unique_id: string | null
    tot_amt: string | null
    discount: string | null
    discount_type: number | null
    net_amt: string | null
    adv_amt: string | null
    balance_amt: string | null
    balance_pymnt2: string | null
    final_balance: string | null
    lab_id: number | null
    unique_billid: string | null
    created_on: string | null
  }

  export type BillingMaxAggregateOutputType = {
    billing_id: number | null
    laboratory_tests: string | null
    medical_num: string | null
    patient_unique_id: string | null
    tot_amt: string | null
    discount: string | null
    discount_type: number | null
    net_amt: string | null
    adv_amt: string | null
    balance_amt: string | null
    balance_pymnt2: string | null
    final_balance: string | null
    lab_id: number | null
    unique_billid: string | null
    created_on: string | null
  }

  export type BillingCountAggregateOutputType = {
    billing_id: number
    laboratory_tests: number
    medical_num: number
    patient_unique_id: number
    tot_amt: number
    discount: number
    discount_type: number
    net_amt: number
    adv_amt: number
    balance_amt: number
    balance_pymnt2: number
    final_balance: number
    lab_id: number
    unique_billid: number
    created_on: number
    _all: number
  }


  export type BillingAvgAggregateInputType = {
    billing_id?: true
    discount_type?: true
    lab_id?: true
  }

  export type BillingSumAggregateInputType = {
    billing_id?: true
    discount_type?: true
    lab_id?: true
  }

  export type BillingMinAggregateInputType = {
    billing_id?: true
    laboratory_tests?: true
    medical_num?: true
    patient_unique_id?: true
    tot_amt?: true
    discount?: true
    discount_type?: true
    net_amt?: true
    adv_amt?: true
    balance_amt?: true
    balance_pymnt2?: true
    final_balance?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
  }

  export type BillingMaxAggregateInputType = {
    billing_id?: true
    laboratory_tests?: true
    medical_num?: true
    patient_unique_id?: true
    tot_amt?: true
    discount?: true
    discount_type?: true
    net_amt?: true
    adv_amt?: true
    balance_amt?: true
    balance_pymnt2?: true
    final_balance?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
  }

  export type BillingCountAggregateInputType = {
    billing_id?: true
    laboratory_tests?: true
    medical_num?: true
    patient_unique_id?: true
    tot_amt?: true
    discount?: true
    discount_type?: true
    net_amt?: true
    adv_amt?: true
    balance_amt?: true
    balance_pymnt2?: true
    final_balance?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
    _all?: true
  }

  export type BillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billing to aggregate.
     */
    where?: billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billings to fetch.
     */
    orderBy?: billingOrderByWithRelationInput | billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned billings
    **/
    _count?: true | BillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingMaxAggregateInputType
  }

  export type GetBillingAggregateType<T extends BillingAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling[P]>
      : GetScalarType<T[P], AggregateBilling[P]>
  }




  export type billingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billingWhereInput
    orderBy?: billingOrderByWithAggregationInput | billingOrderByWithAggregationInput[]
    by: BillingScalarFieldEnum[] | BillingScalarFieldEnum
    having?: billingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingCountAggregateInputType | true
    _avg?: BillingAvgAggregateInputType
    _sum?: BillingSumAggregateInputType
    _min?: BillingMinAggregateInputType
    _max?: BillingMaxAggregateInputType
  }

  export type BillingGroupByOutputType = {
    billing_id: number
    laboratory_tests: string
    medical_num: string | null
    patient_unique_id: string | null
    tot_amt: string | null
    discount: string | null
    discount_type: number
    net_amt: string | null
    adv_amt: string
    balance_amt: string
    balance_pymnt2: string
    final_balance: string
    lab_id: number
    unique_billid: string
    created_on: string | null
    _count: BillingCountAggregateOutputType | null
    _avg: BillingAvgAggregateOutputType | null
    _sum: BillingSumAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  type GetBillingGroupByPayload<T extends billingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingGroupByOutputType[P]>
            : GetScalarType<T[P], BillingGroupByOutputType[P]>
        }
      >
    >


  export type billingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    billing_id?: boolean
    laboratory_tests?: boolean
    medical_num?: boolean
    patient_unique_id?: boolean
    tot_amt?: boolean
    discount?: boolean
    discount_type?: boolean
    net_amt?: boolean
    adv_amt?: boolean
    balance_amt?: boolean
    balance_pymnt2?: boolean
    final_balance?: boolean
    lab_id?: boolean
    unique_billid?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["billing"]>


  export type billingSelectScalar = {
    billing_id?: boolean
    laboratory_tests?: boolean
    medical_num?: boolean
    patient_unique_id?: boolean
    tot_amt?: boolean
    discount?: boolean
    discount_type?: boolean
    net_amt?: boolean
    adv_amt?: boolean
    balance_amt?: boolean
    balance_pymnt2?: boolean
    final_balance?: boolean
    lab_id?: boolean
    unique_billid?: boolean
    created_on?: boolean
  }


  export type $billingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "billing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      billing_id: number
      laboratory_tests: string
      medical_num: string | null
      patient_unique_id: string | null
      tot_amt: string | null
      discount: string | null
      discount_type: number
      net_amt: string | null
      adv_amt: string
      balance_amt: string
      balance_pymnt2: string
      final_balance: string
      lab_id: number
      unique_billid: string
      created_on: string | null
    }, ExtArgs["result"]["billing"]>
    composites: {}
  }

  type billingGetPayload<S extends boolean | null | undefined | billingDefaultArgs> = $Result.GetResult<Prisma.$billingPayload, S>

  type billingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<billingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingCountAggregateInputType | true
    }

  export interface billingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['billing'], meta: { name: 'billing' } }
    /**
     * Find zero or one Billing that matches the filter.
     * @param {billingFindUniqueArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends billingFindUniqueArgs>(args: SelectSubset<T, billingFindUniqueArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Billing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {billingFindUniqueOrThrowArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends billingFindUniqueOrThrowArgs>(args: SelectSubset<T, billingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Billing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingFindFirstArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends billingFindFirstArgs>(args?: SelectSubset<T, billingFindFirstArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Billing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingFindFirstOrThrowArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends billingFindFirstOrThrowArgs>(args?: SelectSubset<T, billingFindFirstOrThrowArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billings
     * const billings = await prisma.billing.findMany()
     * 
     * // Get first 10 Billings
     * const billings = await prisma.billing.findMany({ take: 10 })
     * 
     * // Only select the `billing_id`
     * const billingWithBilling_idOnly = await prisma.billing.findMany({ select: { billing_id: true } })
     * 
     */
    findMany<T extends billingFindManyArgs>(args?: SelectSubset<T, billingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Billing.
     * @param {billingCreateArgs} args - Arguments to create a Billing.
     * @example
     * // Create one Billing
     * const Billing = await prisma.billing.create({
     *   data: {
     *     // ... data to create a Billing
     *   }
     * })
     * 
     */
    create<T extends billingCreateArgs>(args: SelectSubset<T, billingCreateArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Billings.
     * @param {billingCreateManyArgs} args - Arguments to create many Billings.
     * @example
     * // Create many Billings
     * const billing = await prisma.billing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends billingCreateManyArgs>(args?: SelectSubset<T, billingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billing.
     * @param {billingDeleteArgs} args - Arguments to delete one Billing.
     * @example
     * // Delete one Billing
     * const Billing = await prisma.billing.delete({
     *   where: {
     *     // ... filter to delete one Billing
     *   }
     * })
     * 
     */
    delete<T extends billingDeleteArgs>(args: SelectSubset<T, billingDeleteArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Billing.
     * @param {billingUpdateArgs} args - Arguments to update one Billing.
     * @example
     * // Update one Billing
     * const billing = await prisma.billing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends billingUpdateArgs>(args: SelectSubset<T, billingUpdateArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Billings.
     * @param {billingDeleteManyArgs} args - Arguments to filter Billings to delete.
     * @example
     * // Delete a few Billings
     * const { count } = await prisma.billing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends billingDeleteManyArgs>(args?: SelectSubset<T, billingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billings
     * const billing = await prisma.billing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends billingUpdateManyArgs>(args: SelectSubset<T, billingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing.
     * @param {billingUpsertArgs} args - Arguments to update or create a Billing.
     * @example
     * // Update or create a Billing
     * const billing = await prisma.billing.upsert({
     *   create: {
     *     // ... data to create a Billing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing we want to update
     *   }
     * })
     */
    upsert<T extends billingUpsertArgs>(args: SelectSubset<T, billingUpsertArgs<ExtArgs>>): Prisma__billingClient<$Result.GetResult<Prisma.$billingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingCountArgs} args - Arguments to filter Billings to count.
     * @example
     * // Count the number of Billings
     * const count = await prisma.billing.count({
     *   where: {
     *     // ... the filter for the Billings we want to count
     *   }
     * })
    **/
    count<T extends billingCountArgs>(
      args?: Subset<T, billingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingAggregateArgs>(args: Subset<T, BillingAggregateArgs>): Prisma.PrismaPromise<GetBillingAggregateType<T>>

    /**
     * Group by Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends billingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: billingGroupByArgs['orderBy'] }
        : { orderBy?: billingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, billingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the billing model
   */
  readonly fields: billingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for billing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__billingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the billing model
   */ 
  interface billingFieldRefs {
    readonly billing_id: FieldRef<"billing", 'Int'>
    readonly laboratory_tests: FieldRef<"billing", 'String'>
    readonly medical_num: FieldRef<"billing", 'String'>
    readonly patient_unique_id: FieldRef<"billing", 'String'>
    readonly tot_amt: FieldRef<"billing", 'String'>
    readonly discount: FieldRef<"billing", 'String'>
    readonly discount_type: FieldRef<"billing", 'Int'>
    readonly net_amt: FieldRef<"billing", 'String'>
    readonly adv_amt: FieldRef<"billing", 'String'>
    readonly balance_amt: FieldRef<"billing", 'String'>
    readonly balance_pymnt2: FieldRef<"billing", 'String'>
    readonly final_balance: FieldRef<"billing", 'String'>
    readonly lab_id: FieldRef<"billing", 'Int'>
    readonly unique_billid: FieldRef<"billing", 'String'>
    readonly created_on: FieldRef<"billing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * billing findUnique
   */
  export type billingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter, which billing to fetch.
     */
    where: billingWhereUniqueInput
  }

  /**
   * billing findUniqueOrThrow
   */
  export type billingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter, which billing to fetch.
     */
    where: billingWhereUniqueInput
  }

  /**
   * billing findFirst
   */
  export type billingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter, which billing to fetch.
     */
    where?: billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billings to fetch.
     */
    orderBy?: billingOrderByWithRelationInput | billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billings.
     */
    cursor?: billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billings.
     */
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * billing findFirstOrThrow
   */
  export type billingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter, which billing to fetch.
     */
    where?: billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billings to fetch.
     */
    orderBy?: billingOrderByWithRelationInput | billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billings.
     */
    cursor?: billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billings.
     */
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * billing findMany
   */
  export type billingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter, which billings to fetch.
     */
    where?: billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billings to fetch.
     */
    orderBy?: billingOrderByWithRelationInput | billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing billings.
     */
    cursor?: billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billings.
     */
    skip?: number
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * billing create
   */
  export type billingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * The data needed to create a billing.
     */
    data: XOR<billingCreateInput, billingUncheckedCreateInput>
  }

  /**
   * billing createMany
   */
  export type billingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many billings.
     */
    data: billingCreateManyInput | billingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * billing update
   */
  export type billingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * The data needed to update a billing.
     */
    data: XOR<billingUpdateInput, billingUncheckedUpdateInput>
    /**
     * Choose, which billing to update.
     */
    where: billingWhereUniqueInput
  }

  /**
   * billing updateMany
   */
  export type billingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update billings.
     */
    data: XOR<billingUpdateManyMutationInput, billingUncheckedUpdateManyInput>
    /**
     * Filter which billings to update
     */
    where?: billingWhereInput
  }

  /**
   * billing upsert
   */
  export type billingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * The filter to search for the billing to update in case it exists.
     */
    where: billingWhereUniqueInput
    /**
     * In case the billing found by the `where` argument doesn't exist, create a new billing with this data.
     */
    create: XOR<billingCreateInput, billingUncheckedCreateInput>
    /**
     * In case the billing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<billingUpdateInput, billingUncheckedUpdateInput>
  }

  /**
   * billing delete
   */
  export type billingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
    /**
     * Filter which billing to delete.
     */
    where: billingWhereUniqueInput
  }

  /**
   * billing deleteMany
   */
  export type billingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billings to delete
     */
    where?: billingWhereInput
  }

  /**
   * billing without action
   */
  export type billingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing
     */
    select?: billingSelect<ExtArgs> | null
  }


  /**
   * Model billing_log
   */

  export type AggregateBilling_log = {
    _count: Billing_logCountAggregateOutputType | null
    _avg: Billing_logAvgAggregateOutputType | null
    _sum: Billing_logSumAggregateOutputType | null
    _min: Billing_logMinAggregateOutputType | null
    _max: Billing_logMaxAggregateOutputType | null
  }

  export type Billing_logAvgAggregateOutputType = {
    billing_log_id: number | null
    billing_id: number | null
    payment_method: number | null
  }

  export type Billing_logSumAggregateOutputType = {
    billing_log_id: number | null
    billing_id: number | null
    payment_method: number | null
  }

  export type Billing_logMinAggregateOutputType = {
    billing_log_id: number | null
    billing_id: number | null
    amt: string | null
    payment_method: number | null
    added_date: Date | null
  }

  export type Billing_logMaxAggregateOutputType = {
    billing_log_id: number | null
    billing_id: number | null
    amt: string | null
    payment_method: number | null
    added_date: Date | null
  }

  export type Billing_logCountAggregateOutputType = {
    billing_log_id: number
    billing_id: number
    amt: number
    payment_method: number
    added_date: number
    _all: number
  }


  export type Billing_logAvgAggregateInputType = {
    billing_log_id?: true
    billing_id?: true
    payment_method?: true
  }

  export type Billing_logSumAggregateInputType = {
    billing_log_id?: true
    billing_id?: true
    payment_method?: true
  }

  export type Billing_logMinAggregateInputType = {
    billing_log_id?: true
    billing_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
  }

  export type Billing_logMaxAggregateInputType = {
    billing_log_id?: true
    billing_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
  }

  export type Billing_logCountAggregateInputType = {
    billing_log_id?: true
    billing_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
    _all?: true
  }

  export type Billing_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billing_log to aggregate.
     */
    where?: billing_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_logs to fetch.
     */
    orderBy?: billing_logOrderByWithRelationInput | billing_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: billing_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned billing_logs
    **/
    _count?: true | Billing_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Billing_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Billing_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Billing_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Billing_logMaxAggregateInputType
  }

  export type GetBilling_logAggregateType<T extends Billing_logAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling_log[P]>
      : GetScalarType<T[P], AggregateBilling_log[P]>
  }




  export type billing_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billing_logWhereInput
    orderBy?: billing_logOrderByWithAggregationInput | billing_logOrderByWithAggregationInput[]
    by: Billing_logScalarFieldEnum[] | Billing_logScalarFieldEnum
    having?: billing_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Billing_logCountAggregateInputType | true
    _avg?: Billing_logAvgAggregateInputType
    _sum?: Billing_logSumAggregateInputType
    _min?: Billing_logMinAggregateInputType
    _max?: Billing_logMaxAggregateInputType
  }

  export type Billing_logGroupByOutputType = {
    billing_log_id: number
    billing_id: number
    amt: string
    payment_method: number
    added_date: Date
    _count: Billing_logCountAggregateOutputType | null
    _avg: Billing_logAvgAggregateOutputType | null
    _sum: Billing_logSumAggregateOutputType | null
    _min: Billing_logMinAggregateOutputType | null
    _max: Billing_logMaxAggregateOutputType | null
  }

  type GetBilling_logGroupByPayload<T extends billing_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Billing_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Billing_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Billing_logGroupByOutputType[P]>
            : GetScalarType<T[P], Billing_logGroupByOutputType[P]>
        }
      >
    >


  export type billing_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    billing_log_id?: boolean
    billing_id?: boolean
    amt?: boolean
    payment_method?: boolean
    added_date?: boolean
  }, ExtArgs["result"]["billing_log"]>


  export type billing_logSelectScalar = {
    billing_log_id?: boolean
    billing_id?: boolean
    amt?: boolean
    payment_method?: boolean
    added_date?: boolean
  }


  export type $billing_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "billing_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      billing_log_id: number
      billing_id: number
      amt: string
      payment_method: number
      added_date: Date
    }, ExtArgs["result"]["billing_log"]>
    composites: {}
  }

  type billing_logGetPayload<S extends boolean | null | undefined | billing_logDefaultArgs> = $Result.GetResult<Prisma.$billing_logPayload, S>

  type billing_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<billing_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Billing_logCountAggregateInputType | true
    }

  export interface billing_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['billing_log'], meta: { name: 'billing_log' } }
    /**
     * Find zero or one Billing_log that matches the filter.
     * @param {billing_logFindUniqueArgs} args - Arguments to find a Billing_log
     * @example
     * // Get one Billing_log
     * const billing_log = await prisma.billing_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends billing_logFindUniqueArgs>(args: SelectSubset<T, billing_logFindUniqueArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Billing_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {billing_logFindUniqueOrThrowArgs} args - Arguments to find a Billing_log
     * @example
     * // Get one Billing_log
     * const billing_log = await prisma.billing_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends billing_logFindUniqueOrThrowArgs>(args: SelectSubset<T, billing_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Billing_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logFindFirstArgs} args - Arguments to find a Billing_log
     * @example
     * // Get one Billing_log
     * const billing_log = await prisma.billing_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends billing_logFindFirstArgs>(args?: SelectSubset<T, billing_logFindFirstArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Billing_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logFindFirstOrThrowArgs} args - Arguments to find a Billing_log
     * @example
     * // Get one Billing_log
     * const billing_log = await prisma.billing_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends billing_logFindFirstOrThrowArgs>(args?: SelectSubset<T, billing_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Billing_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billing_logs
     * const billing_logs = await prisma.billing_log.findMany()
     * 
     * // Get first 10 Billing_logs
     * const billing_logs = await prisma.billing_log.findMany({ take: 10 })
     * 
     * // Only select the `billing_log_id`
     * const billing_logWithBilling_log_idOnly = await prisma.billing_log.findMany({ select: { billing_log_id: true } })
     * 
     */
    findMany<T extends billing_logFindManyArgs>(args?: SelectSubset<T, billing_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Billing_log.
     * @param {billing_logCreateArgs} args - Arguments to create a Billing_log.
     * @example
     * // Create one Billing_log
     * const Billing_log = await prisma.billing_log.create({
     *   data: {
     *     // ... data to create a Billing_log
     *   }
     * })
     * 
     */
    create<T extends billing_logCreateArgs>(args: SelectSubset<T, billing_logCreateArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Billing_logs.
     * @param {billing_logCreateManyArgs} args - Arguments to create many Billing_logs.
     * @example
     * // Create many Billing_logs
     * const billing_log = await prisma.billing_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends billing_logCreateManyArgs>(args?: SelectSubset<T, billing_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billing_log.
     * @param {billing_logDeleteArgs} args - Arguments to delete one Billing_log.
     * @example
     * // Delete one Billing_log
     * const Billing_log = await prisma.billing_log.delete({
     *   where: {
     *     // ... filter to delete one Billing_log
     *   }
     * })
     * 
     */
    delete<T extends billing_logDeleteArgs>(args: SelectSubset<T, billing_logDeleteArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Billing_log.
     * @param {billing_logUpdateArgs} args - Arguments to update one Billing_log.
     * @example
     * // Update one Billing_log
     * const billing_log = await prisma.billing_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends billing_logUpdateArgs>(args: SelectSubset<T, billing_logUpdateArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Billing_logs.
     * @param {billing_logDeleteManyArgs} args - Arguments to filter Billing_logs to delete.
     * @example
     * // Delete a few Billing_logs
     * const { count } = await prisma.billing_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends billing_logDeleteManyArgs>(args?: SelectSubset<T, billing_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billing_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billing_logs
     * const billing_log = await prisma.billing_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends billing_logUpdateManyArgs>(args: SelectSubset<T, billing_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing_log.
     * @param {billing_logUpsertArgs} args - Arguments to update or create a Billing_log.
     * @example
     * // Update or create a Billing_log
     * const billing_log = await prisma.billing_log.upsert({
     *   create: {
     *     // ... data to create a Billing_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing_log we want to update
     *   }
     * })
     */
    upsert<T extends billing_logUpsertArgs>(args: SelectSubset<T, billing_logUpsertArgs<ExtArgs>>): Prisma__billing_logClient<$Result.GetResult<Prisma.$billing_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Billing_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logCountArgs} args - Arguments to filter Billing_logs to count.
     * @example
     * // Count the number of Billing_logs
     * const count = await prisma.billing_log.count({
     *   where: {
     *     // ... the filter for the Billing_logs we want to count
     *   }
     * })
    **/
    count<T extends billing_logCountArgs>(
      args?: Subset<T, billing_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Billing_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Billing_logAggregateArgs>(args: Subset<T, Billing_logAggregateArgs>): Prisma.PrismaPromise<GetBilling_logAggregateType<T>>

    /**
     * Group by Billing_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends billing_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: billing_logGroupByArgs['orderBy'] }
        : { orderBy?: billing_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, billing_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilling_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the billing_log model
   */
  readonly fields: billing_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for billing_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__billing_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the billing_log model
   */ 
  interface billing_logFieldRefs {
    readonly billing_log_id: FieldRef<"billing_log", 'Int'>
    readonly billing_id: FieldRef<"billing_log", 'Int'>
    readonly amt: FieldRef<"billing_log", 'String'>
    readonly payment_method: FieldRef<"billing_log", 'Int'>
    readonly added_date: FieldRef<"billing_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * billing_log findUnique
   */
  export type billing_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter, which billing_log to fetch.
     */
    where: billing_logWhereUniqueInput
  }

  /**
   * billing_log findUniqueOrThrow
   */
  export type billing_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter, which billing_log to fetch.
     */
    where: billing_logWhereUniqueInput
  }

  /**
   * billing_log findFirst
   */
  export type billing_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter, which billing_log to fetch.
     */
    where?: billing_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_logs to fetch.
     */
    orderBy?: billing_logOrderByWithRelationInput | billing_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billing_logs.
     */
    cursor?: billing_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billing_logs.
     */
    distinct?: Billing_logScalarFieldEnum | Billing_logScalarFieldEnum[]
  }

  /**
   * billing_log findFirstOrThrow
   */
  export type billing_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter, which billing_log to fetch.
     */
    where?: billing_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_logs to fetch.
     */
    orderBy?: billing_logOrderByWithRelationInput | billing_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billing_logs.
     */
    cursor?: billing_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billing_logs.
     */
    distinct?: Billing_logScalarFieldEnum | Billing_logScalarFieldEnum[]
  }

  /**
   * billing_log findMany
   */
  export type billing_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter, which billing_logs to fetch.
     */
    where?: billing_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_logs to fetch.
     */
    orderBy?: billing_logOrderByWithRelationInput | billing_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing billing_logs.
     */
    cursor?: billing_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_logs.
     */
    skip?: number
    distinct?: Billing_logScalarFieldEnum | Billing_logScalarFieldEnum[]
  }

  /**
   * billing_log create
   */
  export type billing_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * The data needed to create a billing_log.
     */
    data: XOR<billing_logCreateInput, billing_logUncheckedCreateInput>
  }

  /**
   * billing_log createMany
   */
  export type billing_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many billing_logs.
     */
    data: billing_logCreateManyInput | billing_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * billing_log update
   */
  export type billing_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * The data needed to update a billing_log.
     */
    data: XOR<billing_logUpdateInput, billing_logUncheckedUpdateInput>
    /**
     * Choose, which billing_log to update.
     */
    where: billing_logWhereUniqueInput
  }

  /**
   * billing_log updateMany
   */
  export type billing_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update billing_logs.
     */
    data: XOR<billing_logUpdateManyMutationInput, billing_logUncheckedUpdateManyInput>
    /**
     * Filter which billing_logs to update
     */
    where?: billing_logWhereInput
  }

  /**
   * billing_log upsert
   */
  export type billing_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * The filter to search for the billing_log to update in case it exists.
     */
    where: billing_logWhereUniqueInput
    /**
     * In case the billing_log found by the `where` argument doesn't exist, create a new billing_log with this data.
     */
    create: XOR<billing_logCreateInput, billing_logUncheckedCreateInput>
    /**
     * In case the billing_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<billing_logUpdateInput, billing_logUncheckedUpdateInput>
  }

  /**
   * billing_log delete
   */
  export type billing_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
    /**
     * Filter which billing_log to delete.
     */
    where: billing_logWhereUniqueInput
  }

  /**
   * billing_log deleteMany
   */
  export type billing_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billing_logs to delete
     */
    where?: billing_logWhereInput
  }

  /**
   * billing_log without action
   */
  export type billing_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_log
     */
    select?: billing_logSelect<ExtArgs> | null
  }


  /**
   * Model bloodgroup_details
   */

  export type AggregateBloodgroup_details = {
    _count: Bloodgroup_detailsCountAggregateOutputType | null
    _avg: Bloodgroup_detailsAvgAggregateOutputType | null
    _sum: Bloodgroup_detailsSumAggregateOutputType | null
    _min: Bloodgroup_detailsMinAggregateOutputType | null
    _max: Bloodgroup_detailsMaxAggregateOutputType | null
  }

  export type Bloodgroup_detailsAvgAggregateOutputType = {
    bloodgroup_id: number | null
    active: number | null
  }

  export type Bloodgroup_detailsSumAggregateOutputType = {
    bloodgroup_id: number | null
    active: number | null
  }

  export type Bloodgroup_detailsMinAggregateOutputType = {
    bloodgroup_id: number | null
    bloodgroup_name: string | null
    active: number | null
  }

  export type Bloodgroup_detailsMaxAggregateOutputType = {
    bloodgroup_id: number | null
    bloodgroup_name: string | null
    active: number | null
  }

  export type Bloodgroup_detailsCountAggregateOutputType = {
    bloodgroup_id: number
    bloodgroup_name: number
    active: number
    _all: number
  }


  export type Bloodgroup_detailsAvgAggregateInputType = {
    bloodgroup_id?: true
    active?: true
  }

  export type Bloodgroup_detailsSumAggregateInputType = {
    bloodgroup_id?: true
    active?: true
  }

  export type Bloodgroup_detailsMinAggregateInputType = {
    bloodgroup_id?: true
    bloodgroup_name?: true
    active?: true
  }

  export type Bloodgroup_detailsMaxAggregateInputType = {
    bloodgroup_id?: true
    bloodgroup_name?: true
    active?: true
  }

  export type Bloodgroup_detailsCountAggregateInputType = {
    bloodgroup_id?: true
    bloodgroup_name?: true
    active?: true
    _all?: true
  }

  export type Bloodgroup_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bloodgroup_details to aggregate.
     */
    where?: bloodgroup_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bloodgroup_details to fetch.
     */
    orderBy?: bloodgroup_detailsOrderByWithRelationInput | bloodgroup_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bloodgroup_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bloodgroup_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bloodgroup_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bloodgroup_details
    **/
    _count?: true | Bloodgroup_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bloodgroup_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bloodgroup_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bloodgroup_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bloodgroup_detailsMaxAggregateInputType
  }

  export type GetBloodgroup_detailsAggregateType<T extends Bloodgroup_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBloodgroup_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloodgroup_details[P]>
      : GetScalarType<T[P], AggregateBloodgroup_details[P]>
  }




  export type bloodgroup_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bloodgroup_detailsWhereInput
    orderBy?: bloodgroup_detailsOrderByWithAggregationInput | bloodgroup_detailsOrderByWithAggregationInput[]
    by: Bloodgroup_detailsScalarFieldEnum[] | Bloodgroup_detailsScalarFieldEnum
    having?: bloodgroup_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bloodgroup_detailsCountAggregateInputType | true
    _avg?: Bloodgroup_detailsAvgAggregateInputType
    _sum?: Bloodgroup_detailsSumAggregateInputType
    _min?: Bloodgroup_detailsMinAggregateInputType
    _max?: Bloodgroup_detailsMaxAggregateInputType
  }

  export type Bloodgroup_detailsGroupByOutputType = {
    bloodgroup_id: number
    bloodgroup_name: string | null
    active: number | null
    _count: Bloodgroup_detailsCountAggregateOutputType | null
    _avg: Bloodgroup_detailsAvgAggregateOutputType | null
    _sum: Bloodgroup_detailsSumAggregateOutputType | null
    _min: Bloodgroup_detailsMinAggregateOutputType | null
    _max: Bloodgroup_detailsMaxAggregateOutputType | null
  }

  type GetBloodgroup_detailsGroupByPayload<T extends bloodgroup_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bloodgroup_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bloodgroup_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bloodgroup_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Bloodgroup_detailsGroupByOutputType[P]>
        }
      >
    >


  export type bloodgroup_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bloodgroup_id?: boolean
    bloodgroup_name?: boolean
    active?: boolean
  }, ExtArgs["result"]["bloodgroup_details"]>


  export type bloodgroup_detailsSelectScalar = {
    bloodgroup_id?: boolean
    bloodgroup_name?: boolean
    active?: boolean
  }


  export type $bloodgroup_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bloodgroup_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      bloodgroup_id: number
      bloodgroup_name: string | null
      active: number | null
    }, ExtArgs["result"]["bloodgroup_details"]>
    composites: {}
  }

  type bloodgroup_detailsGetPayload<S extends boolean | null | undefined | bloodgroup_detailsDefaultArgs> = $Result.GetResult<Prisma.$bloodgroup_detailsPayload, S>

  type bloodgroup_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bloodgroup_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bloodgroup_detailsCountAggregateInputType | true
    }

  export interface bloodgroup_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bloodgroup_details'], meta: { name: 'bloodgroup_details' } }
    /**
     * Find zero or one Bloodgroup_details that matches the filter.
     * @param {bloodgroup_detailsFindUniqueArgs} args - Arguments to find a Bloodgroup_details
     * @example
     * // Get one Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bloodgroup_detailsFindUniqueArgs>(args: SelectSubset<T, bloodgroup_detailsFindUniqueArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bloodgroup_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bloodgroup_detailsFindUniqueOrThrowArgs} args - Arguments to find a Bloodgroup_details
     * @example
     * // Get one Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bloodgroup_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, bloodgroup_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bloodgroup_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsFindFirstArgs} args - Arguments to find a Bloodgroup_details
     * @example
     * // Get one Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bloodgroup_detailsFindFirstArgs>(args?: SelectSubset<T, bloodgroup_detailsFindFirstArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bloodgroup_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsFindFirstOrThrowArgs} args - Arguments to find a Bloodgroup_details
     * @example
     * // Get one Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bloodgroup_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, bloodgroup_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bloodgroup_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findMany()
     * 
     * // Get first 10 Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.findMany({ take: 10 })
     * 
     * // Only select the `bloodgroup_id`
     * const bloodgroup_detailsWithBloodgroup_idOnly = await prisma.bloodgroup_details.findMany({ select: { bloodgroup_id: true } })
     * 
     */
    findMany<T extends bloodgroup_detailsFindManyArgs>(args?: SelectSubset<T, bloodgroup_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bloodgroup_details.
     * @param {bloodgroup_detailsCreateArgs} args - Arguments to create a Bloodgroup_details.
     * @example
     * // Create one Bloodgroup_details
     * const Bloodgroup_details = await prisma.bloodgroup_details.create({
     *   data: {
     *     // ... data to create a Bloodgroup_details
     *   }
     * })
     * 
     */
    create<T extends bloodgroup_detailsCreateArgs>(args: SelectSubset<T, bloodgroup_detailsCreateArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bloodgroup_details.
     * @param {bloodgroup_detailsCreateManyArgs} args - Arguments to create many Bloodgroup_details.
     * @example
     * // Create many Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bloodgroup_detailsCreateManyArgs>(args?: SelectSubset<T, bloodgroup_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bloodgroup_details.
     * @param {bloodgroup_detailsDeleteArgs} args - Arguments to delete one Bloodgroup_details.
     * @example
     * // Delete one Bloodgroup_details
     * const Bloodgroup_details = await prisma.bloodgroup_details.delete({
     *   where: {
     *     // ... filter to delete one Bloodgroup_details
     *   }
     * })
     * 
     */
    delete<T extends bloodgroup_detailsDeleteArgs>(args: SelectSubset<T, bloodgroup_detailsDeleteArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bloodgroup_details.
     * @param {bloodgroup_detailsUpdateArgs} args - Arguments to update one Bloodgroup_details.
     * @example
     * // Update one Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bloodgroup_detailsUpdateArgs>(args: SelectSubset<T, bloodgroup_detailsUpdateArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bloodgroup_details.
     * @param {bloodgroup_detailsDeleteManyArgs} args - Arguments to filter Bloodgroup_details to delete.
     * @example
     * // Delete a few Bloodgroup_details
     * const { count } = await prisma.bloodgroup_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bloodgroup_detailsDeleteManyArgs>(args?: SelectSubset<T, bloodgroup_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bloodgroup_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bloodgroup_detailsUpdateManyArgs>(args: SelectSubset<T, bloodgroup_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bloodgroup_details.
     * @param {bloodgroup_detailsUpsertArgs} args - Arguments to update or create a Bloodgroup_details.
     * @example
     * // Update or create a Bloodgroup_details
     * const bloodgroup_details = await prisma.bloodgroup_details.upsert({
     *   create: {
     *     // ... data to create a Bloodgroup_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bloodgroup_details we want to update
     *   }
     * })
     */
    upsert<T extends bloodgroup_detailsUpsertArgs>(args: SelectSubset<T, bloodgroup_detailsUpsertArgs<ExtArgs>>): Prisma__bloodgroup_detailsClient<$Result.GetResult<Prisma.$bloodgroup_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bloodgroup_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsCountArgs} args - Arguments to filter Bloodgroup_details to count.
     * @example
     * // Count the number of Bloodgroup_details
     * const count = await prisma.bloodgroup_details.count({
     *   where: {
     *     // ... the filter for the Bloodgroup_details we want to count
     *   }
     * })
    **/
    count<T extends bloodgroup_detailsCountArgs>(
      args?: Subset<T, bloodgroup_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bloodgroup_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bloodgroup_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bloodgroup_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bloodgroup_detailsAggregateArgs>(args: Subset<T, Bloodgroup_detailsAggregateArgs>): Prisma.PrismaPromise<GetBloodgroup_detailsAggregateType<T>>

    /**
     * Group by Bloodgroup_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bloodgroup_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bloodgroup_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bloodgroup_detailsGroupByArgs['orderBy'] }
        : { orderBy?: bloodgroup_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bloodgroup_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBloodgroup_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bloodgroup_details model
   */
  readonly fields: bloodgroup_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bloodgroup_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bloodgroup_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bloodgroup_details model
   */ 
  interface bloodgroup_detailsFieldRefs {
    readonly bloodgroup_id: FieldRef<"bloodgroup_details", 'Int'>
    readonly bloodgroup_name: FieldRef<"bloodgroup_details", 'String'>
    readonly active: FieldRef<"bloodgroup_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bloodgroup_details findUnique
   */
  export type bloodgroup_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter, which bloodgroup_details to fetch.
     */
    where: bloodgroup_detailsWhereUniqueInput
  }

  /**
   * bloodgroup_details findUniqueOrThrow
   */
  export type bloodgroup_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter, which bloodgroup_details to fetch.
     */
    where: bloodgroup_detailsWhereUniqueInput
  }

  /**
   * bloodgroup_details findFirst
   */
  export type bloodgroup_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter, which bloodgroup_details to fetch.
     */
    where?: bloodgroup_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bloodgroup_details to fetch.
     */
    orderBy?: bloodgroup_detailsOrderByWithRelationInput | bloodgroup_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bloodgroup_details.
     */
    cursor?: bloodgroup_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bloodgroup_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bloodgroup_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bloodgroup_details.
     */
    distinct?: Bloodgroup_detailsScalarFieldEnum | Bloodgroup_detailsScalarFieldEnum[]
  }

  /**
   * bloodgroup_details findFirstOrThrow
   */
  export type bloodgroup_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter, which bloodgroup_details to fetch.
     */
    where?: bloodgroup_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bloodgroup_details to fetch.
     */
    orderBy?: bloodgroup_detailsOrderByWithRelationInput | bloodgroup_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bloodgroup_details.
     */
    cursor?: bloodgroup_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bloodgroup_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bloodgroup_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bloodgroup_details.
     */
    distinct?: Bloodgroup_detailsScalarFieldEnum | Bloodgroup_detailsScalarFieldEnum[]
  }

  /**
   * bloodgroup_details findMany
   */
  export type bloodgroup_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter, which bloodgroup_details to fetch.
     */
    where?: bloodgroup_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bloodgroup_details to fetch.
     */
    orderBy?: bloodgroup_detailsOrderByWithRelationInput | bloodgroup_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bloodgroup_details.
     */
    cursor?: bloodgroup_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bloodgroup_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bloodgroup_details.
     */
    skip?: number
    distinct?: Bloodgroup_detailsScalarFieldEnum | Bloodgroup_detailsScalarFieldEnum[]
  }

  /**
   * bloodgroup_details create
   */
  export type bloodgroup_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a bloodgroup_details.
     */
    data?: XOR<bloodgroup_detailsCreateInput, bloodgroup_detailsUncheckedCreateInput>
  }

  /**
   * bloodgroup_details createMany
   */
  export type bloodgroup_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bloodgroup_details.
     */
    data: bloodgroup_detailsCreateManyInput | bloodgroup_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bloodgroup_details update
   */
  export type bloodgroup_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a bloodgroup_details.
     */
    data: XOR<bloodgroup_detailsUpdateInput, bloodgroup_detailsUncheckedUpdateInput>
    /**
     * Choose, which bloodgroup_details to update.
     */
    where: bloodgroup_detailsWhereUniqueInput
  }

  /**
   * bloodgroup_details updateMany
   */
  export type bloodgroup_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bloodgroup_details.
     */
    data: XOR<bloodgroup_detailsUpdateManyMutationInput, bloodgroup_detailsUncheckedUpdateManyInput>
    /**
     * Filter which bloodgroup_details to update
     */
    where?: bloodgroup_detailsWhereInput
  }

  /**
   * bloodgroup_details upsert
   */
  export type bloodgroup_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the bloodgroup_details to update in case it exists.
     */
    where: bloodgroup_detailsWhereUniqueInput
    /**
     * In case the bloodgroup_details found by the `where` argument doesn't exist, create a new bloodgroup_details with this data.
     */
    create: XOR<bloodgroup_detailsCreateInput, bloodgroup_detailsUncheckedCreateInput>
    /**
     * In case the bloodgroup_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bloodgroup_detailsUpdateInput, bloodgroup_detailsUncheckedUpdateInput>
  }

  /**
   * bloodgroup_details delete
   */
  export type bloodgroup_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
    /**
     * Filter which bloodgroup_details to delete.
     */
    where: bloodgroup_detailsWhereUniqueInput
  }

  /**
   * bloodgroup_details deleteMany
   */
  export type bloodgroup_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bloodgroup_details to delete
     */
    where?: bloodgroup_detailsWhereInput
  }

  /**
   * bloodgroup_details without action
   */
  export type bloodgroup_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bloodgroup_details
     */
    select?: bloodgroup_detailsSelect<ExtArgs> | null
  }


  /**
   * Model city
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    city_id: number | null
    state_id: number | null
  }

  export type CitySumAggregateOutputType = {
    city_id: number | null
    state_id: number | null
  }

  export type CityMinAggregateOutputType = {
    city_id: number | null
    city_name: string | null
    state_id: number | null
    active: boolean | null
  }

  export type CityMaxAggregateOutputType = {
    city_id: number | null
    city_name: string | null
    state_id: number | null
    active: boolean | null
  }

  export type CityCountAggregateOutputType = {
    city_id: number
    city_name: number
    state_id: number
    active: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    city_id?: true
    state_id?: true
  }

  export type CitySumAggregateInputType = {
    city_id?: true
    state_id?: true
  }

  export type CityMinAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    active?: true
  }

  export type CityMaxAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    active?: true
  }

  export type CityCountAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    active?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which city to aggregate.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type cityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cityWhereInput
    orderBy?: cityOrderByWithAggregationInput | cityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: cityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    city_id: number
    city_name: string
    state_id: number
    active: boolean
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends cityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type citySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    active?: boolean
  }, ExtArgs["result"]["city"]>


  export type citySelectScalar = {
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    active?: boolean
  }


  export type $cityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "city"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      city_id: number
      city_name: string
      state_id: number
      active: boolean
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type cityGetPayload<S extends boolean | null | undefined | cityDefaultArgs> = $Result.GetResult<Prisma.$cityPayload, S>

  type cityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface cityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['city'], meta: { name: 'city' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {cityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cityFindUniqueArgs>(args: SelectSubset<T, cityFindUniqueArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cityFindUniqueOrThrowArgs>(args: SelectSubset<T, cityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cityFindFirstArgs>(args?: SelectSubset<T, cityFindFirstArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cityFindFirstOrThrowArgs>(args?: SelectSubset<T, cityFindFirstOrThrowArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `city_id`
     * const cityWithCity_idOnly = await prisma.city.findMany({ select: { city_id: true } })
     * 
     */
    findMany<T extends cityFindManyArgs>(args?: SelectSubset<T, cityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {cityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends cityCreateArgs>(args: SelectSubset<T, cityCreateArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {cityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cityCreateManyArgs>(args?: SelectSubset<T, cityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {cityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends cityDeleteArgs>(args: SelectSubset<T, cityDeleteArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {cityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cityUpdateArgs>(args: SelectSubset<T, cityUpdateArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {cityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cityDeleteManyArgs>(args?: SelectSubset<T, cityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cityUpdateManyArgs>(args: SelectSubset<T, cityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {cityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends cityUpsertArgs>(args: SelectSubset<T, cityUpsertArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends cityCountArgs>(
      args?: Subset<T, cityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cityGroupByArgs['orderBy'] }
        : { orderBy?: cityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the city model
   */
  readonly fields: cityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for city.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the city model
   */ 
  interface cityFieldRefs {
    readonly city_id: FieldRef<"city", 'Int'>
    readonly city_name: FieldRef<"city", 'String'>
    readonly state_id: FieldRef<"city", 'Int'>
    readonly active: FieldRef<"city", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * city findUnique
   */
  export type cityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city findUniqueOrThrow
   */
  export type cityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city findFirst
   */
  export type cityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city findFirstOrThrow
   */
  export type cityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city findMany
   */
  export type cityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city create
   */
  export type cityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * The data needed to create a city.
     */
    data: XOR<cityCreateInput, cityUncheckedCreateInput>
  }

  /**
   * city createMany
   */
  export type cityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities.
     */
    data: cityCreateManyInput | cityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * city update
   */
  export type cityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * The data needed to update a city.
     */
    data: XOR<cityUpdateInput, cityUncheckedUpdateInput>
    /**
     * Choose, which city to update.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city updateMany
   */
  export type cityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities.
     */
    data: XOR<cityUpdateManyMutationInput, cityUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: cityWhereInput
  }

  /**
   * city upsert
   */
  export type cityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * The filter to search for the city to update in case it exists.
     */
    where: cityWhereUniqueInput
    /**
     * In case the city found by the `where` argument doesn't exist, create a new city with this data.
     */
    create: XOR<cityCreateInput, cityUncheckedCreateInput>
    /**
     * In case the city was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cityUpdateInput, cityUncheckedUpdateInput>
  }

  /**
   * city delete
   */
  export type cityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Filter which city to delete.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city deleteMany
   */
  export type cityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to delete
     */
    where?: cityWhereInput
  }

  /**
   * city without action
   */
  export type cityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
  }


  /**
   * Model clinic_module_activation_request
   */

  export type AggregateClinic_module_activation_request = {
    _count: Clinic_module_activation_requestCountAggregateOutputType | null
    _avg: Clinic_module_activation_requestAvgAggregateOutputType | null
    _sum: Clinic_module_activation_requestSumAggregateOutputType | null
    _min: Clinic_module_activation_requestMinAggregateOutputType | null
    _max: Clinic_module_activation_requestMaxAggregateOutputType | null
  }

  export type Clinic_module_activation_requestAvgAggregateOutputType = {
    clinic_module_activation_request_id: number | null
    physicianid: number | null
    is_activated: number | null
  }

  export type Clinic_module_activation_requestSumAggregateOutputType = {
    clinic_module_activation_request_id: number | null
    physicianid: number | null
    is_activated: number | null
  }

  export type Clinic_module_activation_requestMinAggregateOutputType = {
    clinic_module_activation_request_id: number | null
    name: string | null
    email: string | null
    phone_num: string | null
    physicianid: number | null
    message: string | null
    is_activated: number | null
    added_date: Date | null
  }

  export type Clinic_module_activation_requestMaxAggregateOutputType = {
    clinic_module_activation_request_id: number | null
    name: string | null
    email: string | null
    phone_num: string | null
    physicianid: number | null
    message: string | null
    is_activated: number | null
    added_date: Date | null
  }

  export type Clinic_module_activation_requestCountAggregateOutputType = {
    clinic_module_activation_request_id: number
    name: number
    email: number
    phone_num: number
    physicianid: number
    message: number
    is_activated: number
    added_date: number
    _all: number
  }


  export type Clinic_module_activation_requestAvgAggregateInputType = {
    clinic_module_activation_request_id?: true
    physicianid?: true
    is_activated?: true
  }

  export type Clinic_module_activation_requestSumAggregateInputType = {
    clinic_module_activation_request_id?: true
    physicianid?: true
    is_activated?: true
  }

  export type Clinic_module_activation_requestMinAggregateInputType = {
    clinic_module_activation_request_id?: true
    name?: true
    email?: true
    phone_num?: true
    physicianid?: true
    message?: true
    is_activated?: true
    added_date?: true
  }

  export type Clinic_module_activation_requestMaxAggregateInputType = {
    clinic_module_activation_request_id?: true
    name?: true
    email?: true
    phone_num?: true
    physicianid?: true
    message?: true
    is_activated?: true
    added_date?: true
  }

  export type Clinic_module_activation_requestCountAggregateInputType = {
    clinic_module_activation_request_id?: true
    name?: true
    email?: true
    phone_num?: true
    physicianid?: true
    message?: true
    is_activated?: true
    added_date?: true
    _all?: true
  }

  export type Clinic_module_activation_requestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_module_activation_request to aggregate.
     */
    where?: clinic_module_activation_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_module_activation_requests to fetch.
     */
    orderBy?: clinic_module_activation_requestOrderByWithRelationInput | clinic_module_activation_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinic_module_activation_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_module_activation_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_module_activation_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinic_module_activation_requests
    **/
    _count?: true | Clinic_module_activation_requestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clinic_module_activation_requestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clinic_module_activation_requestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clinic_module_activation_requestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clinic_module_activation_requestMaxAggregateInputType
  }

  export type GetClinic_module_activation_requestAggregateType<T extends Clinic_module_activation_requestAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic_module_activation_request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic_module_activation_request[P]>
      : GetScalarType<T[P], AggregateClinic_module_activation_request[P]>
  }




  export type clinic_module_activation_requestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinic_module_activation_requestWhereInput
    orderBy?: clinic_module_activation_requestOrderByWithAggregationInput | clinic_module_activation_requestOrderByWithAggregationInput[]
    by: Clinic_module_activation_requestScalarFieldEnum[] | Clinic_module_activation_requestScalarFieldEnum
    having?: clinic_module_activation_requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clinic_module_activation_requestCountAggregateInputType | true
    _avg?: Clinic_module_activation_requestAvgAggregateInputType
    _sum?: Clinic_module_activation_requestSumAggregateInputType
    _min?: Clinic_module_activation_requestMinAggregateInputType
    _max?: Clinic_module_activation_requestMaxAggregateInputType
  }

  export type Clinic_module_activation_requestGroupByOutputType = {
    clinic_module_activation_request_id: number
    name: string
    email: string
    phone_num: string
    physicianid: number
    message: string
    is_activated: number
    added_date: Date
    _count: Clinic_module_activation_requestCountAggregateOutputType | null
    _avg: Clinic_module_activation_requestAvgAggregateOutputType | null
    _sum: Clinic_module_activation_requestSumAggregateOutputType | null
    _min: Clinic_module_activation_requestMinAggregateOutputType | null
    _max: Clinic_module_activation_requestMaxAggregateOutputType | null
  }

  type GetClinic_module_activation_requestGroupByPayload<T extends clinic_module_activation_requestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clinic_module_activation_requestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clinic_module_activation_requestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clinic_module_activation_requestGroupByOutputType[P]>
            : GetScalarType<T[P], Clinic_module_activation_requestGroupByOutputType[P]>
        }
      >
    >


  export type clinic_module_activation_requestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clinic_module_activation_request_id?: boolean
    name?: boolean
    email?: boolean
    phone_num?: boolean
    physicianid?: boolean
    message?: boolean
    is_activated?: boolean
    added_date?: boolean
  }, ExtArgs["result"]["clinic_module_activation_request"]>


  export type clinic_module_activation_requestSelectScalar = {
    clinic_module_activation_request_id?: boolean
    name?: boolean
    email?: boolean
    phone_num?: boolean
    physicianid?: boolean
    message?: boolean
    is_activated?: boolean
    added_date?: boolean
  }


  export type $clinic_module_activation_requestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinic_module_activation_request"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      clinic_module_activation_request_id: number
      name: string
      email: string
      phone_num: string
      physicianid: number
      message: string
      is_activated: number
      added_date: Date
    }, ExtArgs["result"]["clinic_module_activation_request"]>
    composites: {}
  }

  type clinic_module_activation_requestGetPayload<S extends boolean | null | undefined | clinic_module_activation_requestDefaultArgs> = $Result.GetResult<Prisma.$clinic_module_activation_requestPayload, S>

  type clinic_module_activation_requestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clinic_module_activation_requestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Clinic_module_activation_requestCountAggregateInputType | true
    }

  export interface clinic_module_activation_requestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinic_module_activation_request'], meta: { name: 'clinic_module_activation_request' } }
    /**
     * Find zero or one Clinic_module_activation_request that matches the filter.
     * @param {clinic_module_activation_requestFindUniqueArgs} args - Arguments to find a Clinic_module_activation_request
     * @example
     * // Get one Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinic_module_activation_requestFindUniqueArgs>(args: SelectSubset<T, clinic_module_activation_requestFindUniqueArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clinic_module_activation_request that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clinic_module_activation_requestFindUniqueOrThrowArgs} args - Arguments to find a Clinic_module_activation_request
     * @example
     * // Get one Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinic_module_activation_requestFindUniqueOrThrowArgs>(args: SelectSubset<T, clinic_module_activation_requestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clinic_module_activation_request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestFindFirstArgs} args - Arguments to find a Clinic_module_activation_request
     * @example
     * // Get one Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinic_module_activation_requestFindFirstArgs>(args?: SelectSubset<T, clinic_module_activation_requestFindFirstArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clinic_module_activation_request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestFindFirstOrThrowArgs} args - Arguments to find a Clinic_module_activation_request
     * @example
     * // Get one Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinic_module_activation_requestFindFirstOrThrowArgs>(args?: SelectSubset<T, clinic_module_activation_requestFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clinic_module_activation_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinic_module_activation_requests
     * const clinic_module_activation_requests = await prisma.clinic_module_activation_request.findMany()
     * 
     * // Get first 10 Clinic_module_activation_requests
     * const clinic_module_activation_requests = await prisma.clinic_module_activation_request.findMany({ take: 10 })
     * 
     * // Only select the `clinic_module_activation_request_id`
     * const clinic_module_activation_requestWithClinic_module_activation_request_idOnly = await prisma.clinic_module_activation_request.findMany({ select: { clinic_module_activation_request_id: true } })
     * 
     */
    findMany<T extends clinic_module_activation_requestFindManyArgs>(args?: SelectSubset<T, clinic_module_activation_requestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clinic_module_activation_request.
     * @param {clinic_module_activation_requestCreateArgs} args - Arguments to create a Clinic_module_activation_request.
     * @example
     * // Create one Clinic_module_activation_request
     * const Clinic_module_activation_request = await prisma.clinic_module_activation_request.create({
     *   data: {
     *     // ... data to create a Clinic_module_activation_request
     *   }
     * })
     * 
     */
    create<T extends clinic_module_activation_requestCreateArgs>(args: SelectSubset<T, clinic_module_activation_requestCreateArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clinic_module_activation_requests.
     * @param {clinic_module_activation_requestCreateManyArgs} args - Arguments to create many Clinic_module_activation_requests.
     * @example
     * // Create many Clinic_module_activation_requests
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinic_module_activation_requestCreateManyArgs>(args?: SelectSubset<T, clinic_module_activation_requestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinic_module_activation_request.
     * @param {clinic_module_activation_requestDeleteArgs} args - Arguments to delete one Clinic_module_activation_request.
     * @example
     * // Delete one Clinic_module_activation_request
     * const Clinic_module_activation_request = await prisma.clinic_module_activation_request.delete({
     *   where: {
     *     // ... filter to delete one Clinic_module_activation_request
     *   }
     * })
     * 
     */
    delete<T extends clinic_module_activation_requestDeleteArgs>(args: SelectSubset<T, clinic_module_activation_requestDeleteArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clinic_module_activation_request.
     * @param {clinic_module_activation_requestUpdateArgs} args - Arguments to update one Clinic_module_activation_request.
     * @example
     * // Update one Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinic_module_activation_requestUpdateArgs>(args: SelectSubset<T, clinic_module_activation_requestUpdateArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clinic_module_activation_requests.
     * @param {clinic_module_activation_requestDeleteManyArgs} args - Arguments to filter Clinic_module_activation_requests to delete.
     * @example
     * // Delete a few Clinic_module_activation_requests
     * const { count } = await prisma.clinic_module_activation_request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinic_module_activation_requestDeleteManyArgs>(args?: SelectSubset<T, clinic_module_activation_requestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_module_activation_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinic_module_activation_requests
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinic_module_activation_requestUpdateManyArgs>(args: SelectSubset<T, clinic_module_activation_requestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinic_module_activation_request.
     * @param {clinic_module_activation_requestUpsertArgs} args - Arguments to update or create a Clinic_module_activation_request.
     * @example
     * // Update or create a Clinic_module_activation_request
     * const clinic_module_activation_request = await prisma.clinic_module_activation_request.upsert({
     *   create: {
     *     // ... data to create a Clinic_module_activation_request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic_module_activation_request we want to update
     *   }
     * })
     */
    upsert<T extends clinic_module_activation_requestUpsertArgs>(args: SelectSubset<T, clinic_module_activation_requestUpsertArgs<ExtArgs>>): Prisma__clinic_module_activation_requestClient<$Result.GetResult<Prisma.$clinic_module_activation_requestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clinic_module_activation_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestCountArgs} args - Arguments to filter Clinic_module_activation_requests to count.
     * @example
     * // Count the number of Clinic_module_activation_requests
     * const count = await prisma.clinic_module_activation_request.count({
     *   where: {
     *     // ... the filter for the Clinic_module_activation_requests we want to count
     *   }
     * })
    **/
    count<T extends clinic_module_activation_requestCountArgs>(
      args?: Subset<T, clinic_module_activation_requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clinic_module_activation_requestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic_module_activation_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clinic_module_activation_requestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clinic_module_activation_requestAggregateArgs>(args: Subset<T, Clinic_module_activation_requestAggregateArgs>): Prisma.PrismaPromise<GetClinic_module_activation_requestAggregateType<T>>

    /**
     * Group by Clinic_module_activation_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_module_activation_requestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinic_module_activation_requestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinic_module_activation_requestGroupByArgs['orderBy'] }
        : { orderBy?: clinic_module_activation_requestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinic_module_activation_requestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinic_module_activation_requestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinic_module_activation_request model
   */
  readonly fields: clinic_module_activation_requestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinic_module_activation_request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinic_module_activation_requestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinic_module_activation_request model
   */ 
  interface clinic_module_activation_requestFieldRefs {
    readonly clinic_module_activation_request_id: FieldRef<"clinic_module_activation_request", 'Int'>
    readonly name: FieldRef<"clinic_module_activation_request", 'String'>
    readonly email: FieldRef<"clinic_module_activation_request", 'String'>
    readonly phone_num: FieldRef<"clinic_module_activation_request", 'String'>
    readonly physicianid: FieldRef<"clinic_module_activation_request", 'Int'>
    readonly message: FieldRef<"clinic_module_activation_request", 'String'>
    readonly is_activated: FieldRef<"clinic_module_activation_request", 'Int'>
    readonly added_date: FieldRef<"clinic_module_activation_request", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clinic_module_activation_request findUnique
   */
  export type clinic_module_activation_requestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter, which clinic_module_activation_request to fetch.
     */
    where: clinic_module_activation_requestWhereUniqueInput
  }

  /**
   * clinic_module_activation_request findUniqueOrThrow
   */
  export type clinic_module_activation_requestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter, which clinic_module_activation_request to fetch.
     */
    where: clinic_module_activation_requestWhereUniqueInput
  }

  /**
   * clinic_module_activation_request findFirst
   */
  export type clinic_module_activation_requestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter, which clinic_module_activation_request to fetch.
     */
    where?: clinic_module_activation_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_module_activation_requests to fetch.
     */
    orderBy?: clinic_module_activation_requestOrderByWithRelationInput | clinic_module_activation_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_module_activation_requests.
     */
    cursor?: clinic_module_activation_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_module_activation_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_module_activation_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_module_activation_requests.
     */
    distinct?: Clinic_module_activation_requestScalarFieldEnum | Clinic_module_activation_requestScalarFieldEnum[]
  }

  /**
   * clinic_module_activation_request findFirstOrThrow
   */
  export type clinic_module_activation_requestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter, which clinic_module_activation_request to fetch.
     */
    where?: clinic_module_activation_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_module_activation_requests to fetch.
     */
    orderBy?: clinic_module_activation_requestOrderByWithRelationInput | clinic_module_activation_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_module_activation_requests.
     */
    cursor?: clinic_module_activation_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_module_activation_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_module_activation_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_module_activation_requests.
     */
    distinct?: Clinic_module_activation_requestScalarFieldEnum | Clinic_module_activation_requestScalarFieldEnum[]
  }

  /**
   * clinic_module_activation_request findMany
   */
  export type clinic_module_activation_requestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter, which clinic_module_activation_requests to fetch.
     */
    where?: clinic_module_activation_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_module_activation_requests to fetch.
     */
    orderBy?: clinic_module_activation_requestOrderByWithRelationInput | clinic_module_activation_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinic_module_activation_requests.
     */
    cursor?: clinic_module_activation_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_module_activation_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_module_activation_requests.
     */
    skip?: number
    distinct?: Clinic_module_activation_requestScalarFieldEnum | Clinic_module_activation_requestScalarFieldEnum[]
  }

  /**
   * clinic_module_activation_request create
   */
  export type clinic_module_activation_requestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * The data needed to create a clinic_module_activation_request.
     */
    data: XOR<clinic_module_activation_requestCreateInput, clinic_module_activation_requestUncheckedCreateInput>
  }

  /**
   * clinic_module_activation_request createMany
   */
  export type clinic_module_activation_requestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinic_module_activation_requests.
     */
    data: clinic_module_activation_requestCreateManyInput | clinic_module_activation_requestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic_module_activation_request update
   */
  export type clinic_module_activation_requestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * The data needed to update a clinic_module_activation_request.
     */
    data: XOR<clinic_module_activation_requestUpdateInput, clinic_module_activation_requestUncheckedUpdateInput>
    /**
     * Choose, which clinic_module_activation_request to update.
     */
    where: clinic_module_activation_requestWhereUniqueInput
  }

  /**
   * clinic_module_activation_request updateMany
   */
  export type clinic_module_activation_requestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinic_module_activation_requests.
     */
    data: XOR<clinic_module_activation_requestUpdateManyMutationInput, clinic_module_activation_requestUncheckedUpdateManyInput>
    /**
     * Filter which clinic_module_activation_requests to update
     */
    where?: clinic_module_activation_requestWhereInput
  }

  /**
   * clinic_module_activation_request upsert
   */
  export type clinic_module_activation_requestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * The filter to search for the clinic_module_activation_request to update in case it exists.
     */
    where: clinic_module_activation_requestWhereUniqueInput
    /**
     * In case the clinic_module_activation_request found by the `where` argument doesn't exist, create a new clinic_module_activation_request with this data.
     */
    create: XOR<clinic_module_activation_requestCreateInput, clinic_module_activation_requestUncheckedCreateInput>
    /**
     * In case the clinic_module_activation_request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinic_module_activation_requestUpdateInput, clinic_module_activation_requestUncheckedUpdateInput>
  }

  /**
   * clinic_module_activation_request delete
   */
  export type clinic_module_activation_requestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
    /**
     * Filter which clinic_module_activation_request to delete.
     */
    where: clinic_module_activation_requestWhereUniqueInput
  }

  /**
   * clinic_module_activation_request deleteMany
   */
  export type clinic_module_activation_requestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_module_activation_requests to delete
     */
    where?: clinic_module_activation_requestWhereInput
  }

  /**
   * clinic_module_activation_request without action
   */
  export type clinic_module_activation_requestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_module_activation_request
     */
    select?: clinic_module_activation_requestSelect<ExtArgs> | null
  }


  /**
   * Model clinical_parameters
   */

  export type AggregateClinical_parameters = {
    _count: Clinical_parametersCountAggregateOutputType | null
    _avg: Clinical_parametersAvgAggregateOutputType | null
    _sum: Clinical_parametersSumAggregateOutputType | null
    _min: Clinical_parametersMinAggregateOutputType | null
    _max: Clinical_parametersMaxAggregateOutputType | null
  }

  export type Clinical_parametersAvgAggregateOutputType = {
    clinical_parameterid: number | null
    referral_patient_id: number | null
    dependent_id: number | null
  }

  export type Clinical_parametersSumAggregateOutputType = {
    clinical_parameterid: number | null
    referral_patient_id: number | null
    dependent_id: number | null
  }

  export type Clinical_parametersMinAggregateOutputType = {
    clinical_parameterid: number | null
    blood_pressure: string | null
    systolic_blood_pressure: string | null
    diastolic_blood_pressure: string | null
    sugar: string | null
    pulse: string | null
    height: string | null
    weight: string | null
    temperature: string | null
    referral_patient_id: number | null
    dependent_id: number | null
    created_on: string | null
  }

  export type Clinical_parametersMaxAggregateOutputType = {
    clinical_parameterid: number | null
    blood_pressure: string | null
    systolic_blood_pressure: string | null
    diastolic_blood_pressure: string | null
    sugar: string | null
    pulse: string | null
    height: string | null
    weight: string | null
    temperature: string | null
    referral_patient_id: number | null
    dependent_id: number | null
    created_on: string | null
  }

  export type Clinical_parametersCountAggregateOutputType = {
    clinical_parameterid: number
    blood_pressure: number
    systolic_blood_pressure: number
    diastolic_blood_pressure: number
    sugar: number
    pulse: number
    height: number
    weight: number
    temperature: number
    referral_patient_id: number
    dependent_id: number
    created_on: number
    _all: number
  }


  export type Clinical_parametersAvgAggregateInputType = {
    clinical_parameterid?: true
    referral_patient_id?: true
    dependent_id?: true
  }

  export type Clinical_parametersSumAggregateInputType = {
    clinical_parameterid?: true
    referral_patient_id?: true
    dependent_id?: true
  }

  export type Clinical_parametersMinAggregateInputType = {
    clinical_parameterid?: true
    blood_pressure?: true
    systolic_blood_pressure?: true
    diastolic_blood_pressure?: true
    sugar?: true
    pulse?: true
    height?: true
    weight?: true
    temperature?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
  }

  export type Clinical_parametersMaxAggregateInputType = {
    clinical_parameterid?: true
    blood_pressure?: true
    systolic_blood_pressure?: true
    diastolic_blood_pressure?: true
    sugar?: true
    pulse?: true
    height?: true
    weight?: true
    temperature?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
  }

  export type Clinical_parametersCountAggregateInputType = {
    clinical_parameterid?: true
    blood_pressure?: true
    systolic_blood_pressure?: true
    diastolic_blood_pressure?: true
    sugar?: true
    pulse?: true
    height?: true
    weight?: true
    temperature?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
    _all?: true
  }

  export type Clinical_parametersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinical_parameters to aggregate.
     */
    where?: clinical_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinical_parameters to fetch.
     */
    orderBy?: clinical_parametersOrderByWithRelationInput | clinical_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinical_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinical_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinical_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinical_parameters
    **/
    _count?: true | Clinical_parametersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clinical_parametersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clinical_parametersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clinical_parametersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clinical_parametersMaxAggregateInputType
  }

  export type GetClinical_parametersAggregateType<T extends Clinical_parametersAggregateArgs> = {
        [P in keyof T & keyof AggregateClinical_parameters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinical_parameters[P]>
      : GetScalarType<T[P], AggregateClinical_parameters[P]>
  }




  export type clinical_parametersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinical_parametersWhereInput
    orderBy?: clinical_parametersOrderByWithAggregationInput | clinical_parametersOrderByWithAggregationInput[]
    by: Clinical_parametersScalarFieldEnum[] | Clinical_parametersScalarFieldEnum
    having?: clinical_parametersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clinical_parametersCountAggregateInputType | true
    _avg?: Clinical_parametersAvgAggregateInputType
    _sum?: Clinical_parametersSumAggregateInputType
    _min?: Clinical_parametersMinAggregateInputType
    _max?: Clinical_parametersMaxAggregateInputType
  }

  export type Clinical_parametersGroupByOutputType = {
    clinical_parameterid: number
    blood_pressure: string
    systolic_blood_pressure: string
    diastolic_blood_pressure: string
    sugar: string
    pulse: string
    height: string
    weight: string
    temperature: string
    referral_patient_id: number
    dependent_id: number
    created_on: string | null
    _count: Clinical_parametersCountAggregateOutputType | null
    _avg: Clinical_parametersAvgAggregateOutputType | null
    _sum: Clinical_parametersSumAggregateOutputType | null
    _min: Clinical_parametersMinAggregateOutputType | null
    _max: Clinical_parametersMaxAggregateOutputType | null
  }

  type GetClinical_parametersGroupByPayload<T extends clinical_parametersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clinical_parametersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clinical_parametersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clinical_parametersGroupByOutputType[P]>
            : GetScalarType<T[P], Clinical_parametersGroupByOutputType[P]>
        }
      >
    >


  export type clinical_parametersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clinical_parameterid?: boolean
    blood_pressure?: boolean
    systolic_blood_pressure?: boolean
    diastolic_blood_pressure?: boolean
    sugar?: boolean
    pulse?: boolean
    height?: boolean
    weight?: boolean
    temperature?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["clinical_parameters"]>


  export type clinical_parametersSelectScalar = {
    clinical_parameterid?: boolean
    blood_pressure?: boolean
    systolic_blood_pressure?: boolean
    diastolic_blood_pressure?: boolean
    sugar?: boolean
    pulse?: boolean
    height?: boolean
    weight?: boolean
    temperature?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    created_on?: boolean
  }


  export type $clinical_parametersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinical_parameters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      clinical_parameterid: number
      blood_pressure: string
      systolic_blood_pressure: string
      diastolic_blood_pressure: string
      sugar: string
      pulse: string
      height: string
      weight: string
      temperature: string
      referral_patient_id: number
      dependent_id: number
      created_on: string | null
    }, ExtArgs["result"]["clinical_parameters"]>
    composites: {}
  }

  type clinical_parametersGetPayload<S extends boolean | null | undefined | clinical_parametersDefaultArgs> = $Result.GetResult<Prisma.$clinical_parametersPayload, S>

  type clinical_parametersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clinical_parametersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Clinical_parametersCountAggregateInputType | true
    }

  export interface clinical_parametersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinical_parameters'], meta: { name: 'clinical_parameters' } }
    /**
     * Find zero or one Clinical_parameters that matches the filter.
     * @param {clinical_parametersFindUniqueArgs} args - Arguments to find a Clinical_parameters
     * @example
     * // Get one Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinical_parametersFindUniqueArgs>(args: SelectSubset<T, clinical_parametersFindUniqueArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clinical_parameters that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clinical_parametersFindUniqueOrThrowArgs} args - Arguments to find a Clinical_parameters
     * @example
     * // Get one Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinical_parametersFindUniqueOrThrowArgs>(args: SelectSubset<T, clinical_parametersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clinical_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersFindFirstArgs} args - Arguments to find a Clinical_parameters
     * @example
     * // Get one Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinical_parametersFindFirstArgs>(args?: SelectSubset<T, clinical_parametersFindFirstArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clinical_parameters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersFindFirstOrThrowArgs} args - Arguments to find a Clinical_parameters
     * @example
     * // Get one Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinical_parametersFindFirstOrThrowArgs>(args?: SelectSubset<T, clinical_parametersFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clinical_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findMany()
     * 
     * // Get first 10 Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.findMany({ take: 10 })
     * 
     * // Only select the `clinical_parameterid`
     * const clinical_parametersWithClinical_parameteridOnly = await prisma.clinical_parameters.findMany({ select: { clinical_parameterid: true } })
     * 
     */
    findMany<T extends clinical_parametersFindManyArgs>(args?: SelectSubset<T, clinical_parametersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clinical_parameters.
     * @param {clinical_parametersCreateArgs} args - Arguments to create a Clinical_parameters.
     * @example
     * // Create one Clinical_parameters
     * const Clinical_parameters = await prisma.clinical_parameters.create({
     *   data: {
     *     // ... data to create a Clinical_parameters
     *   }
     * })
     * 
     */
    create<T extends clinical_parametersCreateArgs>(args: SelectSubset<T, clinical_parametersCreateArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clinical_parameters.
     * @param {clinical_parametersCreateManyArgs} args - Arguments to create many Clinical_parameters.
     * @example
     * // Create many Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinical_parametersCreateManyArgs>(args?: SelectSubset<T, clinical_parametersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinical_parameters.
     * @param {clinical_parametersDeleteArgs} args - Arguments to delete one Clinical_parameters.
     * @example
     * // Delete one Clinical_parameters
     * const Clinical_parameters = await prisma.clinical_parameters.delete({
     *   where: {
     *     // ... filter to delete one Clinical_parameters
     *   }
     * })
     * 
     */
    delete<T extends clinical_parametersDeleteArgs>(args: SelectSubset<T, clinical_parametersDeleteArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clinical_parameters.
     * @param {clinical_parametersUpdateArgs} args - Arguments to update one Clinical_parameters.
     * @example
     * // Update one Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinical_parametersUpdateArgs>(args: SelectSubset<T, clinical_parametersUpdateArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clinical_parameters.
     * @param {clinical_parametersDeleteManyArgs} args - Arguments to filter Clinical_parameters to delete.
     * @example
     * // Delete a few Clinical_parameters
     * const { count } = await prisma.clinical_parameters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinical_parametersDeleteManyArgs>(args?: SelectSubset<T, clinical_parametersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinical_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinical_parametersUpdateManyArgs>(args: SelectSubset<T, clinical_parametersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinical_parameters.
     * @param {clinical_parametersUpsertArgs} args - Arguments to update or create a Clinical_parameters.
     * @example
     * // Update or create a Clinical_parameters
     * const clinical_parameters = await prisma.clinical_parameters.upsert({
     *   create: {
     *     // ... data to create a Clinical_parameters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinical_parameters we want to update
     *   }
     * })
     */
    upsert<T extends clinical_parametersUpsertArgs>(args: SelectSubset<T, clinical_parametersUpsertArgs<ExtArgs>>): Prisma__clinical_parametersClient<$Result.GetResult<Prisma.$clinical_parametersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clinical_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersCountArgs} args - Arguments to filter Clinical_parameters to count.
     * @example
     * // Count the number of Clinical_parameters
     * const count = await prisma.clinical_parameters.count({
     *   where: {
     *     // ... the filter for the Clinical_parameters we want to count
     *   }
     * })
    **/
    count<T extends clinical_parametersCountArgs>(
      args?: Subset<T, clinical_parametersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clinical_parametersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinical_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clinical_parametersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clinical_parametersAggregateArgs>(args: Subset<T, Clinical_parametersAggregateArgs>): Prisma.PrismaPromise<GetClinical_parametersAggregateType<T>>

    /**
     * Group by Clinical_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinical_parametersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinical_parametersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinical_parametersGroupByArgs['orderBy'] }
        : { orderBy?: clinical_parametersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinical_parametersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinical_parametersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinical_parameters model
   */
  readonly fields: clinical_parametersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinical_parameters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinical_parametersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinical_parameters model
   */ 
  interface clinical_parametersFieldRefs {
    readonly clinical_parameterid: FieldRef<"clinical_parameters", 'Int'>
    readonly blood_pressure: FieldRef<"clinical_parameters", 'String'>
    readonly systolic_blood_pressure: FieldRef<"clinical_parameters", 'String'>
    readonly diastolic_blood_pressure: FieldRef<"clinical_parameters", 'String'>
    readonly sugar: FieldRef<"clinical_parameters", 'String'>
    readonly pulse: FieldRef<"clinical_parameters", 'String'>
    readonly height: FieldRef<"clinical_parameters", 'String'>
    readonly weight: FieldRef<"clinical_parameters", 'String'>
    readonly temperature: FieldRef<"clinical_parameters", 'String'>
    readonly referral_patient_id: FieldRef<"clinical_parameters", 'Int'>
    readonly dependent_id: FieldRef<"clinical_parameters", 'Int'>
    readonly created_on: FieldRef<"clinical_parameters", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clinical_parameters findUnique
   */
  export type clinical_parametersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter, which clinical_parameters to fetch.
     */
    where: clinical_parametersWhereUniqueInput
  }

  /**
   * clinical_parameters findUniqueOrThrow
   */
  export type clinical_parametersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter, which clinical_parameters to fetch.
     */
    where: clinical_parametersWhereUniqueInput
  }

  /**
   * clinical_parameters findFirst
   */
  export type clinical_parametersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter, which clinical_parameters to fetch.
     */
    where?: clinical_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinical_parameters to fetch.
     */
    orderBy?: clinical_parametersOrderByWithRelationInput | clinical_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinical_parameters.
     */
    cursor?: clinical_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinical_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinical_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinical_parameters.
     */
    distinct?: Clinical_parametersScalarFieldEnum | Clinical_parametersScalarFieldEnum[]
  }

  /**
   * clinical_parameters findFirstOrThrow
   */
  export type clinical_parametersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter, which clinical_parameters to fetch.
     */
    where?: clinical_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinical_parameters to fetch.
     */
    orderBy?: clinical_parametersOrderByWithRelationInput | clinical_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinical_parameters.
     */
    cursor?: clinical_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinical_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinical_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinical_parameters.
     */
    distinct?: Clinical_parametersScalarFieldEnum | Clinical_parametersScalarFieldEnum[]
  }

  /**
   * clinical_parameters findMany
   */
  export type clinical_parametersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter, which clinical_parameters to fetch.
     */
    where?: clinical_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinical_parameters to fetch.
     */
    orderBy?: clinical_parametersOrderByWithRelationInput | clinical_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinical_parameters.
     */
    cursor?: clinical_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinical_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinical_parameters.
     */
    skip?: number
    distinct?: Clinical_parametersScalarFieldEnum | Clinical_parametersScalarFieldEnum[]
  }

  /**
   * clinical_parameters create
   */
  export type clinical_parametersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * The data needed to create a clinical_parameters.
     */
    data: XOR<clinical_parametersCreateInput, clinical_parametersUncheckedCreateInput>
  }

  /**
   * clinical_parameters createMany
   */
  export type clinical_parametersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinical_parameters.
     */
    data: clinical_parametersCreateManyInput | clinical_parametersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinical_parameters update
   */
  export type clinical_parametersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * The data needed to update a clinical_parameters.
     */
    data: XOR<clinical_parametersUpdateInput, clinical_parametersUncheckedUpdateInput>
    /**
     * Choose, which clinical_parameters to update.
     */
    where: clinical_parametersWhereUniqueInput
  }

  /**
   * clinical_parameters updateMany
   */
  export type clinical_parametersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinical_parameters.
     */
    data: XOR<clinical_parametersUpdateManyMutationInput, clinical_parametersUncheckedUpdateManyInput>
    /**
     * Filter which clinical_parameters to update
     */
    where?: clinical_parametersWhereInput
  }

  /**
   * clinical_parameters upsert
   */
  export type clinical_parametersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * The filter to search for the clinical_parameters to update in case it exists.
     */
    where: clinical_parametersWhereUniqueInput
    /**
     * In case the clinical_parameters found by the `where` argument doesn't exist, create a new clinical_parameters with this data.
     */
    create: XOR<clinical_parametersCreateInput, clinical_parametersUncheckedCreateInput>
    /**
     * In case the clinical_parameters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinical_parametersUpdateInput, clinical_parametersUncheckedUpdateInput>
  }

  /**
   * clinical_parameters delete
   */
  export type clinical_parametersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
    /**
     * Filter which clinical_parameters to delete.
     */
    where: clinical_parametersWhereUniqueInput
  }

  /**
   * clinical_parameters deleteMany
   */
  export type clinical_parametersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinical_parameters to delete
     */
    where?: clinical_parametersWhereInput
  }

  /**
   * clinical_parameters without action
   */
  export type clinical_parametersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinical_parameters
     */
    select?: clinical_parametersSelect<ExtArgs> | null
  }


  /**
   * Model contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    name: string | null
    emailid: string | null
    subject: string | null
    message: string | null
    created_date: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    emailid: string | null
    subject: string | null
    message: string | null
    created_date: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    emailid: number
    subject: number
    message: number
    created_date: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    emailid?: true
    subject?: true
    message?: true
    created_date?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    emailid?: true
    subject?: true
    message?: true
    created_date?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    emailid?: true
    subject?: true
    message?: true
    created_date?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact to aggregate.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactWhereInput
    orderBy?: contactOrderByWithAggregationInput | contactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    name: string
    emailid: string
    subject: string
    message: string
    created_date: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emailid?: boolean
    subject?: boolean
    message?: boolean
    created_date?: boolean
  }, ExtArgs["result"]["contact"]>


  export type contactSelectScalar = {
    id?: boolean
    name?: boolean
    emailid?: boolean
    subject?: boolean
    message?: boolean
    created_date?: boolean
  }


  export type $contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      emailid: string
      subject: string
      message: string
      created_date: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type contactGetPayload<S extends boolean | null | undefined | contactDefaultArgs> = $Result.GetResult<Prisma.$contactPayload, S>

  type contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact'], meta: { name: 'contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {contactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactFindUniqueArgs>(args: SelectSubset<T, contactFindUniqueArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactFindUniqueOrThrowArgs>(args: SelectSubset<T, contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactFindFirstArgs>(args?: SelectSubset<T, contactFindFirstArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactFindFirstOrThrowArgs>(args?: SelectSubset<T, contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactFindManyArgs>(args?: SelectSubset<T, contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {contactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends contactCreateArgs>(args: SelectSubset<T, contactCreateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {contactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactCreateManyArgs>(args?: SelectSubset<T, contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {contactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends contactDeleteArgs>(args: SelectSubset<T, contactDeleteArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {contactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactUpdateArgs>(args: SelectSubset<T, contactUpdateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {contactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactDeleteManyArgs>(args?: SelectSubset<T, contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactUpdateManyArgs>(args: SelectSubset<T, contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {contactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends contactUpsertArgs>(args: SelectSubset<T, contactUpsertArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactCountArgs>(
      args?: Subset<T, contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactGroupByArgs['orderBy'] }
        : { orderBy?: contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact model
   */
  readonly fields: contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact model
   */ 
  interface contactFieldRefs {
    readonly id: FieldRef<"contact", 'Int'>
    readonly name: FieldRef<"contact", 'String'>
    readonly emailid: FieldRef<"contact", 'String'>
    readonly subject: FieldRef<"contact", 'String'>
    readonly message: FieldRef<"contact", 'String'>
    readonly created_date: FieldRef<"contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact findUnique
   */
  export type contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findUniqueOrThrow
   */
  export type contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findFirst
   */
  export type contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findFirstOrThrow
   */
  export type contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findMany
   */
  export type contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact create
   */
  export type contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The data needed to create a contact.
     */
    data: XOR<contactCreateInput, contactUncheckedCreateInput>
  }

  /**
   * contact createMany
   */
  export type contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactCreateManyInput | contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact update
   */
  export type contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The data needed to update a contact.
     */
    data: XOR<contactUpdateInput, contactUncheckedUpdateInput>
    /**
     * Choose, which contact to update.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact updateMany
   */
  export type contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactUpdateManyMutationInput, contactUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactWhereInput
  }

  /**
   * contact upsert
   */
  export type contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The filter to search for the contact to update in case it exists.
     */
    where: contactWhereUniqueInput
    /**
     * In case the contact found by the `where` argument doesn't exist, create a new contact with this data.
     */
    create: XOR<contactCreateInput, contactUncheckedCreateInput>
    /**
     * In case the contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactUpdateInput, contactUncheckedUpdateInput>
  }

  /**
   * contact delete
   */
  export type contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter which contact to delete.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact deleteMany
   */
  export type contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactWhereInput
  }

  /**
   * contact without action
   */
  export type contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
  }


  /**
   * Model country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    country_id: number | null
  }

  export type CountrySumAggregateOutputType = {
    country_id: number | null
  }

  export type CountryMinAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    active: boolean | null
  }

  export type CountryMaxAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    active: boolean | null
  }

  export type CountryCountAggregateOutputType = {
    country_id: number
    country_name: number
    active: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    country_id?: true
  }

  export type CountrySumAggregateInputType = {
    country_id?: true
  }

  export type CountryMinAggregateInputType = {
    country_id?: true
    country_name?: true
    active?: true
  }

  export type CountryMaxAggregateInputType = {
    country_id?: true
    country_name?: true
    active?: true
  }

  export type CountryCountAggregateInputType = {
    country_id?: true
    country_name?: true
    active?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which country to aggregate.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type countryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: countryWhereInput
    orderBy?: countryOrderByWithAggregationInput | countryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: countryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    country_id: number
    country_name: string | null
    active: boolean
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends countryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type countrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_name?: boolean
    active?: boolean
  }, ExtArgs["result"]["country"]>


  export type countrySelectScalar = {
    country_id?: boolean
    country_name?: boolean
    active?: boolean
  }


  export type $countryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "country"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      country_id: number
      country_name: string | null
      active: boolean
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type countryGetPayload<S extends boolean | null | undefined | countryDefaultArgs> = $Result.GetResult<Prisma.$countryPayload, S>

  type countryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<countryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface countryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['country'], meta: { name: 'country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {countryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends countryFindUniqueArgs>(args: SelectSubset<T, countryFindUniqueArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {countryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends countryFindUniqueOrThrowArgs>(args: SelectSubset<T, countryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends countryFindFirstArgs>(args?: SelectSubset<T, countryFindFirstArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends countryFindFirstOrThrowArgs>(args?: SelectSubset<T, countryFindFirstOrThrowArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `country_id`
     * const countryWithCountry_idOnly = await prisma.country.findMany({ select: { country_id: true } })
     * 
     */
    findMany<T extends countryFindManyArgs>(args?: SelectSubset<T, countryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {countryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends countryCreateArgs>(args: SelectSubset<T, countryCreateArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {countryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends countryCreateManyArgs>(args?: SelectSubset<T, countryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {countryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends countryDeleteArgs>(args: SelectSubset<T, countryDeleteArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {countryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends countryUpdateArgs>(args: SelectSubset<T, countryUpdateArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {countryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends countryDeleteManyArgs>(args?: SelectSubset<T, countryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends countryUpdateManyArgs>(args: SelectSubset<T, countryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {countryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends countryUpsertArgs>(args: SelectSubset<T, countryUpsertArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countryCountArgs>(
      args?: Subset<T, countryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countryGroupByArgs['orderBy'] }
        : { orderBy?: countryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the country model
   */
  readonly fields: countryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__countryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the country model
   */ 
  interface countryFieldRefs {
    readonly country_id: FieldRef<"country", 'Int'>
    readonly country_name: FieldRef<"country", 'String'>
    readonly active: FieldRef<"country", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * country findUnique
   */
  export type countryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country findUniqueOrThrow
   */
  export type countryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country findFirst
   */
  export type countryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country findFirstOrThrow
   */
  export type countryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country findMany
   */
  export type countryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country create
   */
  export type countryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The data needed to create a country.
     */
    data?: XOR<countryCreateInput, countryUncheckedCreateInput>
  }

  /**
   * country createMany
   */
  export type countryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countryCreateManyInput | countryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * country update
   */
  export type countryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The data needed to update a country.
     */
    data: XOR<countryUpdateInput, countryUncheckedUpdateInput>
    /**
     * Choose, which country to update.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country updateMany
   */
  export type countryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countryUpdateManyMutationInput, countryUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countryWhereInput
  }

  /**
   * country upsert
   */
  export type countryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The filter to search for the country to update in case it exists.
     */
    where: countryWhereUniqueInput
    /**
     * In case the country found by the `where` argument doesn't exist, create a new country with this data.
     */
    create: XOR<countryCreateInput, countryUncheckedCreateInput>
    /**
     * In case the country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countryUpdateInput, countryUncheckedUpdateInput>
  }

  /**
   * country delete
   */
  export type countryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter which country to delete.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country deleteMany
   */
  export type countryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countryWhereInput
  }

  /**
   * country without action
   */
  export type countryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
  }


  /**
   * Model files
   */

  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: number | null
    file_name: string | null
    type: string | null
    medical_num: string | null
    patient_unique_id: string | null
    referral_id: string | null
    uploaded_on: Date | null
    status: $Enums.files_status | null
  }

  export type FilesMaxAggregateOutputType = {
    id: number | null
    file_name: string | null
    type: string | null
    medical_num: string | null
    patient_unique_id: string | null
    referral_id: string | null
    uploaded_on: Date | null
    status: $Enums.files_status | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    file_name: number
    type: number
    medical_num: number
    patient_unique_id: number
    referral_id: number
    uploaded_on: number
    status: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    file_name?: true
    type?: true
    medical_num?: true
    patient_unique_id?: true
    referral_id?: true
    uploaded_on?: true
    status?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    file_name?: true
    type?: true
    medical_num?: true
    patient_unique_id?: true
    referral_id?: true
    uploaded_on?: true
    status?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    file_name?: true
    type?: true
    medical_num?: true
    patient_unique_id?: true
    referral_id?: true
    uploaded_on?: true
    status?: true
    _all?: true
  }

  export type FilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to aggregate.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type filesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filesWhereInput
    orderBy?: filesOrderByWithAggregationInput | filesOrderByWithAggregationInput[]
    by: FilesScalarFieldEnum[] | FilesScalarFieldEnum
    having?: filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }

  export type FilesGroupByOutputType = {
    id: number
    file_name: string
    type: string
    medical_num: string
    patient_unique_id: string
    referral_id: string
    uploaded_on: Date
    status: $Enums.files_status
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends filesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type filesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    type?: boolean
    medical_num?: boolean
    patient_unique_id?: boolean
    referral_id?: boolean
    uploaded_on?: boolean
    status?: boolean
  }, ExtArgs["result"]["files"]>


  export type filesSelectScalar = {
    id?: boolean
    file_name?: boolean
    type?: boolean
    medical_num?: boolean
    patient_unique_id?: boolean
    referral_id?: boolean
    uploaded_on?: boolean
    status?: boolean
  }


  export type $filesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "files"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_name: string
      type: string
      medical_num: string
      patient_unique_id: string
      referral_id: string
      uploaded_on: Date
      status: $Enums.files_status
    }, ExtArgs["result"]["files"]>
    composites: {}
  }

  type filesGetPayload<S extends boolean | null | undefined | filesDefaultArgs> = $Result.GetResult<Prisma.$filesPayload, S>

  type filesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<filesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface filesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['files'], meta: { name: 'files' } }
    /**
     * Find zero or one Files that matches the filter.
     * @param {filesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends filesFindUniqueArgs>(args: SelectSubset<T, filesFindUniqueArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Files that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {filesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends filesFindUniqueOrThrowArgs>(args: SelectSubset<T, filesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends filesFindFirstArgs>(args?: SelectSubset<T, filesFindFirstArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends filesFindFirstOrThrowArgs>(args?: SelectSubset<T, filesFindFirstOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends filesFindManyArgs>(args?: SelectSubset<T, filesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Files.
     * @param {filesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
     */
    create<T extends filesCreateArgs>(args: SelectSubset<T, filesCreateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {filesCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends filesCreateManyArgs>(args?: SelectSubset<T, filesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {filesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
     */
    delete<T extends filesDeleteArgs>(args: SelectSubset<T, filesDeleteArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Files.
     * @param {filesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends filesUpdateArgs>(args: SelectSubset<T, filesUpdateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {filesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends filesDeleteManyArgs>(args?: SelectSubset<T, filesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends filesUpdateManyArgs>(args: SelectSubset<T, filesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {filesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
     */
    upsert<T extends filesUpsertArgs>(args: SelectSubset<T, filesUpsertArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends filesCountArgs>(
      args?: Subset<T, filesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filesGroupByArgs['orderBy'] }
        : { orderBy?: filesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the files model
   */
  readonly fields: filesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the files model
   */ 
  interface filesFieldRefs {
    readonly id: FieldRef<"files", 'Int'>
    readonly file_name: FieldRef<"files", 'String'>
    readonly type: FieldRef<"files", 'String'>
    readonly medical_num: FieldRef<"files", 'String'>
    readonly patient_unique_id: FieldRef<"files", 'String'>
    readonly referral_id: FieldRef<"files", 'String'>
    readonly uploaded_on: FieldRef<"files", 'DateTime'>
    readonly status: FieldRef<"files", 'files_status'>
  }
    

  // Custom InputTypes
  /**
   * files findUnique
   */
  export type filesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findUniqueOrThrow
   */
  export type filesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findFirst
   */
  export type filesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findFirstOrThrow
   */
  export type filesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findMany
   */
  export type filesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files create
   */
  export type filesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * The data needed to create a files.
     */
    data: XOR<filesCreateInput, filesUncheckedCreateInput>
  }

  /**
   * files createMany
   */
  export type filesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many files.
     */
    data: filesCreateManyInput | filesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * files update
   */
  export type filesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * The data needed to update a files.
     */
    data: XOR<filesUpdateInput, filesUncheckedUpdateInput>
    /**
     * Choose, which files to update.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files updateMany
   */
  export type filesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update files.
     */
    data: XOR<filesUpdateManyMutationInput, filesUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: filesWhereInput
  }

  /**
   * files upsert
   */
  export type filesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * The filter to search for the files to update in case it exists.
     */
    where: filesWhereUniqueInput
    /**
     * In case the files found by the `where` argument doesn't exist, create a new files with this data.
     */
    create: XOR<filesCreateInput, filesUncheckedCreateInput>
    /**
     * In case the files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filesUpdateInput, filesUncheckedUpdateInput>
  }

  /**
   * files delete
   */
  export type filesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Filter which files to delete.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files deleteMany
   */
  export type filesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to delete
     */
    where?: filesWhereInput
  }

  /**
   * files without action
   */
  export type filesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
  }


  /**
   * Model investigation_details
   */

  export type AggregateInvestigation_details = {
    _count: Investigation_detailsCountAggregateOutputType | null
    _avg: Investigation_detailsAvgAggregateOutputType | null
    _sum: Investigation_detailsSumAggregateOutputType | null
    _min: Investigation_detailsMinAggregateOutputType | null
    _max: Investigation_detailsMaxAggregateOutputType | null
  }

  export type Investigation_detailsAvgAggregateOutputType = {
    investigation_id: number | null
    active: number | null
  }

  export type Investigation_detailsSumAggregateOutputType = {
    investigation_id: number | null
    active: number | null
  }

  export type Investigation_detailsMinAggregateOutputType = {
    investigation_id: number | null
    investigation_name: string | null
    active: number | null
  }

  export type Investigation_detailsMaxAggregateOutputType = {
    investigation_id: number | null
    investigation_name: string | null
    active: number | null
  }

  export type Investigation_detailsCountAggregateOutputType = {
    investigation_id: number
    investigation_name: number
    active: number
    _all: number
  }


  export type Investigation_detailsAvgAggregateInputType = {
    investigation_id?: true
    active?: true
  }

  export type Investigation_detailsSumAggregateInputType = {
    investigation_id?: true
    active?: true
  }

  export type Investigation_detailsMinAggregateInputType = {
    investigation_id?: true
    investigation_name?: true
    active?: true
  }

  export type Investigation_detailsMaxAggregateInputType = {
    investigation_id?: true
    investigation_name?: true
    active?: true
  }

  export type Investigation_detailsCountAggregateInputType = {
    investigation_id?: true
    investigation_name?: true
    active?: true
    _all?: true
  }

  export type Investigation_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_details to aggregate.
     */
    where?: investigation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_details to fetch.
     */
    orderBy?: investigation_detailsOrderByWithRelationInput | investigation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investigation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investigation_details
    **/
    _count?: true | Investigation_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Investigation_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Investigation_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Investigation_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Investigation_detailsMaxAggregateInputType
  }

  export type GetInvestigation_detailsAggregateType<T extends Investigation_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigation_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigation_details[P]>
      : GetScalarType<T[P], AggregateInvestigation_details[P]>
  }




  export type investigation_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investigation_detailsWhereInput
    orderBy?: investigation_detailsOrderByWithAggregationInput | investigation_detailsOrderByWithAggregationInput[]
    by: Investigation_detailsScalarFieldEnum[] | Investigation_detailsScalarFieldEnum
    having?: investigation_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Investigation_detailsCountAggregateInputType | true
    _avg?: Investigation_detailsAvgAggregateInputType
    _sum?: Investigation_detailsSumAggregateInputType
    _min?: Investigation_detailsMinAggregateInputType
    _max?: Investigation_detailsMaxAggregateInputType
  }

  export type Investigation_detailsGroupByOutputType = {
    investigation_id: number
    investigation_name: string | null
    active: number | null
    _count: Investigation_detailsCountAggregateOutputType | null
    _avg: Investigation_detailsAvgAggregateOutputType | null
    _sum: Investigation_detailsSumAggregateOutputType | null
    _min: Investigation_detailsMinAggregateOutputType | null
    _max: Investigation_detailsMaxAggregateOutputType | null
  }

  type GetInvestigation_detailsGroupByPayload<T extends investigation_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Investigation_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Investigation_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Investigation_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Investigation_detailsGroupByOutputType[P]>
        }
      >
    >


  export type investigation_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    investigation_id?: boolean
    investigation_name?: boolean
    active?: boolean
    investigation_test_details?: boolean | investigation_details$investigation_test_detailsArgs<ExtArgs>
    _count?: boolean | Investigation_detailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation_details"]>


  export type investigation_detailsSelectScalar = {
    investigation_id?: boolean
    investigation_name?: boolean
    active?: boolean
  }

  export type investigation_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigation_test_details?: boolean | investigation_details$investigation_test_detailsArgs<ExtArgs>
    _count?: boolean | Investigation_detailsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $investigation_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investigation_details"
    objects: {
      investigation_test_details: Prisma.$investigation_test_detailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      investigation_id: number
      investigation_name: string | null
      active: number | null
    }, ExtArgs["result"]["investigation_details"]>
    composites: {}
  }

  type investigation_detailsGetPayload<S extends boolean | null | undefined | investigation_detailsDefaultArgs> = $Result.GetResult<Prisma.$investigation_detailsPayload, S>

  type investigation_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<investigation_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Investigation_detailsCountAggregateInputType | true
    }

  export interface investigation_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investigation_details'], meta: { name: 'investigation_details' } }
    /**
     * Find zero or one Investigation_details that matches the filter.
     * @param {investigation_detailsFindUniqueArgs} args - Arguments to find a Investigation_details
     * @example
     * // Get one Investigation_details
     * const investigation_details = await prisma.investigation_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investigation_detailsFindUniqueArgs>(args: SelectSubset<T, investigation_detailsFindUniqueArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investigation_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {investigation_detailsFindUniqueOrThrowArgs} args - Arguments to find a Investigation_details
     * @example
     * // Get one Investigation_details
     * const investigation_details = await prisma.investigation_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investigation_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, investigation_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investigation_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsFindFirstArgs} args - Arguments to find a Investigation_details
     * @example
     * // Get one Investigation_details
     * const investigation_details = await prisma.investigation_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investigation_detailsFindFirstArgs>(args?: SelectSubset<T, investigation_detailsFindFirstArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investigation_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsFindFirstOrThrowArgs} args - Arguments to find a Investigation_details
     * @example
     * // Get one Investigation_details
     * const investigation_details = await prisma.investigation_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investigation_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, investigation_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investigation_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investigation_details
     * const investigation_details = await prisma.investigation_details.findMany()
     * 
     * // Get first 10 Investigation_details
     * const investigation_details = await prisma.investigation_details.findMany({ take: 10 })
     * 
     * // Only select the `investigation_id`
     * const investigation_detailsWithInvestigation_idOnly = await prisma.investigation_details.findMany({ select: { investigation_id: true } })
     * 
     */
    findMany<T extends investigation_detailsFindManyArgs>(args?: SelectSubset<T, investigation_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investigation_details.
     * @param {investigation_detailsCreateArgs} args - Arguments to create a Investigation_details.
     * @example
     * // Create one Investigation_details
     * const Investigation_details = await prisma.investigation_details.create({
     *   data: {
     *     // ... data to create a Investigation_details
     *   }
     * })
     * 
     */
    create<T extends investigation_detailsCreateArgs>(args: SelectSubset<T, investigation_detailsCreateArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investigation_details.
     * @param {investigation_detailsCreateManyArgs} args - Arguments to create many Investigation_details.
     * @example
     * // Create many Investigation_details
     * const investigation_details = await prisma.investigation_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investigation_detailsCreateManyArgs>(args?: SelectSubset<T, investigation_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investigation_details.
     * @param {investigation_detailsDeleteArgs} args - Arguments to delete one Investigation_details.
     * @example
     * // Delete one Investigation_details
     * const Investigation_details = await prisma.investigation_details.delete({
     *   where: {
     *     // ... filter to delete one Investigation_details
     *   }
     * })
     * 
     */
    delete<T extends investigation_detailsDeleteArgs>(args: SelectSubset<T, investigation_detailsDeleteArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investigation_details.
     * @param {investigation_detailsUpdateArgs} args - Arguments to update one Investigation_details.
     * @example
     * // Update one Investigation_details
     * const investigation_details = await prisma.investigation_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investigation_detailsUpdateArgs>(args: SelectSubset<T, investigation_detailsUpdateArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investigation_details.
     * @param {investigation_detailsDeleteManyArgs} args - Arguments to filter Investigation_details to delete.
     * @example
     * // Delete a few Investigation_details
     * const { count } = await prisma.investigation_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investigation_detailsDeleteManyArgs>(args?: SelectSubset<T, investigation_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investigation_details
     * const investigation_details = await prisma.investigation_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investigation_detailsUpdateManyArgs>(args: SelectSubset<T, investigation_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investigation_details.
     * @param {investigation_detailsUpsertArgs} args - Arguments to update or create a Investigation_details.
     * @example
     * // Update or create a Investigation_details
     * const investigation_details = await prisma.investigation_details.upsert({
     *   create: {
     *     // ... data to create a Investigation_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investigation_details we want to update
     *   }
     * })
     */
    upsert<T extends investigation_detailsUpsertArgs>(args: SelectSubset<T, investigation_detailsUpsertArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investigation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsCountArgs} args - Arguments to filter Investigation_details to count.
     * @example
     * // Count the number of Investigation_details
     * const count = await prisma.investigation_details.count({
     *   where: {
     *     // ... the filter for the Investigation_details we want to count
     *   }
     * })
    **/
    count<T extends investigation_detailsCountArgs>(
      args?: Subset<T, investigation_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investigation_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investigation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Investigation_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investigation_detailsAggregateArgs>(args: Subset<T, Investigation_detailsAggregateArgs>): Prisma.PrismaPromise<GetInvestigation_detailsAggregateType<T>>

    /**
     * Group by Investigation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investigation_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investigation_detailsGroupByArgs['orderBy'] }
        : { orderBy?: investigation_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investigation_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigation_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investigation_details model
   */
  readonly fields: investigation_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investigation_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investigation_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investigation_test_details<T extends investigation_details$investigation_test_detailsArgs<ExtArgs> = {}>(args?: Subset<T, investigation_details$investigation_test_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investigation_details model
   */ 
  interface investigation_detailsFieldRefs {
    readonly investigation_id: FieldRef<"investigation_details", 'Int'>
    readonly investigation_name: FieldRef<"investigation_details", 'String'>
    readonly active: FieldRef<"investigation_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * investigation_details findUnique
   */
  export type investigation_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_details to fetch.
     */
    where: investigation_detailsWhereUniqueInput
  }

  /**
   * investigation_details findUniqueOrThrow
   */
  export type investigation_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_details to fetch.
     */
    where: investigation_detailsWhereUniqueInput
  }

  /**
   * investigation_details findFirst
   */
  export type investigation_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_details to fetch.
     */
    where?: investigation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_details to fetch.
     */
    orderBy?: investigation_detailsOrderByWithRelationInput | investigation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_details.
     */
    cursor?: investigation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_details.
     */
    distinct?: Investigation_detailsScalarFieldEnum | Investigation_detailsScalarFieldEnum[]
  }

  /**
   * investigation_details findFirstOrThrow
   */
  export type investigation_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_details to fetch.
     */
    where?: investigation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_details to fetch.
     */
    orderBy?: investigation_detailsOrderByWithRelationInput | investigation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_details.
     */
    cursor?: investigation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_details.
     */
    distinct?: Investigation_detailsScalarFieldEnum | Investigation_detailsScalarFieldEnum[]
  }

  /**
   * investigation_details findMany
   */
  export type investigation_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_details to fetch.
     */
    where?: investigation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_details to fetch.
     */
    orderBy?: investigation_detailsOrderByWithRelationInput | investigation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investigation_details.
     */
    cursor?: investigation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_details.
     */
    skip?: number
    distinct?: Investigation_detailsScalarFieldEnum | Investigation_detailsScalarFieldEnum[]
  }

  /**
   * investigation_details create
   */
  export type investigation_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a investigation_details.
     */
    data?: XOR<investigation_detailsCreateInput, investigation_detailsUncheckedCreateInput>
  }

  /**
   * investigation_details createMany
   */
  export type investigation_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investigation_details.
     */
    data: investigation_detailsCreateManyInput | investigation_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investigation_details update
   */
  export type investigation_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a investigation_details.
     */
    data: XOR<investigation_detailsUpdateInput, investigation_detailsUncheckedUpdateInput>
    /**
     * Choose, which investigation_details to update.
     */
    where: investigation_detailsWhereUniqueInput
  }

  /**
   * investigation_details updateMany
   */
  export type investigation_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investigation_details.
     */
    data: XOR<investigation_detailsUpdateManyMutationInput, investigation_detailsUncheckedUpdateManyInput>
    /**
     * Filter which investigation_details to update
     */
    where?: investigation_detailsWhereInput
  }

  /**
   * investigation_details upsert
   */
  export type investigation_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the investigation_details to update in case it exists.
     */
    where: investigation_detailsWhereUniqueInput
    /**
     * In case the investigation_details found by the `where` argument doesn't exist, create a new investigation_details with this data.
     */
    create: XOR<investigation_detailsCreateInput, investigation_detailsUncheckedCreateInput>
    /**
     * In case the investigation_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investigation_detailsUpdateInput, investigation_detailsUncheckedUpdateInput>
  }

  /**
   * investigation_details delete
   */
  export type investigation_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
    /**
     * Filter which investigation_details to delete.
     */
    where: investigation_detailsWhereUniqueInput
  }

  /**
   * investigation_details deleteMany
   */
  export type investigation_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_details to delete
     */
    where?: investigation_detailsWhereInput
  }

  /**
   * investigation_details.investigation_test_details
   */
  export type investigation_details$investigation_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    where?: investigation_test_detailsWhereInput
    orderBy?: investigation_test_detailsOrderByWithRelationInput | investigation_test_detailsOrderByWithRelationInput[]
    cursor?: investigation_test_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Investigation_test_detailsScalarFieldEnum | Investigation_test_detailsScalarFieldEnum[]
  }

  /**
   * investigation_details without action
   */
  export type investigation_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_details
     */
    select?: investigation_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_detailsInclude<ExtArgs> | null
  }


  /**
   * Model investigation_file
   */

  export type AggregateInvestigation_file = {
    _count: Investigation_fileCountAggregateOutputType | null
    _avg: Investigation_fileAvgAggregateOutputType | null
    _sum: Investigation_fileSumAggregateOutputType | null
    _min: Investigation_fileMinAggregateOutputType | null
    _max: Investigation_fileMaxAggregateOutputType | null
  }

  export type Investigation_fileAvgAggregateOutputType = {
    file_id: number | null
    referral_test_ID: number | null
  }

  export type Investigation_fileSumAggregateOutputType = {
    file_id: number | null
    referral_test_ID: number | null
  }

  export type Investigation_fileMinAggregateOutputType = {
    file_id: number | null
    investigation_file: string | null
    referral_test_ID: number | null
    uploaded_on: Date | null
  }

  export type Investigation_fileMaxAggregateOutputType = {
    file_id: number | null
    investigation_file: string | null
    referral_test_ID: number | null
    uploaded_on: Date | null
  }

  export type Investigation_fileCountAggregateOutputType = {
    file_id: number
    investigation_file: number
    referral_test_ID: number
    uploaded_on: number
    _all: number
  }


  export type Investigation_fileAvgAggregateInputType = {
    file_id?: true
    referral_test_ID?: true
  }

  export type Investigation_fileSumAggregateInputType = {
    file_id?: true
    referral_test_ID?: true
  }

  export type Investigation_fileMinAggregateInputType = {
    file_id?: true
    investigation_file?: true
    referral_test_ID?: true
    uploaded_on?: true
  }

  export type Investigation_fileMaxAggregateInputType = {
    file_id?: true
    investigation_file?: true
    referral_test_ID?: true
    uploaded_on?: true
  }

  export type Investigation_fileCountAggregateInputType = {
    file_id?: true
    investigation_file?: true
    referral_test_ID?: true
    uploaded_on?: true
    _all?: true
  }

  export type Investigation_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_file to aggregate.
     */
    where?: investigation_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_files to fetch.
     */
    orderBy?: investigation_fileOrderByWithRelationInput | investigation_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investigation_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investigation_files
    **/
    _count?: true | Investigation_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Investigation_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Investigation_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Investigation_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Investigation_fileMaxAggregateInputType
  }

  export type GetInvestigation_fileAggregateType<T extends Investigation_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigation_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigation_file[P]>
      : GetScalarType<T[P], AggregateInvestigation_file[P]>
  }




  export type investigation_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investigation_fileWhereInput
    orderBy?: investigation_fileOrderByWithAggregationInput | investigation_fileOrderByWithAggregationInput[]
    by: Investigation_fileScalarFieldEnum[] | Investigation_fileScalarFieldEnum
    having?: investigation_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Investigation_fileCountAggregateInputType | true
    _avg?: Investigation_fileAvgAggregateInputType
    _sum?: Investigation_fileSumAggregateInputType
    _min?: Investigation_fileMinAggregateInputType
    _max?: Investigation_fileMaxAggregateInputType
  }

  export type Investigation_fileGroupByOutputType = {
    file_id: number
    investigation_file: string
    referral_test_ID: number
    uploaded_on: Date
    _count: Investigation_fileCountAggregateOutputType | null
    _avg: Investigation_fileAvgAggregateOutputType | null
    _sum: Investigation_fileSumAggregateOutputType | null
    _min: Investigation_fileMinAggregateOutputType | null
    _max: Investigation_fileMaxAggregateOutputType | null
  }

  type GetInvestigation_fileGroupByPayload<T extends investigation_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Investigation_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Investigation_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Investigation_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Investigation_fileGroupByOutputType[P]>
        }
      >
    >


  export type investigation_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    file_id?: boolean
    investigation_file?: boolean
    referral_test_ID?: boolean
    uploaded_on?: boolean
  }, ExtArgs["result"]["investigation_file"]>


  export type investigation_fileSelectScalar = {
    file_id?: boolean
    investigation_file?: boolean
    referral_test_ID?: boolean
    uploaded_on?: boolean
  }


  export type $investigation_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investigation_file"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      file_id: number
      investigation_file: string
      referral_test_ID: number
      uploaded_on: Date
    }, ExtArgs["result"]["investigation_file"]>
    composites: {}
  }

  type investigation_fileGetPayload<S extends boolean | null | undefined | investigation_fileDefaultArgs> = $Result.GetResult<Prisma.$investigation_filePayload, S>

  type investigation_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<investigation_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Investigation_fileCountAggregateInputType | true
    }

  export interface investigation_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investigation_file'], meta: { name: 'investigation_file' } }
    /**
     * Find zero or one Investigation_file that matches the filter.
     * @param {investigation_fileFindUniqueArgs} args - Arguments to find a Investigation_file
     * @example
     * // Get one Investigation_file
     * const investigation_file = await prisma.investigation_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investigation_fileFindUniqueArgs>(args: SelectSubset<T, investigation_fileFindUniqueArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investigation_file that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {investigation_fileFindUniqueOrThrowArgs} args - Arguments to find a Investigation_file
     * @example
     * // Get one Investigation_file
     * const investigation_file = await prisma.investigation_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investigation_fileFindUniqueOrThrowArgs>(args: SelectSubset<T, investigation_fileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investigation_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileFindFirstArgs} args - Arguments to find a Investigation_file
     * @example
     * // Get one Investigation_file
     * const investigation_file = await prisma.investigation_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investigation_fileFindFirstArgs>(args?: SelectSubset<T, investigation_fileFindFirstArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investigation_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileFindFirstOrThrowArgs} args - Arguments to find a Investigation_file
     * @example
     * // Get one Investigation_file
     * const investigation_file = await prisma.investigation_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investigation_fileFindFirstOrThrowArgs>(args?: SelectSubset<T, investigation_fileFindFirstOrThrowArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investigation_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investigation_files
     * const investigation_files = await prisma.investigation_file.findMany()
     * 
     * // Get first 10 Investigation_files
     * const investigation_files = await prisma.investigation_file.findMany({ take: 10 })
     * 
     * // Only select the `file_id`
     * const investigation_fileWithFile_idOnly = await prisma.investigation_file.findMany({ select: { file_id: true } })
     * 
     */
    findMany<T extends investigation_fileFindManyArgs>(args?: SelectSubset<T, investigation_fileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investigation_file.
     * @param {investigation_fileCreateArgs} args - Arguments to create a Investigation_file.
     * @example
     * // Create one Investigation_file
     * const Investigation_file = await prisma.investigation_file.create({
     *   data: {
     *     // ... data to create a Investigation_file
     *   }
     * })
     * 
     */
    create<T extends investigation_fileCreateArgs>(args: SelectSubset<T, investigation_fileCreateArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investigation_files.
     * @param {investigation_fileCreateManyArgs} args - Arguments to create many Investigation_files.
     * @example
     * // Create many Investigation_files
     * const investigation_file = await prisma.investigation_file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investigation_fileCreateManyArgs>(args?: SelectSubset<T, investigation_fileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investigation_file.
     * @param {investigation_fileDeleteArgs} args - Arguments to delete one Investigation_file.
     * @example
     * // Delete one Investigation_file
     * const Investigation_file = await prisma.investigation_file.delete({
     *   where: {
     *     // ... filter to delete one Investigation_file
     *   }
     * })
     * 
     */
    delete<T extends investigation_fileDeleteArgs>(args: SelectSubset<T, investigation_fileDeleteArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investigation_file.
     * @param {investigation_fileUpdateArgs} args - Arguments to update one Investigation_file.
     * @example
     * // Update one Investigation_file
     * const investigation_file = await prisma.investigation_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investigation_fileUpdateArgs>(args: SelectSubset<T, investigation_fileUpdateArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investigation_files.
     * @param {investigation_fileDeleteManyArgs} args - Arguments to filter Investigation_files to delete.
     * @example
     * // Delete a few Investigation_files
     * const { count } = await prisma.investigation_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investigation_fileDeleteManyArgs>(args?: SelectSubset<T, investigation_fileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigation_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investigation_files
     * const investigation_file = await prisma.investigation_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investigation_fileUpdateManyArgs>(args: SelectSubset<T, investigation_fileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investigation_file.
     * @param {investigation_fileUpsertArgs} args - Arguments to update or create a Investigation_file.
     * @example
     * // Update or create a Investigation_file
     * const investigation_file = await prisma.investigation_file.upsert({
     *   create: {
     *     // ... data to create a Investigation_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investigation_file we want to update
     *   }
     * })
     */
    upsert<T extends investigation_fileUpsertArgs>(args: SelectSubset<T, investigation_fileUpsertArgs<ExtArgs>>): Prisma__investigation_fileClient<$Result.GetResult<Prisma.$investigation_filePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investigation_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileCountArgs} args - Arguments to filter Investigation_files to count.
     * @example
     * // Count the number of Investigation_files
     * const count = await prisma.investigation_file.count({
     *   where: {
     *     // ... the filter for the Investigation_files we want to count
     *   }
     * })
    **/
    count<T extends investigation_fileCountArgs>(
      args?: Subset<T, investigation_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investigation_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investigation_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Investigation_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investigation_fileAggregateArgs>(args: Subset<T, Investigation_fileAggregateArgs>): Prisma.PrismaPromise<GetInvestigation_fileAggregateType<T>>

    /**
     * Group by Investigation_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investigation_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investigation_fileGroupByArgs['orderBy'] }
        : { orderBy?: investigation_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investigation_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigation_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investigation_file model
   */
  readonly fields: investigation_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investigation_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investigation_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investigation_file model
   */ 
  interface investigation_fileFieldRefs {
    readonly file_id: FieldRef<"investigation_file", 'Int'>
    readonly investigation_file: FieldRef<"investigation_file", 'String'>
    readonly referral_test_ID: FieldRef<"investigation_file", 'Int'>
    readonly uploaded_on: FieldRef<"investigation_file", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * investigation_file findUnique
   */
  export type investigation_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter, which investigation_file to fetch.
     */
    where: investigation_fileWhereUniqueInput
  }

  /**
   * investigation_file findUniqueOrThrow
   */
  export type investigation_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter, which investigation_file to fetch.
     */
    where: investigation_fileWhereUniqueInput
  }

  /**
   * investigation_file findFirst
   */
  export type investigation_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter, which investigation_file to fetch.
     */
    where?: investigation_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_files to fetch.
     */
    orderBy?: investigation_fileOrderByWithRelationInput | investigation_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_files.
     */
    cursor?: investigation_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_files.
     */
    distinct?: Investigation_fileScalarFieldEnum | Investigation_fileScalarFieldEnum[]
  }

  /**
   * investigation_file findFirstOrThrow
   */
  export type investigation_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter, which investigation_file to fetch.
     */
    where?: investigation_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_files to fetch.
     */
    orderBy?: investigation_fileOrderByWithRelationInput | investigation_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_files.
     */
    cursor?: investigation_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_files.
     */
    distinct?: Investigation_fileScalarFieldEnum | Investigation_fileScalarFieldEnum[]
  }

  /**
   * investigation_file findMany
   */
  export type investigation_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter, which investigation_files to fetch.
     */
    where?: investigation_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_files to fetch.
     */
    orderBy?: investigation_fileOrderByWithRelationInput | investigation_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investigation_files.
     */
    cursor?: investigation_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_files.
     */
    skip?: number
    distinct?: Investigation_fileScalarFieldEnum | Investigation_fileScalarFieldEnum[]
  }

  /**
   * investigation_file create
   */
  export type investigation_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * The data needed to create a investigation_file.
     */
    data: XOR<investigation_fileCreateInput, investigation_fileUncheckedCreateInput>
  }

  /**
   * investigation_file createMany
   */
  export type investigation_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investigation_files.
     */
    data: investigation_fileCreateManyInput | investigation_fileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investigation_file update
   */
  export type investigation_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * The data needed to update a investigation_file.
     */
    data: XOR<investigation_fileUpdateInput, investigation_fileUncheckedUpdateInput>
    /**
     * Choose, which investigation_file to update.
     */
    where: investigation_fileWhereUniqueInput
  }

  /**
   * investigation_file updateMany
   */
  export type investigation_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investigation_files.
     */
    data: XOR<investigation_fileUpdateManyMutationInput, investigation_fileUncheckedUpdateManyInput>
    /**
     * Filter which investigation_files to update
     */
    where?: investigation_fileWhereInput
  }

  /**
   * investigation_file upsert
   */
  export type investigation_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * The filter to search for the investigation_file to update in case it exists.
     */
    where: investigation_fileWhereUniqueInput
    /**
     * In case the investigation_file found by the `where` argument doesn't exist, create a new investigation_file with this data.
     */
    create: XOR<investigation_fileCreateInput, investigation_fileUncheckedCreateInput>
    /**
     * In case the investigation_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investigation_fileUpdateInput, investigation_fileUncheckedUpdateInput>
  }

  /**
   * investigation_file delete
   */
  export type investigation_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
    /**
     * Filter which investigation_file to delete.
     */
    where: investigation_fileWhereUniqueInput
  }

  /**
   * investigation_file deleteMany
   */
  export type investigation_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_files to delete
     */
    where?: investigation_fileWhereInput
  }

  /**
   * investigation_file without action
   */
  export type investigation_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_file
     */
    select?: investigation_fileSelect<ExtArgs> | null
  }


  /**
   * Model investigation_test_details
   */

  export type AggregateInvestigation_test_details = {
    _count: Investigation_test_detailsCountAggregateOutputType | null
    _avg: Investigation_test_detailsAvgAggregateOutputType | null
    _sum: Investigation_test_detailsSumAggregateOutputType | null
    _min: Investigation_test_detailsMinAggregateOutputType | null
    _max: Investigation_test_detailsMaxAggregateOutputType | null
  }

  export type Investigation_test_detailsAvgAggregateOutputType = {
    parse_id: number | null
    investigation_id: number | null
    parent_parse_id: number | null
    active: number | null
  }

  export type Investigation_test_detailsSumAggregateOutputType = {
    parse_id: number | null
    investigation_id: number | null
    parent_parse_id: number | null
    active: number | null
  }

  export type Investigation_test_detailsMinAggregateOutputType = {
    parse_id: number | null
    test_name: string | null
    investigation_id: number | null
    parent_parse_id: number | null
    active: number | null
  }

  export type Investigation_test_detailsMaxAggregateOutputType = {
    parse_id: number | null
    test_name: string | null
    investigation_id: number | null
    parent_parse_id: number | null
    active: number | null
  }

  export type Investigation_test_detailsCountAggregateOutputType = {
    parse_id: number
    test_name: number
    investigation_id: number
    parent_parse_id: number
    active: number
    _all: number
  }


  export type Investigation_test_detailsAvgAggregateInputType = {
    parse_id?: true
    investigation_id?: true
    parent_parse_id?: true
    active?: true
  }

  export type Investigation_test_detailsSumAggregateInputType = {
    parse_id?: true
    investigation_id?: true
    parent_parse_id?: true
    active?: true
  }

  export type Investigation_test_detailsMinAggregateInputType = {
    parse_id?: true
    test_name?: true
    investigation_id?: true
    parent_parse_id?: true
    active?: true
  }

  export type Investigation_test_detailsMaxAggregateInputType = {
    parse_id?: true
    test_name?: true
    investigation_id?: true
    parent_parse_id?: true
    active?: true
  }

  export type Investigation_test_detailsCountAggregateInputType = {
    parse_id?: true
    test_name?: true
    investigation_id?: true
    parent_parse_id?: true
    active?: true
    _all?: true
  }

  export type Investigation_test_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_test_details to aggregate.
     */
    where?: investigation_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_test_details to fetch.
     */
    orderBy?: investigation_test_detailsOrderByWithRelationInput | investigation_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investigation_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investigation_test_details
    **/
    _count?: true | Investigation_test_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Investigation_test_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Investigation_test_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Investigation_test_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Investigation_test_detailsMaxAggregateInputType
  }

  export type GetInvestigation_test_detailsAggregateType<T extends Investigation_test_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigation_test_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigation_test_details[P]>
      : GetScalarType<T[P], AggregateInvestigation_test_details[P]>
  }




  export type investigation_test_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investigation_test_detailsWhereInput
    orderBy?: investigation_test_detailsOrderByWithAggregationInput | investigation_test_detailsOrderByWithAggregationInput[]
    by: Investigation_test_detailsScalarFieldEnum[] | Investigation_test_detailsScalarFieldEnum
    having?: investigation_test_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Investigation_test_detailsCountAggregateInputType | true
    _avg?: Investigation_test_detailsAvgAggregateInputType
    _sum?: Investigation_test_detailsSumAggregateInputType
    _min?: Investigation_test_detailsMinAggregateInputType
    _max?: Investigation_test_detailsMaxAggregateInputType
  }

  export type Investigation_test_detailsGroupByOutputType = {
    parse_id: number
    test_name: string
    investigation_id: number
    parent_parse_id: number
    active: number
    _count: Investigation_test_detailsCountAggregateOutputType | null
    _avg: Investigation_test_detailsAvgAggregateOutputType | null
    _sum: Investigation_test_detailsSumAggregateOutputType | null
    _min: Investigation_test_detailsMinAggregateOutputType | null
    _max: Investigation_test_detailsMaxAggregateOutputType | null
  }

  type GetInvestigation_test_detailsGroupByPayload<T extends investigation_test_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Investigation_test_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Investigation_test_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Investigation_test_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Investigation_test_detailsGroupByOutputType[P]>
        }
      >
    >


  export type investigation_test_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parse_id?: boolean
    test_name?: boolean
    investigation_id?: boolean
    parent_parse_id?: boolean
    active?: boolean
    investigation_details?: boolean | investigation_detailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation_test_details"]>


  export type investigation_test_detailsSelectScalar = {
    parse_id?: boolean
    test_name?: boolean
    investigation_id?: boolean
    parent_parse_id?: boolean
    active?: boolean
  }

  export type investigation_test_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigation_details?: boolean | investigation_detailsDefaultArgs<ExtArgs>
  }

  export type $investigation_test_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investigation_test_details"
    objects: {
      investigation_details: Prisma.$investigation_detailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      parse_id: number
      test_name: string
      investigation_id: number
      parent_parse_id: number
      active: number
    }, ExtArgs["result"]["investigation_test_details"]>
    composites: {}
  }

  type investigation_test_detailsGetPayload<S extends boolean | null | undefined | investigation_test_detailsDefaultArgs> = $Result.GetResult<Prisma.$investigation_test_detailsPayload, S>

  type investigation_test_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<investigation_test_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Investigation_test_detailsCountAggregateInputType | true
    }

  export interface investigation_test_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investigation_test_details'], meta: { name: 'investigation_test_details' } }
    /**
     * Find zero or one Investigation_test_details that matches the filter.
     * @param {investigation_test_detailsFindUniqueArgs} args - Arguments to find a Investigation_test_details
     * @example
     * // Get one Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investigation_test_detailsFindUniqueArgs>(args: SelectSubset<T, investigation_test_detailsFindUniqueArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investigation_test_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {investigation_test_detailsFindUniqueOrThrowArgs} args - Arguments to find a Investigation_test_details
     * @example
     * // Get one Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investigation_test_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, investigation_test_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investigation_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsFindFirstArgs} args - Arguments to find a Investigation_test_details
     * @example
     * // Get one Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investigation_test_detailsFindFirstArgs>(args?: SelectSubset<T, investigation_test_detailsFindFirstArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investigation_test_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsFindFirstOrThrowArgs} args - Arguments to find a Investigation_test_details
     * @example
     * // Get one Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investigation_test_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, investigation_test_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investigation_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findMany()
     * 
     * // Get first 10 Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.findMany({ take: 10 })
     * 
     * // Only select the `parse_id`
     * const investigation_test_detailsWithParse_idOnly = await prisma.investigation_test_details.findMany({ select: { parse_id: true } })
     * 
     */
    findMany<T extends investigation_test_detailsFindManyArgs>(args?: SelectSubset<T, investigation_test_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investigation_test_details.
     * @param {investigation_test_detailsCreateArgs} args - Arguments to create a Investigation_test_details.
     * @example
     * // Create one Investigation_test_details
     * const Investigation_test_details = await prisma.investigation_test_details.create({
     *   data: {
     *     // ... data to create a Investigation_test_details
     *   }
     * })
     * 
     */
    create<T extends investigation_test_detailsCreateArgs>(args: SelectSubset<T, investigation_test_detailsCreateArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investigation_test_details.
     * @param {investigation_test_detailsCreateManyArgs} args - Arguments to create many Investigation_test_details.
     * @example
     * // Create many Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investigation_test_detailsCreateManyArgs>(args?: SelectSubset<T, investigation_test_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investigation_test_details.
     * @param {investigation_test_detailsDeleteArgs} args - Arguments to delete one Investigation_test_details.
     * @example
     * // Delete one Investigation_test_details
     * const Investigation_test_details = await prisma.investigation_test_details.delete({
     *   where: {
     *     // ... filter to delete one Investigation_test_details
     *   }
     * })
     * 
     */
    delete<T extends investigation_test_detailsDeleteArgs>(args: SelectSubset<T, investigation_test_detailsDeleteArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investigation_test_details.
     * @param {investigation_test_detailsUpdateArgs} args - Arguments to update one Investigation_test_details.
     * @example
     * // Update one Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investigation_test_detailsUpdateArgs>(args: SelectSubset<T, investigation_test_detailsUpdateArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investigation_test_details.
     * @param {investigation_test_detailsDeleteManyArgs} args - Arguments to filter Investigation_test_details to delete.
     * @example
     * // Delete a few Investigation_test_details
     * const { count } = await prisma.investigation_test_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investigation_test_detailsDeleteManyArgs>(args?: SelectSubset<T, investigation_test_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigation_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investigation_test_detailsUpdateManyArgs>(args: SelectSubset<T, investigation_test_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investigation_test_details.
     * @param {investigation_test_detailsUpsertArgs} args - Arguments to update or create a Investigation_test_details.
     * @example
     * // Update or create a Investigation_test_details
     * const investigation_test_details = await prisma.investigation_test_details.upsert({
     *   create: {
     *     // ... data to create a Investigation_test_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investigation_test_details we want to update
     *   }
     * })
     */
    upsert<T extends investigation_test_detailsUpsertArgs>(args: SelectSubset<T, investigation_test_detailsUpsertArgs<ExtArgs>>): Prisma__investigation_test_detailsClient<$Result.GetResult<Prisma.$investigation_test_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investigation_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsCountArgs} args - Arguments to filter Investigation_test_details to count.
     * @example
     * // Count the number of Investigation_test_details
     * const count = await prisma.investigation_test_details.count({
     *   where: {
     *     // ... the filter for the Investigation_test_details we want to count
     *   }
     * })
    **/
    count<T extends investigation_test_detailsCountArgs>(
      args?: Subset<T, investigation_test_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investigation_test_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investigation_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Investigation_test_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investigation_test_detailsAggregateArgs>(args: Subset<T, Investigation_test_detailsAggregateArgs>): Prisma.PrismaPromise<GetInvestigation_test_detailsAggregateType<T>>

    /**
     * Group by Investigation_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investigation_test_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investigation_test_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investigation_test_detailsGroupByArgs['orderBy'] }
        : { orderBy?: investigation_test_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investigation_test_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigation_test_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investigation_test_details model
   */
  readonly fields: investigation_test_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investigation_test_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investigation_test_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investigation_details<T extends investigation_detailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, investigation_detailsDefaultArgs<ExtArgs>>): Prisma__investigation_detailsClient<$Result.GetResult<Prisma.$investigation_detailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investigation_test_details model
   */ 
  interface investigation_test_detailsFieldRefs {
    readonly parse_id: FieldRef<"investigation_test_details", 'Int'>
    readonly test_name: FieldRef<"investigation_test_details", 'String'>
    readonly investigation_id: FieldRef<"investigation_test_details", 'Int'>
    readonly parent_parse_id: FieldRef<"investigation_test_details", 'Int'>
    readonly active: FieldRef<"investigation_test_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * investigation_test_details findUnique
   */
  export type investigation_test_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_test_details to fetch.
     */
    where: investigation_test_detailsWhereUniqueInput
  }

  /**
   * investigation_test_details findUniqueOrThrow
   */
  export type investigation_test_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_test_details to fetch.
     */
    where: investigation_test_detailsWhereUniqueInput
  }

  /**
   * investigation_test_details findFirst
   */
  export type investigation_test_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_test_details to fetch.
     */
    where?: investigation_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_test_details to fetch.
     */
    orderBy?: investigation_test_detailsOrderByWithRelationInput | investigation_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_test_details.
     */
    cursor?: investigation_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_test_details.
     */
    distinct?: Investigation_test_detailsScalarFieldEnum | Investigation_test_detailsScalarFieldEnum[]
  }

  /**
   * investigation_test_details findFirstOrThrow
   */
  export type investigation_test_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_test_details to fetch.
     */
    where?: investigation_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_test_details to fetch.
     */
    orderBy?: investigation_test_detailsOrderByWithRelationInput | investigation_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investigation_test_details.
     */
    cursor?: investigation_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investigation_test_details.
     */
    distinct?: Investigation_test_detailsScalarFieldEnum | Investigation_test_detailsScalarFieldEnum[]
  }

  /**
   * investigation_test_details findMany
   */
  export type investigation_test_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which investigation_test_details to fetch.
     */
    where?: investigation_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investigation_test_details to fetch.
     */
    orderBy?: investigation_test_detailsOrderByWithRelationInput | investigation_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investigation_test_details.
     */
    cursor?: investigation_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investigation_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investigation_test_details.
     */
    skip?: number
    distinct?: Investigation_test_detailsScalarFieldEnum | Investigation_test_detailsScalarFieldEnum[]
  }

  /**
   * investigation_test_details create
   */
  export type investigation_test_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a investigation_test_details.
     */
    data: XOR<investigation_test_detailsCreateInput, investigation_test_detailsUncheckedCreateInput>
  }

  /**
   * investigation_test_details createMany
   */
  export type investigation_test_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investigation_test_details.
     */
    data: investigation_test_detailsCreateManyInput | investigation_test_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investigation_test_details update
   */
  export type investigation_test_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a investigation_test_details.
     */
    data: XOR<investigation_test_detailsUpdateInput, investigation_test_detailsUncheckedUpdateInput>
    /**
     * Choose, which investigation_test_details to update.
     */
    where: investigation_test_detailsWhereUniqueInput
  }

  /**
   * investigation_test_details updateMany
   */
  export type investigation_test_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investigation_test_details.
     */
    data: XOR<investigation_test_detailsUpdateManyMutationInput, investigation_test_detailsUncheckedUpdateManyInput>
    /**
     * Filter which investigation_test_details to update
     */
    where?: investigation_test_detailsWhereInput
  }

  /**
   * investigation_test_details upsert
   */
  export type investigation_test_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the investigation_test_details to update in case it exists.
     */
    where: investigation_test_detailsWhereUniqueInput
    /**
     * In case the investigation_test_details found by the `where` argument doesn't exist, create a new investigation_test_details with this data.
     */
    create: XOR<investigation_test_detailsCreateInput, investigation_test_detailsUncheckedCreateInput>
    /**
     * In case the investigation_test_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investigation_test_detailsUpdateInput, investigation_test_detailsUncheckedUpdateInput>
  }

  /**
   * investigation_test_details delete
   */
  export type investigation_test_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
    /**
     * Filter which investigation_test_details to delete.
     */
    where: investigation_test_detailsWhereUniqueInput
  }

  /**
   * investigation_test_details deleteMany
   */
  export type investigation_test_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investigation_test_details to delete
     */
    where?: investigation_test_detailsWhereInput
  }

  /**
   * investigation_test_details without action
   */
  export type investigation_test_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investigation_test_details
     */
    select?: investigation_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investigation_test_detailsInclude<ExtArgs> | null
  }


  /**
   * Model lab_leaves
   */

  export type AggregateLab_leaves = {
    _count: Lab_leavesCountAggregateOutputType | null
    _avg: Lab_leavesAvgAggregateOutputType | null
    _sum: Lab_leavesSumAggregateOutputType | null
    _min: Lab_leavesMinAggregateOutputType | null
    _max: Lab_leavesMaxAggregateOutputType | null
  }

  export type Lab_leavesAvgAggregateOutputType = {
    id: number | null
    lab_id: number | null
  }

  export type Lab_leavesSumAggregateOutputType = {
    id: number | null
    lab_id: bigint | null
  }

  export type Lab_leavesMinAggregateOutputType = {
    id: number | null
    lab_id: bigint | null
    dates: string | null
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string | null
  }

  export type Lab_leavesMaxAggregateOutputType = {
    id: number | null
    lab_id: bigint | null
    dates: string | null
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string | null
  }

  export type Lab_leavesCountAggregateOutputType = {
    id: number
    lab_id: number
    dates: number
    start_time: number
    end_time: number
    reason: number
    created_time: number
    _all: number
  }


  export type Lab_leavesAvgAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type Lab_leavesSumAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type Lab_leavesMinAggregateInputType = {
    id?: true
    lab_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
  }

  export type Lab_leavesMaxAggregateInputType = {
    id?: true
    lab_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
  }

  export type Lab_leavesCountAggregateInputType = {
    id?: true
    lab_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
    _all?: true
  }

  export type Lab_leavesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_leaves to aggregate.
     */
    where?: lab_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_leaves to fetch.
     */
    orderBy?: lab_leavesOrderByWithRelationInput | lab_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_leaves
    **/
    _count?: true | Lab_leavesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lab_leavesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lab_leavesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_leavesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_leavesMaxAggregateInputType
  }

  export type GetLab_leavesAggregateType<T extends Lab_leavesAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_leaves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_leaves[P]>
      : GetScalarType<T[P], AggregateLab_leaves[P]>
  }




  export type lab_leavesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_leavesWhereInput
    orderBy?: lab_leavesOrderByWithAggregationInput | lab_leavesOrderByWithAggregationInput[]
    by: Lab_leavesScalarFieldEnum[] | Lab_leavesScalarFieldEnum
    having?: lab_leavesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_leavesCountAggregateInputType | true
    _avg?: Lab_leavesAvgAggregateInputType
    _sum?: Lab_leavesSumAggregateInputType
    _min?: Lab_leavesMinAggregateInputType
    _max?: Lab_leavesMaxAggregateInputType
  }

  export type Lab_leavesGroupByOutputType = {
    id: number
    lab_id: bigint
    dates: string
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string
    _count: Lab_leavesCountAggregateOutputType | null
    _avg: Lab_leavesAvgAggregateOutputType | null
    _sum: Lab_leavesSumAggregateOutputType | null
    _min: Lab_leavesMinAggregateOutputType | null
    _max: Lab_leavesMaxAggregateOutputType | null
  }

  type GetLab_leavesGroupByPayload<T extends lab_leavesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_leavesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_leavesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_leavesGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_leavesGroupByOutputType[P]>
        }
      >
    >


  export type lab_leavesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lab_id?: boolean
    dates?: boolean
    start_time?: boolean
    end_time?: boolean
    reason?: boolean
    created_time?: boolean
  }, ExtArgs["result"]["lab_leaves"]>


  export type lab_leavesSelectScalar = {
    id?: boolean
    lab_id?: boolean
    dates?: boolean
    start_time?: boolean
    end_time?: boolean
    reason?: boolean
    created_time?: boolean
  }


  export type $lab_leavesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_leaves"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lab_id: bigint
      dates: string
      start_time: string | null
      end_time: string | null
      reason: string | null
      created_time: string
    }, ExtArgs["result"]["lab_leaves"]>
    composites: {}
  }

  type lab_leavesGetPayload<S extends boolean | null | undefined | lab_leavesDefaultArgs> = $Result.GetResult<Prisma.$lab_leavesPayload, S>

  type lab_leavesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lab_leavesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lab_leavesCountAggregateInputType | true
    }

  export interface lab_leavesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_leaves'], meta: { name: 'lab_leaves' } }
    /**
     * Find zero or one Lab_leaves that matches the filter.
     * @param {lab_leavesFindUniqueArgs} args - Arguments to find a Lab_leaves
     * @example
     * // Get one Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_leavesFindUniqueArgs>(args: SelectSubset<T, lab_leavesFindUniqueArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lab_leaves that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {lab_leavesFindUniqueOrThrowArgs} args - Arguments to find a Lab_leaves
     * @example
     * // Get one Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_leavesFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_leavesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lab_leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesFindFirstArgs} args - Arguments to find a Lab_leaves
     * @example
     * // Get one Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_leavesFindFirstArgs>(args?: SelectSubset<T, lab_leavesFindFirstArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lab_leaves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesFindFirstOrThrowArgs} args - Arguments to find a Lab_leaves
     * @example
     * // Get one Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_leavesFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_leavesFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lab_leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findMany()
     * 
     * // Get first 10 Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_leavesWithIdOnly = await prisma.lab_leaves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_leavesFindManyArgs>(args?: SelectSubset<T, lab_leavesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lab_leaves.
     * @param {lab_leavesCreateArgs} args - Arguments to create a Lab_leaves.
     * @example
     * // Create one Lab_leaves
     * const Lab_leaves = await prisma.lab_leaves.create({
     *   data: {
     *     // ... data to create a Lab_leaves
     *   }
     * })
     * 
     */
    create<T extends lab_leavesCreateArgs>(args: SelectSubset<T, lab_leavesCreateArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lab_leaves.
     * @param {lab_leavesCreateManyArgs} args - Arguments to create many Lab_leaves.
     * @example
     * // Create many Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_leavesCreateManyArgs>(args?: SelectSubset<T, lab_leavesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lab_leaves.
     * @param {lab_leavesDeleteArgs} args - Arguments to delete one Lab_leaves.
     * @example
     * // Delete one Lab_leaves
     * const Lab_leaves = await prisma.lab_leaves.delete({
     *   where: {
     *     // ... filter to delete one Lab_leaves
     *   }
     * })
     * 
     */
    delete<T extends lab_leavesDeleteArgs>(args: SelectSubset<T, lab_leavesDeleteArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lab_leaves.
     * @param {lab_leavesUpdateArgs} args - Arguments to update one Lab_leaves.
     * @example
     * // Update one Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_leavesUpdateArgs>(args: SelectSubset<T, lab_leavesUpdateArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lab_leaves.
     * @param {lab_leavesDeleteManyArgs} args - Arguments to filter Lab_leaves to delete.
     * @example
     * // Delete a few Lab_leaves
     * const { count } = await prisma.lab_leaves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_leavesDeleteManyArgs>(args?: SelectSubset<T, lab_leavesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_leavesUpdateManyArgs>(args: SelectSubset<T, lab_leavesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lab_leaves.
     * @param {lab_leavesUpsertArgs} args - Arguments to update or create a Lab_leaves.
     * @example
     * // Update or create a Lab_leaves
     * const lab_leaves = await prisma.lab_leaves.upsert({
     *   create: {
     *     // ... data to create a Lab_leaves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_leaves we want to update
     *   }
     * })
     */
    upsert<T extends lab_leavesUpsertArgs>(args: SelectSubset<T, lab_leavesUpsertArgs<ExtArgs>>): Prisma__lab_leavesClient<$Result.GetResult<Prisma.$lab_leavesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lab_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesCountArgs} args - Arguments to filter Lab_leaves to count.
     * @example
     * // Count the number of Lab_leaves
     * const count = await prisma.lab_leaves.count({
     *   where: {
     *     // ... the filter for the Lab_leaves we want to count
     *   }
     * })
    **/
    count<T extends lab_leavesCountArgs>(
      args?: Subset<T, lab_leavesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_leavesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_leavesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_leavesAggregateArgs>(args: Subset<T, Lab_leavesAggregateArgs>): Prisma.PrismaPromise<GetLab_leavesAggregateType<T>>

    /**
     * Group by Lab_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_leavesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_leavesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_leavesGroupByArgs['orderBy'] }
        : { orderBy?: lab_leavesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_leavesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_leavesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_leaves model
   */
  readonly fields: lab_leavesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_leaves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_leavesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_leaves model
   */ 
  interface lab_leavesFieldRefs {
    readonly id: FieldRef<"lab_leaves", 'Int'>
    readonly lab_id: FieldRef<"lab_leaves", 'BigInt'>
    readonly dates: FieldRef<"lab_leaves", 'String'>
    readonly start_time: FieldRef<"lab_leaves", 'String'>
    readonly end_time: FieldRef<"lab_leaves", 'String'>
    readonly reason: FieldRef<"lab_leaves", 'String'>
    readonly created_time: FieldRef<"lab_leaves", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lab_leaves findUnique
   */
  export type lab_leavesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter, which lab_leaves to fetch.
     */
    where: lab_leavesWhereUniqueInput
  }

  /**
   * lab_leaves findUniqueOrThrow
   */
  export type lab_leavesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter, which lab_leaves to fetch.
     */
    where: lab_leavesWhereUniqueInput
  }

  /**
   * lab_leaves findFirst
   */
  export type lab_leavesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter, which lab_leaves to fetch.
     */
    where?: lab_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_leaves to fetch.
     */
    orderBy?: lab_leavesOrderByWithRelationInput | lab_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_leaves.
     */
    cursor?: lab_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_leaves.
     */
    distinct?: Lab_leavesScalarFieldEnum | Lab_leavesScalarFieldEnum[]
  }

  /**
   * lab_leaves findFirstOrThrow
   */
  export type lab_leavesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter, which lab_leaves to fetch.
     */
    where?: lab_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_leaves to fetch.
     */
    orderBy?: lab_leavesOrderByWithRelationInput | lab_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_leaves.
     */
    cursor?: lab_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_leaves.
     */
    distinct?: Lab_leavesScalarFieldEnum | Lab_leavesScalarFieldEnum[]
  }

  /**
   * lab_leaves findMany
   */
  export type lab_leavesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter, which lab_leaves to fetch.
     */
    where?: lab_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_leaves to fetch.
     */
    orderBy?: lab_leavesOrderByWithRelationInput | lab_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_leaves.
     */
    cursor?: lab_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_leaves.
     */
    skip?: number
    distinct?: Lab_leavesScalarFieldEnum | Lab_leavesScalarFieldEnum[]
  }

  /**
   * lab_leaves create
   */
  export type lab_leavesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * The data needed to create a lab_leaves.
     */
    data: XOR<lab_leavesCreateInput, lab_leavesUncheckedCreateInput>
  }

  /**
   * lab_leaves createMany
   */
  export type lab_leavesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_leaves.
     */
    data: lab_leavesCreateManyInput | lab_leavesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_leaves update
   */
  export type lab_leavesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * The data needed to update a lab_leaves.
     */
    data: XOR<lab_leavesUpdateInput, lab_leavesUncheckedUpdateInput>
    /**
     * Choose, which lab_leaves to update.
     */
    where: lab_leavesWhereUniqueInput
  }

  /**
   * lab_leaves updateMany
   */
  export type lab_leavesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_leaves.
     */
    data: XOR<lab_leavesUpdateManyMutationInput, lab_leavesUncheckedUpdateManyInput>
    /**
     * Filter which lab_leaves to update
     */
    where?: lab_leavesWhereInput
  }

  /**
   * lab_leaves upsert
   */
  export type lab_leavesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * The filter to search for the lab_leaves to update in case it exists.
     */
    where: lab_leavesWhereUniqueInput
    /**
     * In case the lab_leaves found by the `where` argument doesn't exist, create a new lab_leaves with this data.
     */
    create: XOR<lab_leavesCreateInput, lab_leavesUncheckedCreateInput>
    /**
     * In case the lab_leaves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_leavesUpdateInput, lab_leavesUncheckedUpdateInput>
  }

  /**
   * lab_leaves delete
   */
  export type lab_leavesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
    /**
     * Filter which lab_leaves to delete.
     */
    where: lab_leavesWhereUniqueInput
  }

  /**
   * lab_leaves deleteMany
   */
  export type lab_leavesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_leaves to delete
     */
    where?: lab_leavesWhereInput
  }

  /**
   * lab_leaves without action
   */
  export type lab_leavesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_leaves
     */
    select?: lab_leavesSelect<ExtArgs> | null
  }


  /**
   * Model lab_tests_price_updates
   */

  export type AggregateLab_tests_price_updates = {
    _count: Lab_tests_price_updatesCountAggregateOutputType | null
    _avg: Lab_tests_price_updatesAvgAggregateOutputType | null
    _sum: Lab_tests_price_updatesSumAggregateOutputType | null
    _min: Lab_tests_price_updatesMinAggregateOutputType | null
    _max: Lab_tests_price_updatesMaxAggregateOutputType | null
  }

  export type Lab_tests_price_updatesAvgAggregateOutputType = {
    id: number | null
  }

  export type Lab_tests_price_updatesSumAggregateOutputType = {
    id: number | null
  }

  export type Lab_tests_price_updatesMinAggregateOutputType = {
    id: number | null
    lab_id: string | null
    test_id: string | null
    price: string | null
    unit: string | null
    reference_range: string | null
    created_date: string | null
    created_by: string | null
    created_by_phone_num: string | null
  }

  export type Lab_tests_price_updatesMaxAggregateOutputType = {
    id: number | null
    lab_id: string | null
    test_id: string | null
    price: string | null
    unit: string | null
    reference_range: string | null
    created_date: string | null
    created_by: string | null
    created_by_phone_num: string | null
  }

  export type Lab_tests_price_updatesCountAggregateOutputType = {
    id: number
    lab_id: number
    test_id: number
    price: number
    unit: number
    reference_range: number
    created_date: number
    created_by: number
    created_by_phone_num: number
    _all: number
  }


  export type Lab_tests_price_updatesAvgAggregateInputType = {
    id?: true
  }

  export type Lab_tests_price_updatesSumAggregateInputType = {
    id?: true
  }

  export type Lab_tests_price_updatesMinAggregateInputType = {
    id?: true
    lab_id?: true
    test_id?: true
    price?: true
    unit?: true
    reference_range?: true
    created_date?: true
    created_by?: true
    created_by_phone_num?: true
  }

  export type Lab_tests_price_updatesMaxAggregateInputType = {
    id?: true
    lab_id?: true
    test_id?: true
    price?: true
    unit?: true
    reference_range?: true
    created_date?: true
    created_by?: true
    created_by_phone_num?: true
  }

  export type Lab_tests_price_updatesCountAggregateInputType = {
    id?: true
    lab_id?: true
    test_id?: true
    price?: true
    unit?: true
    reference_range?: true
    created_date?: true
    created_by?: true
    created_by_phone_num?: true
    _all?: true
  }

  export type Lab_tests_price_updatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_tests_price_updates to aggregate.
     */
    where?: lab_tests_price_updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests_price_updates to fetch.
     */
    orderBy?: lab_tests_price_updatesOrderByWithRelationInput | lab_tests_price_updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_tests_price_updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests_price_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests_price_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_tests_price_updates
    **/
    _count?: true | Lab_tests_price_updatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lab_tests_price_updatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lab_tests_price_updatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_tests_price_updatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_tests_price_updatesMaxAggregateInputType
  }

  export type GetLab_tests_price_updatesAggregateType<T extends Lab_tests_price_updatesAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_tests_price_updates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_tests_price_updates[P]>
      : GetScalarType<T[P], AggregateLab_tests_price_updates[P]>
  }




  export type lab_tests_price_updatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_tests_price_updatesWhereInput
    orderBy?: lab_tests_price_updatesOrderByWithAggregationInput | lab_tests_price_updatesOrderByWithAggregationInput[]
    by: Lab_tests_price_updatesScalarFieldEnum[] | Lab_tests_price_updatesScalarFieldEnum
    having?: lab_tests_price_updatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_tests_price_updatesCountAggregateInputType | true
    _avg?: Lab_tests_price_updatesAvgAggregateInputType
    _sum?: Lab_tests_price_updatesSumAggregateInputType
    _min?: Lab_tests_price_updatesMinAggregateInputType
    _max?: Lab_tests_price_updatesMaxAggregateInputType
  }

  export type Lab_tests_price_updatesGroupByOutputType = {
    id: number
    lab_id: string | null
    test_id: string | null
    price: string | null
    unit: string | null
    reference_range: string | null
    created_date: string | null
    created_by: string | null
    created_by_phone_num: string | null
    _count: Lab_tests_price_updatesCountAggregateOutputType | null
    _avg: Lab_tests_price_updatesAvgAggregateOutputType | null
    _sum: Lab_tests_price_updatesSumAggregateOutputType | null
    _min: Lab_tests_price_updatesMinAggregateOutputType | null
    _max: Lab_tests_price_updatesMaxAggregateOutputType | null
  }

  type GetLab_tests_price_updatesGroupByPayload<T extends lab_tests_price_updatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_tests_price_updatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_tests_price_updatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_tests_price_updatesGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_tests_price_updatesGroupByOutputType[P]>
        }
      >
    >


  export type lab_tests_price_updatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lab_id?: boolean
    test_id?: boolean
    price?: boolean
    unit?: boolean
    reference_range?: boolean
    created_date?: boolean
    created_by?: boolean
    created_by_phone_num?: boolean
  }, ExtArgs["result"]["lab_tests_price_updates"]>


  export type lab_tests_price_updatesSelectScalar = {
    id?: boolean
    lab_id?: boolean
    test_id?: boolean
    price?: boolean
    unit?: boolean
    reference_range?: boolean
    created_date?: boolean
    created_by?: boolean
    created_by_phone_num?: boolean
  }


  export type $lab_tests_price_updatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_tests_price_updates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lab_id: string | null
      test_id: string | null
      price: string | null
      unit: string | null
      reference_range: string | null
      created_date: string | null
      created_by: string | null
      created_by_phone_num: string | null
    }, ExtArgs["result"]["lab_tests_price_updates"]>
    composites: {}
  }

  type lab_tests_price_updatesGetPayload<S extends boolean | null | undefined | lab_tests_price_updatesDefaultArgs> = $Result.GetResult<Prisma.$lab_tests_price_updatesPayload, S>

  type lab_tests_price_updatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lab_tests_price_updatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lab_tests_price_updatesCountAggregateInputType | true
    }

  export interface lab_tests_price_updatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_tests_price_updates'], meta: { name: 'lab_tests_price_updates' } }
    /**
     * Find zero or one Lab_tests_price_updates that matches the filter.
     * @param {lab_tests_price_updatesFindUniqueArgs} args - Arguments to find a Lab_tests_price_updates
     * @example
     * // Get one Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_tests_price_updatesFindUniqueArgs>(args: SelectSubset<T, lab_tests_price_updatesFindUniqueArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lab_tests_price_updates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {lab_tests_price_updatesFindUniqueOrThrowArgs} args - Arguments to find a Lab_tests_price_updates
     * @example
     * // Get one Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_tests_price_updatesFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_tests_price_updatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lab_tests_price_updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesFindFirstArgs} args - Arguments to find a Lab_tests_price_updates
     * @example
     * // Get one Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_tests_price_updatesFindFirstArgs>(args?: SelectSubset<T, lab_tests_price_updatesFindFirstArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lab_tests_price_updates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesFindFirstOrThrowArgs} args - Arguments to find a Lab_tests_price_updates
     * @example
     * // Get one Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_tests_price_updatesFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_tests_price_updatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lab_tests_price_updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findMany()
     * 
     * // Get first 10 Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_tests_price_updatesWithIdOnly = await prisma.lab_tests_price_updates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_tests_price_updatesFindManyArgs>(args?: SelectSubset<T, lab_tests_price_updatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lab_tests_price_updates.
     * @param {lab_tests_price_updatesCreateArgs} args - Arguments to create a Lab_tests_price_updates.
     * @example
     * // Create one Lab_tests_price_updates
     * const Lab_tests_price_updates = await prisma.lab_tests_price_updates.create({
     *   data: {
     *     // ... data to create a Lab_tests_price_updates
     *   }
     * })
     * 
     */
    create<T extends lab_tests_price_updatesCreateArgs>(args: SelectSubset<T, lab_tests_price_updatesCreateArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lab_tests_price_updates.
     * @param {lab_tests_price_updatesCreateManyArgs} args - Arguments to create many Lab_tests_price_updates.
     * @example
     * // Create many Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_tests_price_updatesCreateManyArgs>(args?: SelectSubset<T, lab_tests_price_updatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lab_tests_price_updates.
     * @param {lab_tests_price_updatesDeleteArgs} args - Arguments to delete one Lab_tests_price_updates.
     * @example
     * // Delete one Lab_tests_price_updates
     * const Lab_tests_price_updates = await prisma.lab_tests_price_updates.delete({
     *   where: {
     *     // ... filter to delete one Lab_tests_price_updates
     *   }
     * })
     * 
     */
    delete<T extends lab_tests_price_updatesDeleteArgs>(args: SelectSubset<T, lab_tests_price_updatesDeleteArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lab_tests_price_updates.
     * @param {lab_tests_price_updatesUpdateArgs} args - Arguments to update one Lab_tests_price_updates.
     * @example
     * // Update one Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_tests_price_updatesUpdateArgs>(args: SelectSubset<T, lab_tests_price_updatesUpdateArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lab_tests_price_updates.
     * @param {lab_tests_price_updatesDeleteManyArgs} args - Arguments to filter Lab_tests_price_updates to delete.
     * @example
     * // Delete a few Lab_tests_price_updates
     * const { count } = await prisma.lab_tests_price_updates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_tests_price_updatesDeleteManyArgs>(args?: SelectSubset<T, lab_tests_price_updatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_tests_price_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_tests_price_updatesUpdateManyArgs>(args: SelectSubset<T, lab_tests_price_updatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lab_tests_price_updates.
     * @param {lab_tests_price_updatesUpsertArgs} args - Arguments to update or create a Lab_tests_price_updates.
     * @example
     * // Update or create a Lab_tests_price_updates
     * const lab_tests_price_updates = await prisma.lab_tests_price_updates.upsert({
     *   create: {
     *     // ... data to create a Lab_tests_price_updates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_tests_price_updates we want to update
     *   }
     * })
     */
    upsert<T extends lab_tests_price_updatesUpsertArgs>(args: SelectSubset<T, lab_tests_price_updatesUpsertArgs<ExtArgs>>): Prisma__lab_tests_price_updatesClient<$Result.GetResult<Prisma.$lab_tests_price_updatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lab_tests_price_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesCountArgs} args - Arguments to filter Lab_tests_price_updates to count.
     * @example
     * // Count the number of Lab_tests_price_updates
     * const count = await prisma.lab_tests_price_updates.count({
     *   where: {
     *     // ... the filter for the Lab_tests_price_updates we want to count
     *   }
     * })
    **/
    count<T extends lab_tests_price_updatesCountArgs>(
      args?: Subset<T, lab_tests_price_updatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_tests_price_updatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_tests_price_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_tests_price_updatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_tests_price_updatesAggregateArgs>(args: Subset<T, Lab_tests_price_updatesAggregateArgs>): Prisma.PrismaPromise<GetLab_tests_price_updatesAggregateType<T>>

    /**
     * Group by Lab_tests_price_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_tests_price_updatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_tests_price_updatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_tests_price_updatesGroupByArgs['orderBy'] }
        : { orderBy?: lab_tests_price_updatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_tests_price_updatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_tests_price_updatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_tests_price_updates model
   */
  readonly fields: lab_tests_price_updatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_tests_price_updates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_tests_price_updatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_tests_price_updates model
   */ 
  interface lab_tests_price_updatesFieldRefs {
    readonly id: FieldRef<"lab_tests_price_updates", 'Int'>
    readonly lab_id: FieldRef<"lab_tests_price_updates", 'String'>
    readonly test_id: FieldRef<"lab_tests_price_updates", 'String'>
    readonly price: FieldRef<"lab_tests_price_updates", 'String'>
    readonly unit: FieldRef<"lab_tests_price_updates", 'String'>
    readonly reference_range: FieldRef<"lab_tests_price_updates", 'String'>
    readonly created_date: FieldRef<"lab_tests_price_updates", 'String'>
    readonly created_by: FieldRef<"lab_tests_price_updates", 'String'>
    readonly created_by_phone_num: FieldRef<"lab_tests_price_updates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lab_tests_price_updates findUnique
   */
  export type lab_tests_price_updatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter, which lab_tests_price_updates to fetch.
     */
    where: lab_tests_price_updatesWhereUniqueInput
  }

  /**
   * lab_tests_price_updates findUniqueOrThrow
   */
  export type lab_tests_price_updatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter, which lab_tests_price_updates to fetch.
     */
    where: lab_tests_price_updatesWhereUniqueInput
  }

  /**
   * lab_tests_price_updates findFirst
   */
  export type lab_tests_price_updatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter, which lab_tests_price_updates to fetch.
     */
    where?: lab_tests_price_updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests_price_updates to fetch.
     */
    orderBy?: lab_tests_price_updatesOrderByWithRelationInput | lab_tests_price_updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_tests_price_updates.
     */
    cursor?: lab_tests_price_updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests_price_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests_price_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_tests_price_updates.
     */
    distinct?: Lab_tests_price_updatesScalarFieldEnum | Lab_tests_price_updatesScalarFieldEnum[]
  }

  /**
   * lab_tests_price_updates findFirstOrThrow
   */
  export type lab_tests_price_updatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter, which lab_tests_price_updates to fetch.
     */
    where?: lab_tests_price_updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests_price_updates to fetch.
     */
    orderBy?: lab_tests_price_updatesOrderByWithRelationInput | lab_tests_price_updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_tests_price_updates.
     */
    cursor?: lab_tests_price_updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests_price_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests_price_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_tests_price_updates.
     */
    distinct?: Lab_tests_price_updatesScalarFieldEnum | Lab_tests_price_updatesScalarFieldEnum[]
  }

  /**
   * lab_tests_price_updates findMany
   */
  export type lab_tests_price_updatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter, which lab_tests_price_updates to fetch.
     */
    where?: lab_tests_price_updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests_price_updates to fetch.
     */
    orderBy?: lab_tests_price_updatesOrderByWithRelationInput | lab_tests_price_updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_tests_price_updates.
     */
    cursor?: lab_tests_price_updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests_price_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests_price_updates.
     */
    skip?: number
    distinct?: Lab_tests_price_updatesScalarFieldEnum | Lab_tests_price_updatesScalarFieldEnum[]
  }

  /**
   * lab_tests_price_updates create
   */
  export type lab_tests_price_updatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * The data needed to create a lab_tests_price_updates.
     */
    data?: XOR<lab_tests_price_updatesCreateInput, lab_tests_price_updatesUncheckedCreateInput>
  }

  /**
   * lab_tests_price_updates createMany
   */
  export type lab_tests_price_updatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_tests_price_updates.
     */
    data: lab_tests_price_updatesCreateManyInput | lab_tests_price_updatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_tests_price_updates update
   */
  export type lab_tests_price_updatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * The data needed to update a lab_tests_price_updates.
     */
    data: XOR<lab_tests_price_updatesUpdateInput, lab_tests_price_updatesUncheckedUpdateInput>
    /**
     * Choose, which lab_tests_price_updates to update.
     */
    where: lab_tests_price_updatesWhereUniqueInput
  }

  /**
   * lab_tests_price_updates updateMany
   */
  export type lab_tests_price_updatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_tests_price_updates.
     */
    data: XOR<lab_tests_price_updatesUpdateManyMutationInput, lab_tests_price_updatesUncheckedUpdateManyInput>
    /**
     * Filter which lab_tests_price_updates to update
     */
    where?: lab_tests_price_updatesWhereInput
  }

  /**
   * lab_tests_price_updates upsert
   */
  export type lab_tests_price_updatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * The filter to search for the lab_tests_price_updates to update in case it exists.
     */
    where: lab_tests_price_updatesWhereUniqueInput
    /**
     * In case the lab_tests_price_updates found by the `where` argument doesn't exist, create a new lab_tests_price_updates with this data.
     */
    create: XOR<lab_tests_price_updatesCreateInput, lab_tests_price_updatesUncheckedCreateInput>
    /**
     * In case the lab_tests_price_updates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_tests_price_updatesUpdateInput, lab_tests_price_updatesUncheckedUpdateInput>
  }

  /**
   * lab_tests_price_updates delete
   */
  export type lab_tests_price_updatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
    /**
     * Filter which lab_tests_price_updates to delete.
     */
    where: lab_tests_price_updatesWhereUniqueInput
  }

  /**
   * lab_tests_price_updates deleteMany
   */
  export type lab_tests_price_updatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_tests_price_updates to delete
     */
    where?: lab_tests_price_updatesWhereInput
  }

  /**
   * lab_tests_price_updates without action
   */
  export type lab_tests_price_updatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests_price_updates
     */
    select?: lab_tests_price_updatesSelect<ExtArgs> | null
  }


  /**
   * Model lab_timings
   */

  export type AggregateLab_timings = {
    _count: Lab_timingsCountAggregateOutputType | null
    _avg: Lab_timingsAvgAggregateOutputType | null
    _sum: Lab_timingsSumAggregateOutputType | null
    _min: Lab_timingsMinAggregateOutputType | null
    _max: Lab_timingsMaxAggregateOutputType | null
  }

  export type Lab_timingsAvgAggregateOutputType = {
    id: number | null
    lab_id: number | null
  }

  export type Lab_timingsSumAggregateOutputType = {
    id: number | null
    lab_id: number | null
  }

  export type Lab_timingsMinAggregateOutputType = {
    id: number | null
    lab_id: number | null
    theday: string | null
    work_type: $Enums.lab_timings_work_type | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Lab_timingsMaxAggregateOutputType = {
    id: number | null
    lab_id: number | null
    theday: string | null
    work_type: $Enums.lab_timings_work_type | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Lab_timingsCountAggregateOutputType = {
    id: number
    lab_id: number
    theday: number
    work_type: number
    start_time: number
    end_time: number
    created_time: number
    updated_time: number
    _all: number
  }


  export type Lab_timingsAvgAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type Lab_timingsSumAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type Lab_timingsMinAggregateInputType = {
    id?: true
    lab_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Lab_timingsMaxAggregateInputType = {
    id?: true
    lab_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Lab_timingsCountAggregateInputType = {
    id?: true
    lab_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
    _all?: true
  }

  export type Lab_timingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_timings to aggregate.
     */
    where?: lab_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_timings to fetch.
     */
    orderBy?: lab_timingsOrderByWithRelationInput | lab_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_timings
    **/
    _count?: true | Lab_timingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lab_timingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lab_timingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_timingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_timingsMaxAggregateInputType
  }

  export type GetLab_timingsAggregateType<T extends Lab_timingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_timings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_timings[P]>
      : GetScalarType<T[P], AggregateLab_timings[P]>
  }




  export type lab_timingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_timingsWhereInput
    orderBy?: lab_timingsOrderByWithAggregationInput | lab_timingsOrderByWithAggregationInput[]
    by: Lab_timingsScalarFieldEnum[] | Lab_timingsScalarFieldEnum
    having?: lab_timingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_timingsCountAggregateInputType | true
    _avg?: Lab_timingsAvgAggregateInputType
    _sum?: Lab_timingsSumAggregateInputType
    _min?: Lab_timingsMinAggregateInputType
    _max?: Lab_timingsMaxAggregateInputType
  }

  export type Lab_timingsGroupByOutputType = {
    id: number
    lab_id: number
    theday: string
    work_type: $Enums.lab_timings_work_type
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
    _count: Lab_timingsCountAggregateOutputType | null
    _avg: Lab_timingsAvgAggregateOutputType | null
    _sum: Lab_timingsSumAggregateOutputType | null
    _min: Lab_timingsMinAggregateOutputType | null
    _max: Lab_timingsMaxAggregateOutputType | null
  }

  type GetLab_timingsGroupByPayload<T extends lab_timingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_timingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_timingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_timingsGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_timingsGroupByOutputType[P]>
        }
      >
    >


  export type lab_timingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lab_id?: boolean
    theday?: boolean
    work_type?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }, ExtArgs["result"]["lab_timings"]>


  export type lab_timingsSelectScalar = {
    id?: boolean
    lab_id?: boolean
    theday?: boolean
    work_type?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }


  export type $lab_timingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_timings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lab_id: number
      theday: string
      work_type: $Enums.lab_timings_work_type
      start_time: string | null
      end_time: string | null
      created_time: string | null
      updated_time: string | null
    }, ExtArgs["result"]["lab_timings"]>
    composites: {}
  }

  type lab_timingsGetPayload<S extends boolean | null | undefined | lab_timingsDefaultArgs> = $Result.GetResult<Prisma.$lab_timingsPayload, S>

  type lab_timingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lab_timingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lab_timingsCountAggregateInputType | true
    }

  export interface lab_timingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_timings'], meta: { name: 'lab_timings' } }
    /**
     * Find zero or one Lab_timings that matches the filter.
     * @param {lab_timingsFindUniqueArgs} args - Arguments to find a Lab_timings
     * @example
     * // Get one Lab_timings
     * const lab_timings = await prisma.lab_timings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_timingsFindUniqueArgs>(args: SelectSubset<T, lab_timingsFindUniqueArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lab_timings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {lab_timingsFindUniqueOrThrowArgs} args - Arguments to find a Lab_timings
     * @example
     * // Get one Lab_timings
     * const lab_timings = await prisma.lab_timings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_timingsFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_timingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lab_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsFindFirstArgs} args - Arguments to find a Lab_timings
     * @example
     * // Get one Lab_timings
     * const lab_timings = await prisma.lab_timings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_timingsFindFirstArgs>(args?: SelectSubset<T, lab_timingsFindFirstArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lab_timings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsFindFirstOrThrowArgs} args - Arguments to find a Lab_timings
     * @example
     * // Get one Lab_timings
     * const lab_timings = await prisma.lab_timings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_timingsFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_timingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lab_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_timings
     * const lab_timings = await prisma.lab_timings.findMany()
     * 
     * // Get first 10 Lab_timings
     * const lab_timings = await prisma.lab_timings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_timingsWithIdOnly = await prisma.lab_timings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_timingsFindManyArgs>(args?: SelectSubset<T, lab_timingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lab_timings.
     * @param {lab_timingsCreateArgs} args - Arguments to create a Lab_timings.
     * @example
     * // Create one Lab_timings
     * const Lab_timings = await prisma.lab_timings.create({
     *   data: {
     *     // ... data to create a Lab_timings
     *   }
     * })
     * 
     */
    create<T extends lab_timingsCreateArgs>(args: SelectSubset<T, lab_timingsCreateArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lab_timings.
     * @param {lab_timingsCreateManyArgs} args - Arguments to create many Lab_timings.
     * @example
     * // Create many Lab_timings
     * const lab_timings = await prisma.lab_timings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_timingsCreateManyArgs>(args?: SelectSubset<T, lab_timingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lab_timings.
     * @param {lab_timingsDeleteArgs} args - Arguments to delete one Lab_timings.
     * @example
     * // Delete one Lab_timings
     * const Lab_timings = await prisma.lab_timings.delete({
     *   where: {
     *     // ... filter to delete one Lab_timings
     *   }
     * })
     * 
     */
    delete<T extends lab_timingsDeleteArgs>(args: SelectSubset<T, lab_timingsDeleteArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lab_timings.
     * @param {lab_timingsUpdateArgs} args - Arguments to update one Lab_timings.
     * @example
     * // Update one Lab_timings
     * const lab_timings = await prisma.lab_timings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_timingsUpdateArgs>(args: SelectSubset<T, lab_timingsUpdateArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lab_timings.
     * @param {lab_timingsDeleteManyArgs} args - Arguments to filter Lab_timings to delete.
     * @example
     * // Delete a few Lab_timings
     * const { count } = await prisma.lab_timings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_timingsDeleteManyArgs>(args?: SelectSubset<T, lab_timingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_timings
     * const lab_timings = await prisma.lab_timings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_timingsUpdateManyArgs>(args: SelectSubset<T, lab_timingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lab_timings.
     * @param {lab_timingsUpsertArgs} args - Arguments to update or create a Lab_timings.
     * @example
     * // Update or create a Lab_timings
     * const lab_timings = await prisma.lab_timings.upsert({
     *   create: {
     *     // ... data to create a Lab_timings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_timings we want to update
     *   }
     * })
     */
    upsert<T extends lab_timingsUpsertArgs>(args: SelectSubset<T, lab_timingsUpsertArgs<ExtArgs>>): Prisma__lab_timingsClient<$Result.GetResult<Prisma.$lab_timingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lab_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsCountArgs} args - Arguments to filter Lab_timings to count.
     * @example
     * // Count the number of Lab_timings
     * const count = await prisma.lab_timings.count({
     *   where: {
     *     // ... the filter for the Lab_timings we want to count
     *   }
     * })
    **/
    count<T extends lab_timingsCountArgs>(
      args?: Subset<T, lab_timingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_timingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_timingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_timingsAggregateArgs>(args: Subset<T, Lab_timingsAggregateArgs>): Prisma.PrismaPromise<GetLab_timingsAggregateType<T>>

    /**
     * Group by Lab_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_timingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_timingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_timingsGroupByArgs['orderBy'] }
        : { orderBy?: lab_timingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_timingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_timingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_timings model
   */
  readonly fields: lab_timingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_timings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_timingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_timings model
   */ 
  interface lab_timingsFieldRefs {
    readonly id: FieldRef<"lab_timings", 'Int'>
    readonly lab_id: FieldRef<"lab_timings", 'Int'>
    readonly theday: FieldRef<"lab_timings", 'String'>
    readonly work_type: FieldRef<"lab_timings", 'lab_timings_work_type'>
    readonly start_time: FieldRef<"lab_timings", 'String'>
    readonly end_time: FieldRef<"lab_timings", 'String'>
    readonly created_time: FieldRef<"lab_timings", 'String'>
    readonly updated_time: FieldRef<"lab_timings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lab_timings findUnique
   */
  export type lab_timingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter, which lab_timings to fetch.
     */
    where: lab_timingsWhereUniqueInput
  }

  /**
   * lab_timings findUniqueOrThrow
   */
  export type lab_timingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter, which lab_timings to fetch.
     */
    where: lab_timingsWhereUniqueInput
  }

  /**
   * lab_timings findFirst
   */
  export type lab_timingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter, which lab_timings to fetch.
     */
    where?: lab_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_timings to fetch.
     */
    orderBy?: lab_timingsOrderByWithRelationInput | lab_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_timings.
     */
    cursor?: lab_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_timings.
     */
    distinct?: Lab_timingsScalarFieldEnum | Lab_timingsScalarFieldEnum[]
  }

  /**
   * lab_timings findFirstOrThrow
   */
  export type lab_timingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter, which lab_timings to fetch.
     */
    where?: lab_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_timings to fetch.
     */
    orderBy?: lab_timingsOrderByWithRelationInput | lab_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_timings.
     */
    cursor?: lab_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_timings.
     */
    distinct?: Lab_timingsScalarFieldEnum | Lab_timingsScalarFieldEnum[]
  }

  /**
   * lab_timings findMany
   */
  export type lab_timingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter, which lab_timings to fetch.
     */
    where?: lab_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_timings to fetch.
     */
    orderBy?: lab_timingsOrderByWithRelationInput | lab_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_timings.
     */
    cursor?: lab_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_timings.
     */
    skip?: number
    distinct?: Lab_timingsScalarFieldEnum | Lab_timingsScalarFieldEnum[]
  }

  /**
   * lab_timings create
   */
  export type lab_timingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * The data needed to create a lab_timings.
     */
    data: XOR<lab_timingsCreateInput, lab_timingsUncheckedCreateInput>
  }

  /**
   * lab_timings createMany
   */
  export type lab_timingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_timings.
     */
    data: lab_timingsCreateManyInput | lab_timingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_timings update
   */
  export type lab_timingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * The data needed to update a lab_timings.
     */
    data: XOR<lab_timingsUpdateInput, lab_timingsUncheckedUpdateInput>
    /**
     * Choose, which lab_timings to update.
     */
    where: lab_timingsWhereUniqueInput
  }

  /**
   * lab_timings updateMany
   */
  export type lab_timingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_timings.
     */
    data: XOR<lab_timingsUpdateManyMutationInput, lab_timingsUncheckedUpdateManyInput>
    /**
     * Filter which lab_timings to update
     */
    where?: lab_timingsWhereInput
  }

  /**
   * lab_timings upsert
   */
  export type lab_timingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * The filter to search for the lab_timings to update in case it exists.
     */
    where: lab_timingsWhereUniqueInput
    /**
     * In case the lab_timings found by the `where` argument doesn't exist, create a new lab_timings with this data.
     */
    create: XOR<lab_timingsCreateInput, lab_timingsUncheckedCreateInput>
    /**
     * In case the lab_timings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_timingsUpdateInput, lab_timingsUncheckedUpdateInput>
  }

  /**
   * lab_timings delete
   */
  export type lab_timingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
    /**
     * Filter which lab_timings to delete.
     */
    where: lab_timingsWhereUniqueInput
  }

  /**
   * lab_timings deleteMany
   */
  export type lab_timingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_timings to delete
     */
    where?: lab_timingsWhereInput
  }

  /**
   * lab_timings without action
   */
  export type lab_timingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_timings
     */
    select?: lab_timingsSelect<ExtArgs> | null
  }


  /**
   * Model laboratory_details
   */

  export type AggregateLaboratory_details = {
    _count: Laboratory_detailsCountAggregateOutputType | null
    _avg: Laboratory_detailsAvgAggregateOutputType | null
    _sum: Laboratory_detailsSumAggregateOutputType | null
    _min: Laboratory_detailsMinAggregateOutputType | null
    _max: Laboratory_detailsMaxAggregateOutputType | null
  }

  export type Laboratory_detailsAvgAggregateOutputType = {
    laboratory_id: number | null
    active: number | null
    role_id: number | null
  }

  export type Laboratory_detailsSumAggregateOutputType = {
    laboratory_id: number | null
    active: number | null
    role_id: number | null
  }

  export type Laboratory_detailsMinAggregateOutputType = {
    laboratory_id: number | null
    laboratory_name: string | null
    laboratory_address: string | null
    locality: string | null
    laboratory_phone: string | null
    laboratory_email: string | null
    laboratory_password: string | null
    lab_state: string | null
    lab_city: string | null
    lab_pincode: string | null
    created_on: Date | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    profile_filename: string | null
    profile_fullpath: string | null
  }

  export type Laboratory_detailsMaxAggregateOutputType = {
    laboratory_id: number | null
    laboratory_name: string | null
    laboratory_address: string | null
    locality: string | null
    laboratory_phone: string | null
    laboratory_email: string | null
    laboratory_password: string | null
    lab_state: string | null
    lab_city: string | null
    lab_pincode: string | null
    created_on: Date | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    profile_filename: string | null
    profile_fullpath: string | null
  }

  export type Laboratory_detailsCountAggregateOutputType = {
    laboratory_id: number
    laboratory_name: number
    laboratory_address: number
    locality: number
    laboratory_phone: number
    laboratory_email: number
    laboratory_password: number
    lab_state: number
    lab_city: number
    lab_pincode: number
    created_on: number
    updated_on: number
    active: number
    role_id: number
    profile_filename: number
    profile_fullpath: number
    _all: number
  }


  export type Laboratory_detailsAvgAggregateInputType = {
    laboratory_id?: true
    active?: true
    role_id?: true
  }

  export type Laboratory_detailsSumAggregateInputType = {
    laboratory_id?: true
    active?: true
    role_id?: true
  }

  export type Laboratory_detailsMinAggregateInputType = {
    laboratory_id?: true
    laboratory_name?: true
    laboratory_address?: true
    locality?: true
    laboratory_phone?: true
    laboratory_email?: true
    laboratory_password?: true
    lab_state?: true
    lab_city?: true
    lab_pincode?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
  }

  export type Laboratory_detailsMaxAggregateInputType = {
    laboratory_id?: true
    laboratory_name?: true
    laboratory_address?: true
    locality?: true
    laboratory_phone?: true
    laboratory_email?: true
    laboratory_password?: true
    lab_state?: true
    lab_city?: true
    lab_pincode?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
  }

  export type Laboratory_detailsCountAggregateInputType = {
    laboratory_id?: true
    laboratory_name?: true
    laboratory_address?: true
    locality?: true
    laboratory_phone?: true
    laboratory_email?: true
    laboratory_password?: true
    lab_state?: true
    lab_city?: true
    lab_pincode?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
    _all?: true
  }

  export type Laboratory_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_details to aggregate.
     */
    where?: laboratory_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_details to fetch.
     */
    orderBy?: laboratory_detailsOrderByWithRelationInput | laboratory_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: laboratory_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned laboratory_details
    **/
    _count?: true | Laboratory_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Laboratory_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Laboratory_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Laboratory_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Laboratory_detailsMaxAggregateInputType
  }

  export type GetLaboratory_detailsAggregateType<T extends Laboratory_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateLaboratory_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaboratory_details[P]>
      : GetScalarType<T[P], AggregateLaboratory_details[P]>
  }




  export type laboratory_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: laboratory_detailsWhereInput
    orderBy?: laboratory_detailsOrderByWithAggregationInput | laboratory_detailsOrderByWithAggregationInput[]
    by: Laboratory_detailsScalarFieldEnum[] | Laboratory_detailsScalarFieldEnum
    having?: laboratory_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Laboratory_detailsCountAggregateInputType | true
    _avg?: Laboratory_detailsAvgAggregateInputType
    _sum?: Laboratory_detailsSumAggregateInputType
    _min?: Laboratory_detailsMinAggregateInputType
    _max?: Laboratory_detailsMaxAggregateInputType
  }

  export type Laboratory_detailsGroupByOutputType = {
    laboratory_id: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date
    updated_on: Date
    active: number
    role_id: number
    profile_filename: string
    profile_fullpath: string
    _count: Laboratory_detailsCountAggregateOutputType | null
    _avg: Laboratory_detailsAvgAggregateOutputType | null
    _sum: Laboratory_detailsSumAggregateOutputType | null
    _min: Laboratory_detailsMinAggregateOutputType | null
    _max: Laboratory_detailsMaxAggregateOutputType | null
  }

  type GetLaboratory_detailsGroupByPayload<T extends laboratory_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Laboratory_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Laboratory_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Laboratory_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Laboratory_detailsGroupByOutputType[P]>
        }
      >
    >


  export type laboratory_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    laboratory_id?: boolean
    laboratory_name?: boolean
    laboratory_address?: boolean
    locality?: boolean
    laboratory_phone?: boolean
    laboratory_email?: boolean
    laboratory_password?: boolean
    lab_state?: boolean
    lab_city?: boolean
    lab_pincode?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
    laboratory_test_details?: boolean | laboratory_details$laboratory_test_detailsArgs<ExtArgs>
    _count?: boolean | Laboratory_detailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laboratory_details"]>


  export type laboratory_detailsSelectScalar = {
    laboratory_id?: boolean
    laboratory_name?: boolean
    laboratory_address?: boolean
    locality?: boolean
    laboratory_phone?: boolean
    laboratory_email?: boolean
    laboratory_password?: boolean
    lab_state?: boolean
    lab_city?: boolean
    lab_pincode?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
  }

  export type laboratory_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laboratory_test_details?: boolean | laboratory_details$laboratory_test_detailsArgs<ExtArgs>
    _count?: boolean | Laboratory_detailsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $laboratory_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "laboratory_details"
    objects: {
      laboratory_test_details: Prisma.$laboratory_test_detailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      laboratory_id: number
      laboratory_name: string
      laboratory_address: string
      locality: string
      laboratory_phone: string
      laboratory_email: string
      laboratory_password: string
      lab_state: string
      lab_city: string
      lab_pincode: string
      created_on: Date
      updated_on: Date
      active: number
      role_id: number
      profile_filename: string
      profile_fullpath: string
    }, ExtArgs["result"]["laboratory_details"]>
    composites: {}
  }

  type laboratory_detailsGetPayload<S extends boolean | null | undefined | laboratory_detailsDefaultArgs> = $Result.GetResult<Prisma.$laboratory_detailsPayload, S>

  type laboratory_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<laboratory_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Laboratory_detailsCountAggregateInputType | true
    }

  export interface laboratory_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['laboratory_details'], meta: { name: 'laboratory_details' } }
    /**
     * Find zero or one Laboratory_details that matches the filter.
     * @param {laboratory_detailsFindUniqueArgs} args - Arguments to find a Laboratory_details
     * @example
     * // Get one Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends laboratory_detailsFindUniqueArgs>(args: SelectSubset<T, laboratory_detailsFindUniqueArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Laboratory_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {laboratory_detailsFindUniqueOrThrowArgs} args - Arguments to find a Laboratory_details
     * @example
     * // Get one Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends laboratory_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, laboratory_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Laboratory_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsFindFirstArgs} args - Arguments to find a Laboratory_details
     * @example
     * // Get one Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends laboratory_detailsFindFirstArgs>(args?: SelectSubset<T, laboratory_detailsFindFirstArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Laboratory_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsFindFirstOrThrowArgs} args - Arguments to find a Laboratory_details
     * @example
     * // Get one Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends laboratory_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, laboratory_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Laboratory_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findMany()
     * 
     * // Get first 10 Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.findMany({ take: 10 })
     * 
     * // Only select the `laboratory_id`
     * const laboratory_detailsWithLaboratory_idOnly = await prisma.laboratory_details.findMany({ select: { laboratory_id: true } })
     * 
     */
    findMany<T extends laboratory_detailsFindManyArgs>(args?: SelectSubset<T, laboratory_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Laboratory_details.
     * @param {laboratory_detailsCreateArgs} args - Arguments to create a Laboratory_details.
     * @example
     * // Create one Laboratory_details
     * const Laboratory_details = await prisma.laboratory_details.create({
     *   data: {
     *     // ... data to create a Laboratory_details
     *   }
     * })
     * 
     */
    create<T extends laboratory_detailsCreateArgs>(args: SelectSubset<T, laboratory_detailsCreateArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Laboratory_details.
     * @param {laboratory_detailsCreateManyArgs} args - Arguments to create many Laboratory_details.
     * @example
     * // Create many Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends laboratory_detailsCreateManyArgs>(args?: SelectSubset<T, laboratory_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Laboratory_details.
     * @param {laboratory_detailsDeleteArgs} args - Arguments to delete one Laboratory_details.
     * @example
     * // Delete one Laboratory_details
     * const Laboratory_details = await prisma.laboratory_details.delete({
     *   where: {
     *     // ... filter to delete one Laboratory_details
     *   }
     * })
     * 
     */
    delete<T extends laboratory_detailsDeleteArgs>(args: SelectSubset<T, laboratory_detailsDeleteArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Laboratory_details.
     * @param {laboratory_detailsUpdateArgs} args - Arguments to update one Laboratory_details.
     * @example
     * // Update one Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends laboratory_detailsUpdateArgs>(args: SelectSubset<T, laboratory_detailsUpdateArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Laboratory_details.
     * @param {laboratory_detailsDeleteManyArgs} args - Arguments to filter Laboratory_details to delete.
     * @example
     * // Delete a few Laboratory_details
     * const { count } = await prisma.laboratory_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends laboratory_detailsDeleteManyArgs>(args?: SelectSubset<T, laboratory_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Laboratory_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends laboratory_detailsUpdateManyArgs>(args: SelectSubset<T, laboratory_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Laboratory_details.
     * @param {laboratory_detailsUpsertArgs} args - Arguments to update or create a Laboratory_details.
     * @example
     * // Update or create a Laboratory_details
     * const laboratory_details = await prisma.laboratory_details.upsert({
     *   create: {
     *     // ... data to create a Laboratory_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Laboratory_details we want to update
     *   }
     * })
     */
    upsert<T extends laboratory_detailsUpsertArgs>(args: SelectSubset<T, laboratory_detailsUpsertArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Laboratory_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsCountArgs} args - Arguments to filter Laboratory_details to count.
     * @example
     * // Count the number of Laboratory_details
     * const count = await prisma.laboratory_details.count({
     *   where: {
     *     // ... the filter for the Laboratory_details we want to count
     *   }
     * })
    **/
    count<T extends laboratory_detailsCountArgs>(
      args?: Subset<T, laboratory_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Laboratory_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Laboratory_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Laboratory_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Laboratory_detailsAggregateArgs>(args: Subset<T, Laboratory_detailsAggregateArgs>): Prisma.PrismaPromise<GetLaboratory_detailsAggregateType<T>>

    /**
     * Group by Laboratory_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends laboratory_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: laboratory_detailsGroupByArgs['orderBy'] }
        : { orderBy?: laboratory_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, laboratory_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaboratory_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the laboratory_details model
   */
  readonly fields: laboratory_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for laboratory_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__laboratory_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    laboratory_test_details<T extends laboratory_details$laboratory_test_detailsArgs<ExtArgs> = {}>(args?: Subset<T, laboratory_details$laboratory_test_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the laboratory_details model
   */ 
  interface laboratory_detailsFieldRefs {
    readonly laboratory_id: FieldRef<"laboratory_details", 'Int'>
    readonly laboratory_name: FieldRef<"laboratory_details", 'String'>
    readonly laboratory_address: FieldRef<"laboratory_details", 'String'>
    readonly locality: FieldRef<"laboratory_details", 'String'>
    readonly laboratory_phone: FieldRef<"laboratory_details", 'String'>
    readonly laboratory_email: FieldRef<"laboratory_details", 'String'>
    readonly laboratory_password: FieldRef<"laboratory_details", 'String'>
    readonly lab_state: FieldRef<"laboratory_details", 'String'>
    readonly lab_city: FieldRef<"laboratory_details", 'String'>
    readonly lab_pincode: FieldRef<"laboratory_details", 'String'>
    readonly created_on: FieldRef<"laboratory_details", 'DateTime'>
    readonly updated_on: FieldRef<"laboratory_details", 'DateTime'>
    readonly active: FieldRef<"laboratory_details", 'Int'>
    readonly role_id: FieldRef<"laboratory_details", 'Int'>
    readonly profile_filename: FieldRef<"laboratory_details", 'String'>
    readonly profile_fullpath: FieldRef<"laboratory_details", 'String'>
  }
    

  // Custom InputTypes
  /**
   * laboratory_details findUnique
   */
  export type laboratory_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_details to fetch.
     */
    where: laboratory_detailsWhereUniqueInput
  }

  /**
   * laboratory_details findUniqueOrThrow
   */
  export type laboratory_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_details to fetch.
     */
    where: laboratory_detailsWhereUniqueInput
  }

  /**
   * laboratory_details findFirst
   */
  export type laboratory_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_details to fetch.
     */
    where?: laboratory_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_details to fetch.
     */
    orderBy?: laboratory_detailsOrderByWithRelationInput | laboratory_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_details.
     */
    cursor?: laboratory_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_details.
     */
    distinct?: Laboratory_detailsScalarFieldEnum | Laboratory_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_details findFirstOrThrow
   */
  export type laboratory_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_details to fetch.
     */
    where?: laboratory_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_details to fetch.
     */
    orderBy?: laboratory_detailsOrderByWithRelationInput | laboratory_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_details.
     */
    cursor?: laboratory_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_details.
     */
    distinct?: Laboratory_detailsScalarFieldEnum | Laboratory_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_details findMany
   */
  export type laboratory_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_details to fetch.
     */
    where?: laboratory_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_details to fetch.
     */
    orderBy?: laboratory_detailsOrderByWithRelationInput | laboratory_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing laboratory_details.
     */
    cursor?: laboratory_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_details.
     */
    skip?: number
    distinct?: Laboratory_detailsScalarFieldEnum | Laboratory_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_details create
   */
  export type laboratory_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a laboratory_details.
     */
    data: XOR<laboratory_detailsCreateInput, laboratory_detailsUncheckedCreateInput>
  }

  /**
   * laboratory_details createMany
   */
  export type laboratory_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many laboratory_details.
     */
    data: laboratory_detailsCreateManyInput | laboratory_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * laboratory_details update
   */
  export type laboratory_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a laboratory_details.
     */
    data: XOR<laboratory_detailsUpdateInput, laboratory_detailsUncheckedUpdateInput>
    /**
     * Choose, which laboratory_details to update.
     */
    where: laboratory_detailsWhereUniqueInput
  }

  /**
   * laboratory_details updateMany
   */
  export type laboratory_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update laboratory_details.
     */
    data: XOR<laboratory_detailsUpdateManyMutationInput, laboratory_detailsUncheckedUpdateManyInput>
    /**
     * Filter which laboratory_details to update
     */
    where?: laboratory_detailsWhereInput
  }

  /**
   * laboratory_details upsert
   */
  export type laboratory_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the laboratory_details to update in case it exists.
     */
    where: laboratory_detailsWhereUniqueInput
    /**
     * In case the laboratory_details found by the `where` argument doesn't exist, create a new laboratory_details with this data.
     */
    create: XOR<laboratory_detailsCreateInput, laboratory_detailsUncheckedCreateInput>
    /**
     * In case the laboratory_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<laboratory_detailsUpdateInput, laboratory_detailsUncheckedUpdateInput>
  }

  /**
   * laboratory_details delete
   */
  export type laboratory_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
    /**
     * Filter which laboratory_details to delete.
     */
    where: laboratory_detailsWhereUniqueInput
  }

  /**
   * laboratory_details deleteMany
   */
  export type laboratory_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_details to delete
     */
    where?: laboratory_detailsWhereInput
  }

  /**
   * laboratory_details.laboratory_test_details
   */
  export type laboratory_details$laboratory_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    where?: laboratory_test_detailsWhereInput
    orderBy?: laboratory_test_detailsOrderByWithRelationInput | laboratory_test_detailsOrderByWithRelationInput[]
    cursor?: laboratory_test_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Laboratory_test_detailsScalarFieldEnum | Laboratory_test_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_details without action
   */
  export type laboratory_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_details
     */
    select?: laboratory_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_detailsInclude<ExtArgs> | null
  }


  /**
   * Model laboratory_doctors
   */

  export type AggregateLaboratory_doctors = {
    _count: Laboratory_doctorsCountAggregateOutputType | null
    _avg: Laboratory_doctorsAvgAggregateOutputType | null
    _sum: Laboratory_doctorsSumAggregateOutputType | null
    _min: Laboratory_doctorsMinAggregateOutputType | null
    _max: Laboratory_doctorsMaxAggregateOutputType | null
  }

  export type Laboratory_doctorsAvgAggregateOutputType = {
    laboratory_doctors_id: number | null
    laboratory_id: number | null
    doc_dept: number | null
    is_active: number | null
  }

  export type Laboratory_doctorsSumAggregateOutputType = {
    laboratory_doctors_id: number | null
    laboratory_id: number | null
    doc_dept: number | null
    is_active: number | null
  }

  export type Laboratory_doctorsMinAggregateOutputType = {
    laboratory_doctors_id: number | null
    laboratory_id: number | null
    doc_firstname: string | null
    doc_lastname: string | null
    doc_password: string | null
    doc_phone_number: string | null
    doc_email: string | null
    doc_dept: number | null
    doc_signature: string | null
    added_date: Date | null
    doc_designation: string | null
    is_active: number | null
  }

  export type Laboratory_doctorsMaxAggregateOutputType = {
    laboratory_doctors_id: number | null
    laboratory_id: number | null
    doc_firstname: string | null
    doc_lastname: string | null
    doc_password: string | null
    doc_phone_number: string | null
    doc_email: string | null
    doc_dept: number | null
    doc_signature: string | null
    added_date: Date | null
    doc_designation: string | null
    is_active: number | null
  }

  export type Laboratory_doctorsCountAggregateOutputType = {
    laboratory_doctors_id: number
    laboratory_id: number
    doc_firstname: number
    doc_lastname: number
    doc_password: number
    doc_phone_number: number
    doc_email: number
    doc_dept: number
    doc_signature: number
    added_date: number
    doc_designation: number
    is_active: number
    _all: number
  }


  export type Laboratory_doctorsAvgAggregateInputType = {
    laboratory_doctors_id?: true
    laboratory_id?: true
    doc_dept?: true
    is_active?: true
  }

  export type Laboratory_doctorsSumAggregateInputType = {
    laboratory_doctors_id?: true
    laboratory_id?: true
    doc_dept?: true
    is_active?: true
  }

  export type Laboratory_doctorsMinAggregateInputType = {
    laboratory_doctors_id?: true
    laboratory_id?: true
    doc_firstname?: true
    doc_lastname?: true
    doc_password?: true
    doc_phone_number?: true
    doc_email?: true
    doc_dept?: true
    doc_signature?: true
    added_date?: true
    doc_designation?: true
    is_active?: true
  }

  export type Laboratory_doctorsMaxAggregateInputType = {
    laboratory_doctors_id?: true
    laboratory_id?: true
    doc_firstname?: true
    doc_lastname?: true
    doc_password?: true
    doc_phone_number?: true
    doc_email?: true
    doc_dept?: true
    doc_signature?: true
    added_date?: true
    doc_designation?: true
    is_active?: true
  }

  export type Laboratory_doctorsCountAggregateInputType = {
    laboratory_doctors_id?: true
    laboratory_id?: true
    doc_firstname?: true
    doc_lastname?: true
    doc_password?: true
    doc_phone_number?: true
    doc_email?: true
    doc_dept?: true
    doc_signature?: true
    added_date?: true
    doc_designation?: true
    is_active?: true
    _all?: true
  }

  export type Laboratory_doctorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_doctors to aggregate.
     */
    where?: laboratory_doctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_doctors to fetch.
     */
    orderBy?: laboratory_doctorsOrderByWithRelationInput | laboratory_doctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: laboratory_doctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned laboratory_doctors
    **/
    _count?: true | Laboratory_doctorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Laboratory_doctorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Laboratory_doctorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Laboratory_doctorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Laboratory_doctorsMaxAggregateInputType
  }

  export type GetLaboratory_doctorsAggregateType<T extends Laboratory_doctorsAggregateArgs> = {
        [P in keyof T & keyof AggregateLaboratory_doctors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaboratory_doctors[P]>
      : GetScalarType<T[P], AggregateLaboratory_doctors[P]>
  }




  export type laboratory_doctorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: laboratory_doctorsWhereInput
    orderBy?: laboratory_doctorsOrderByWithAggregationInput | laboratory_doctorsOrderByWithAggregationInput[]
    by: Laboratory_doctorsScalarFieldEnum[] | Laboratory_doctorsScalarFieldEnum
    having?: laboratory_doctorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Laboratory_doctorsCountAggregateInputType | true
    _avg?: Laboratory_doctorsAvgAggregateInputType
    _sum?: Laboratory_doctorsSumAggregateInputType
    _min?: Laboratory_doctorsMinAggregateInputType
    _max?: Laboratory_doctorsMaxAggregateInputType
  }

  export type Laboratory_doctorsGroupByOutputType = {
    laboratory_doctors_id: number
    laboratory_id: number
    doc_firstname: string
    doc_lastname: string
    doc_password: string
    doc_phone_number: string
    doc_email: string
    doc_dept: number
    doc_signature: string
    added_date: Date
    doc_designation: string
    is_active: number
    _count: Laboratory_doctorsCountAggregateOutputType | null
    _avg: Laboratory_doctorsAvgAggregateOutputType | null
    _sum: Laboratory_doctorsSumAggregateOutputType | null
    _min: Laboratory_doctorsMinAggregateOutputType | null
    _max: Laboratory_doctorsMaxAggregateOutputType | null
  }

  type GetLaboratory_doctorsGroupByPayload<T extends laboratory_doctorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Laboratory_doctorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Laboratory_doctorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Laboratory_doctorsGroupByOutputType[P]>
            : GetScalarType<T[P], Laboratory_doctorsGroupByOutputType[P]>
        }
      >
    >


  export type laboratory_doctorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    laboratory_doctors_id?: boolean
    laboratory_id?: boolean
    doc_firstname?: boolean
    doc_lastname?: boolean
    doc_password?: boolean
    doc_phone_number?: boolean
    doc_email?: boolean
    doc_dept?: boolean
    doc_signature?: boolean
    added_date?: boolean
    doc_designation?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["laboratory_doctors"]>


  export type laboratory_doctorsSelectScalar = {
    laboratory_doctors_id?: boolean
    laboratory_id?: boolean
    doc_firstname?: boolean
    doc_lastname?: boolean
    doc_password?: boolean
    doc_phone_number?: boolean
    doc_email?: boolean
    doc_dept?: boolean
    doc_signature?: boolean
    added_date?: boolean
    doc_designation?: boolean
    is_active?: boolean
  }


  export type $laboratory_doctorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "laboratory_doctors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      laboratory_doctors_id: number
      laboratory_id: number
      doc_firstname: string
      doc_lastname: string
      doc_password: string
      doc_phone_number: string
      doc_email: string
      doc_dept: number
      doc_signature: string
      added_date: Date
      doc_designation: string
      is_active: number
    }, ExtArgs["result"]["laboratory_doctors"]>
    composites: {}
  }

  type laboratory_doctorsGetPayload<S extends boolean | null | undefined | laboratory_doctorsDefaultArgs> = $Result.GetResult<Prisma.$laboratory_doctorsPayload, S>

  type laboratory_doctorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<laboratory_doctorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Laboratory_doctorsCountAggregateInputType | true
    }

  export interface laboratory_doctorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['laboratory_doctors'], meta: { name: 'laboratory_doctors' } }
    /**
     * Find zero or one Laboratory_doctors that matches the filter.
     * @param {laboratory_doctorsFindUniqueArgs} args - Arguments to find a Laboratory_doctors
     * @example
     * // Get one Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends laboratory_doctorsFindUniqueArgs>(args: SelectSubset<T, laboratory_doctorsFindUniqueArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Laboratory_doctors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {laboratory_doctorsFindUniqueOrThrowArgs} args - Arguments to find a Laboratory_doctors
     * @example
     * // Get one Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends laboratory_doctorsFindUniqueOrThrowArgs>(args: SelectSubset<T, laboratory_doctorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Laboratory_doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsFindFirstArgs} args - Arguments to find a Laboratory_doctors
     * @example
     * // Get one Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends laboratory_doctorsFindFirstArgs>(args?: SelectSubset<T, laboratory_doctorsFindFirstArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Laboratory_doctors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsFindFirstOrThrowArgs} args - Arguments to find a Laboratory_doctors
     * @example
     * // Get one Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends laboratory_doctorsFindFirstOrThrowArgs>(args?: SelectSubset<T, laboratory_doctorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Laboratory_doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findMany()
     * 
     * // Get first 10 Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.findMany({ take: 10 })
     * 
     * // Only select the `laboratory_doctors_id`
     * const laboratory_doctorsWithLaboratory_doctors_idOnly = await prisma.laboratory_doctors.findMany({ select: { laboratory_doctors_id: true } })
     * 
     */
    findMany<T extends laboratory_doctorsFindManyArgs>(args?: SelectSubset<T, laboratory_doctorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Laboratory_doctors.
     * @param {laboratory_doctorsCreateArgs} args - Arguments to create a Laboratory_doctors.
     * @example
     * // Create one Laboratory_doctors
     * const Laboratory_doctors = await prisma.laboratory_doctors.create({
     *   data: {
     *     // ... data to create a Laboratory_doctors
     *   }
     * })
     * 
     */
    create<T extends laboratory_doctorsCreateArgs>(args: SelectSubset<T, laboratory_doctorsCreateArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Laboratory_doctors.
     * @param {laboratory_doctorsCreateManyArgs} args - Arguments to create many Laboratory_doctors.
     * @example
     * // Create many Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends laboratory_doctorsCreateManyArgs>(args?: SelectSubset<T, laboratory_doctorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Laboratory_doctors.
     * @param {laboratory_doctorsDeleteArgs} args - Arguments to delete one Laboratory_doctors.
     * @example
     * // Delete one Laboratory_doctors
     * const Laboratory_doctors = await prisma.laboratory_doctors.delete({
     *   where: {
     *     // ... filter to delete one Laboratory_doctors
     *   }
     * })
     * 
     */
    delete<T extends laboratory_doctorsDeleteArgs>(args: SelectSubset<T, laboratory_doctorsDeleteArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Laboratory_doctors.
     * @param {laboratory_doctorsUpdateArgs} args - Arguments to update one Laboratory_doctors.
     * @example
     * // Update one Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends laboratory_doctorsUpdateArgs>(args: SelectSubset<T, laboratory_doctorsUpdateArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Laboratory_doctors.
     * @param {laboratory_doctorsDeleteManyArgs} args - Arguments to filter Laboratory_doctors to delete.
     * @example
     * // Delete a few Laboratory_doctors
     * const { count } = await prisma.laboratory_doctors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends laboratory_doctorsDeleteManyArgs>(args?: SelectSubset<T, laboratory_doctorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Laboratory_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends laboratory_doctorsUpdateManyArgs>(args: SelectSubset<T, laboratory_doctorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Laboratory_doctors.
     * @param {laboratory_doctorsUpsertArgs} args - Arguments to update or create a Laboratory_doctors.
     * @example
     * // Update or create a Laboratory_doctors
     * const laboratory_doctors = await prisma.laboratory_doctors.upsert({
     *   create: {
     *     // ... data to create a Laboratory_doctors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Laboratory_doctors we want to update
     *   }
     * })
     */
    upsert<T extends laboratory_doctorsUpsertArgs>(args: SelectSubset<T, laboratory_doctorsUpsertArgs<ExtArgs>>): Prisma__laboratory_doctorsClient<$Result.GetResult<Prisma.$laboratory_doctorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Laboratory_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsCountArgs} args - Arguments to filter Laboratory_doctors to count.
     * @example
     * // Count the number of Laboratory_doctors
     * const count = await prisma.laboratory_doctors.count({
     *   where: {
     *     // ... the filter for the Laboratory_doctors we want to count
     *   }
     * })
    **/
    count<T extends laboratory_doctorsCountArgs>(
      args?: Subset<T, laboratory_doctorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Laboratory_doctorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Laboratory_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Laboratory_doctorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Laboratory_doctorsAggregateArgs>(args: Subset<T, Laboratory_doctorsAggregateArgs>): Prisma.PrismaPromise<GetLaboratory_doctorsAggregateType<T>>

    /**
     * Group by Laboratory_doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_doctorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends laboratory_doctorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: laboratory_doctorsGroupByArgs['orderBy'] }
        : { orderBy?: laboratory_doctorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, laboratory_doctorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaboratory_doctorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the laboratory_doctors model
   */
  readonly fields: laboratory_doctorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for laboratory_doctors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__laboratory_doctorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the laboratory_doctors model
   */ 
  interface laboratory_doctorsFieldRefs {
    readonly laboratory_doctors_id: FieldRef<"laboratory_doctors", 'Int'>
    readonly laboratory_id: FieldRef<"laboratory_doctors", 'Int'>
    readonly doc_firstname: FieldRef<"laboratory_doctors", 'String'>
    readonly doc_lastname: FieldRef<"laboratory_doctors", 'String'>
    readonly doc_password: FieldRef<"laboratory_doctors", 'String'>
    readonly doc_phone_number: FieldRef<"laboratory_doctors", 'String'>
    readonly doc_email: FieldRef<"laboratory_doctors", 'String'>
    readonly doc_dept: FieldRef<"laboratory_doctors", 'Int'>
    readonly doc_signature: FieldRef<"laboratory_doctors", 'String'>
    readonly added_date: FieldRef<"laboratory_doctors", 'DateTime'>
    readonly doc_designation: FieldRef<"laboratory_doctors", 'String'>
    readonly is_active: FieldRef<"laboratory_doctors", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * laboratory_doctors findUnique
   */
  export type laboratory_doctorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter, which laboratory_doctors to fetch.
     */
    where: laboratory_doctorsWhereUniqueInput
  }

  /**
   * laboratory_doctors findUniqueOrThrow
   */
  export type laboratory_doctorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter, which laboratory_doctors to fetch.
     */
    where: laboratory_doctorsWhereUniqueInput
  }

  /**
   * laboratory_doctors findFirst
   */
  export type laboratory_doctorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter, which laboratory_doctors to fetch.
     */
    where?: laboratory_doctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_doctors to fetch.
     */
    orderBy?: laboratory_doctorsOrderByWithRelationInput | laboratory_doctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_doctors.
     */
    cursor?: laboratory_doctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_doctors.
     */
    distinct?: Laboratory_doctorsScalarFieldEnum | Laboratory_doctorsScalarFieldEnum[]
  }

  /**
   * laboratory_doctors findFirstOrThrow
   */
  export type laboratory_doctorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter, which laboratory_doctors to fetch.
     */
    where?: laboratory_doctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_doctors to fetch.
     */
    orderBy?: laboratory_doctorsOrderByWithRelationInput | laboratory_doctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_doctors.
     */
    cursor?: laboratory_doctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_doctors.
     */
    distinct?: Laboratory_doctorsScalarFieldEnum | Laboratory_doctorsScalarFieldEnum[]
  }

  /**
   * laboratory_doctors findMany
   */
  export type laboratory_doctorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter, which laboratory_doctors to fetch.
     */
    where?: laboratory_doctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_doctors to fetch.
     */
    orderBy?: laboratory_doctorsOrderByWithRelationInput | laboratory_doctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing laboratory_doctors.
     */
    cursor?: laboratory_doctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_doctors.
     */
    skip?: number
    distinct?: Laboratory_doctorsScalarFieldEnum | Laboratory_doctorsScalarFieldEnum[]
  }

  /**
   * laboratory_doctors create
   */
  export type laboratory_doctorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * The data needed to create a laboratory_doctors.
     */
    data: XOR<laboratory_doctorsCreateInput, laboratory_doctorsUncheckedCreateInput>
  }

  /**
   * laboratory_doctors createMany
   */
  export type laboratory_doctorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many laboratory_doctors.
     */
    data: laboratory_doctorsCreateManyInput | laboratory_doctorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * laboratory_doctors update
   */
  export type laboratory_doctorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * The data needed to update a laboratory_doctors.
     */
    data: XOR<laboratory_doctorsUpdateInput, laboratory_doctorsUncheckedUpdateInput>
    /**
     * Choose, which laboratory_doctors to update.
     */
    where: laboratory_doctorsWhereUniqueInput
  }

  /**
   * laboratory_doctors updateMany
   */
  export type laboratory_doctorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update laboratory_doctors.
     */
    data: XOR<laboratory_doctorsUpdateManyMutationInput, laboratory_doctorsUncheckedUpdateManyInput>
    /**
     * Filter which laboratory_doctors to update
     */
    where?: laboratory_doctorsWhereInput
  }

  /**
   * laboratory_doctors upsert
   */
  export type laboratory_doctorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * The filter to search for the laboratory_doctors to update in case it exists.
     */
    where: laboratory_doctorsWhereUniqueInput
    /**
     * In case the laboratory_doctors found by the `where` argument doesn't exist, create a new laboratory_doctors with this data.
     */
    create: XOR<laboratory_doctorsCreateInput, laboratory_doctorsUncheckedCreateInput>
    /**
     * In case the laboratory_doctors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<laboratory_doctorsUpdateInput, laboratory_doctorsUncheckedUpdateInput>
  }

  /**
   * laboratory_doctors delete
   */
  export type laboratory_doctorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
    /**
     * Filter which laboratory_doctors to delete.
     */
    where: laboratory_doctorsWhereUniqueInput
  }

  /**
   * laboratory_doctors deleteMany
   */
  export type laboratory_doctorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_doctors to delete
     */
    where?: laboratory_doctorsWhereInput
  }

  /**
   * laboratory_doctors without action
   */
  export type laboratory_doctorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_doctors
     */
    select?: laboratory_doctorsSelect<ExtArgs> | null
  }


  /**
   * Model laboratory_test_details
   */

  export type AggregateLaboratory_test_details = {
    _count: Laboratory_test_detailsCountAggregateOutputType | null
    _avg: Laboratory_test_detailsAvgAggregateOutputType | null
    _sum: Laboratory_test_detailsSumAggregateOutputType | null
    _min: Laboratory_test_detailsMinAggregateOutputType | null
    _max: Laboratory_test_detailsMaxAggregateOutputType | null
  }

  export type Laboratory_test_detailsAvgAggregateOutputType = {
    laboratory_testid: number | null
    display_order: number | null
    laboratory_id: number | null
    test_price: number | null
    sort_order: number | null
    title_required: number | null
  }

  export type Laboratory_test_detailsSumAggregateOutputType = {
    laboratory_testid: number | null
    display_order: number | null
    laboratory_id: number | null
    test_price: bigint | null
    sort_order: number | null
    title_required: number | null
  }

  export type Laboratory_test_detailsMinAggregateOutputType = {
    laboratory_testid: number | null
    laboratory_tests: string | null
    code: string | null
    display_order: number | null
    mnemonics: string | null
    test_type: string | null
    sub_department: string | null
    sample_type: string | null
    container_type: string | null
    confidential: string | null
    methodology: string | null
    transport_temperature: string | null
    tat: string | null
    outsourcing_status: string | null
    instrument: string | null
    laboratory_id: number | null
    test_price: bigint | null
    custom_test_name: string | null
    instruction: string | null
    test_method: string | null
    status: $Enums.laboratory_test_details_status | null
    status_changed_by: string | null
    status_changed_on: string | null
    unit: string | null
    reference_range: string | null
    age_gender_specific: string | null
    critical_alert: string | null
    interpretation: string | null
    sort_order: number | null
    title_required: number | null
  }

  export type Laboratory_test_detailsMaxAggregateOutputType = {
    laboratory_testid: number | null
    laboratory_tests: string | null
    code: string | null
    display_order: number | null
    mnemonics: string | null
    test_type: string | null
    sub_department: string | null
    sample_type: string | null
    container_type: string | null
    confidential: string | null
    methodology: string | null
    transport_temperature: string | null
    tat: string | null
    outsourcing_status: string | null
    instrument: string | null
    laboratory_id: number | null
    test_price: bigint | null
    custom_test_name: string | null
    instruction: string | null
    test_method: string | null
    status: $Enums.laboratory_test_details_status | null
    status_changed_by: string | null
    status_changed_on: string | null
    unit: string | null
    reference_range: string | null
    age_gender_specific: string | null
    critical_alert: string | null
    interpretation: string | null
    sort_order: number | null
    title_required: number | null
  }

  export type Laboratory_test_detailsCountAggregateOutputType = {
    laboratory_testid: number
    laboratory_tests: number
    code: number
    display_order: number
    mnemonics: number
    test_type: number
    sub_department: number
    sample_type: number
    container_type: number
    confidential: number
    methodology: number
    transport_temperature: number
    tat: number
    outsourcing_status: number
    instrument: number
    laboratory_id: number
    test_price: number
    custom_test_name: number
    instruction: number
    test_method: number
    status: number
    status_changed_by: number
    status_changed_on: number
    unit: number
    reference_range: number
    age_gender_specific: number
    critical_alert: number
    interpretation: number
    sort_order: number
    title_required: number
    _all: number
  }


  export type Laboratory_test_detailsAvgAggregateInputType = {
    laboratory_testid?: true
    display_order?: true
    laboratory_id?: true
    test_price?: true
    sort_order?: true
    title_required?: true
  }

  export type Laboratory_test_detailsSumAggregateInputType = {
    laboratory_testid?: true
    display_order?: true
    laboratory_id?: true
    test_price?: true
    sort_order?: true
    title_required?: true
  }

  export type Laboratory_test_detailsMinAggregateInputType = {
    laboratory_testid?: true
    laboratory_tests?: true
    code?: true
    display_order?: true
    mnemonics?: true
    test_type?: true
    sub_department?: true
    sample_type?: true
    container_type?: true
    confidential?: true
    methodology?: true
    transport_temperature?: true
    tat?: true
    outsourcing_status?: true
    instrument?: true
    laboratory_id?: true
    test_price?: true
    custom_test_name?: true
    instruction?: true
    test_method?: true
    status?: true
    status_changed_by?: true
    status_changed_on?: true
    unit?: true
    reference_range?: true
    age_gender_specific?: true
    critical_alert?: true
    interpretation?: true
    sort_order?: true
    title_required?: true
  }

  export type Laboratory_test_detailsMaxAggregateInputType = {
    laboratory_testid?: true
    laboratory_tests?: true
    code?: true
    display_order?: true
    mnemonics?: true
    test_type?: true
    sub_department?: true
    sample_type?: true
    container_type?: true
    confidential?: true
    methodology?: true
    transport_temperature?: true
    tat?: true
    outsourcing_status?: true
    instrument?: true
    laboratory_id?: true
    test_price?: true
    custom_test_name?: true
    instruction?: true
    test_method?: true
    status?: true
    status_changed_by?: true
    status_changed_on?: true
    unit?: true
    reference_range?: true
    age_gender_specific?: true
    critical_alert?: true
    interpretation?: true
    sort_order?: true
    title_required?: true
  }

  export type Laboratory_test_detailsCountAggregateInputType = {
    laboratory_testid?: true
    laboratory_tests?: true
    code?: true
    display_order?: true
    mnemonics?: true
    test_type?: true
    sub_department?: true
    sample_type?: true
    container_type?: true
    confidential?: true
    methodology?: true
    transport_temperature?: true
    tat?: true
    outsourcing_status?: true
    instrument?: true
    laboratory_id?: true
    test_price?: true
    custom_test_name?: true
    instruction?: true
    test_method?: true
    status?: true
    status_changed_by?: true
    status_changed_on?: true
    unit?: true
    reference_range?: true
    age_gender_specific?: true
    critical_alert?: true
    interpretation?: true
    sort_order?: true
    title_required?: true
    _all?: true
  }

  export type Laboratory_test_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_test_details to aggregate.
     */
    where?: laboratory_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_test_details to fetch.
     */
    orderBy?: laboratory_test_detailsOrderByWithRelationInput | laboratory_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: laboratory_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned laboratory_test_details
    **/
    _count?: true | Laboratory_test_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Laboratory_test_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Laboratory_test_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Laboratory_test_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Laboratory_test_detailsMaxAggregateInputType
  }

  export type GetLaboratory_test_detailsAggregateType<T extends Laboratory_test_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateLaboratory_test_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaboratory_test_details[P]>
      : GetScalarType<T[P], AggregateLaboratory_test_details[P]>
  }




  export type laboratory_test_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: laboratory_test_detailsWhereInput
    orderBy?: laboratory_test_detailsOrderByWithAggregationInput | laboratory_test_detailsOrderByWithAggregationInput[]
    by: Laboratory_test_detailsScalarFieldEnum[] | Laboratory_test_detailsScalarFieldEnum
    having?: laboratory_test_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Laboratory_test_detailsCountAggregateInputType | true
    _avg?: Laboratory_test_detailsAvgAggregateInputType
    _sum?: Laboratory_test_detailsSumAggregateInputType
    _min?: Laboratory_test_detailsMinAggregateInputType
    _max?: Laboratory_test_detailsMaxAggregateInputType
  }

  export type Laboratory_test_detailsGroupByOutputType = {
    laboratory_testid: number
    laboratory_tests: string
    code: string
    display_order: number | null
    mnemonics: string | null
    test_type: string | null
    sub_department: string | null
    sample_type: string | null
    container_type: string | null
    confidential: string | null
    methodology: string | null
    transport_temperature: string | null
    tat: string | null
    outsourcing_status: string | null
    instrument: string | null
    laboratory_id: number
    test_price: bigint
    custom_test_name: string
    instruction: string
    test_method: string
    status: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific: string | null
    critical_alert: string | null
    interpretation: string | null
    sort_order: number
    title_required: number
    _count: Laboratory_test_detailsCountAggregateOutputType | null
    _avg: Laboratory_test_detailsAvgAggregateOutputType | null
    _sum: Laboratory_test_detailsSumAggregateOutputType | null
    _min: Laboratory_test_detailsMinAggregateOutputType | null
    _max: Laboratory_test_detailsMaxAggregateOutputType | null
  }

  type GetLaboratory_test_detailsGroupByPayload<T extends laboratory_test_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Laboratory_test_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Laboratory_test_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Laboratory_test_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Laboratory_test_detailsGroupByOutputType[P]>
        }
      >
    >


  export type laboratory_test_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    laboratory_testid?: boolean
    laboratory_tests?: boolean
    code?: boolean
    display_order?: boolean
    mnemonics?: boolean
    test_type?: boolean
    sub_department?: boolean
    sample_type?: boolean
    container_type?: boolean
    confidential?: boolean
    methodology?: boolean
    transport_temperature?: boolean
    tat?: boolean
    outsourcing_status?: boolean
    instrument?: boolean
    laboratory_id?: boolean
    test_price?: boolean
    custom_test_name?: boolean
    instruction?: boolean
    test_method?: boolean
    status?: boolean
    status_changed_by?: boolean
    status_changed_on?: boolean
    unit?: boolean
    reference_range?: boolean
    age_gender_specific?: boolean
    critical_alert?: boolean
    interpretation?: boolean
    sort_order?: boolean
    title_required?: boolean
    laboratory_details?: boolean | laboratory_detailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laboratory_test_details"]>


  export type laboratory_test_detailsSelectScalar = {
    laboratory_testid?: boolean
    laboratory_tests?: boolean
    code?: boolean
    display_order?: boolean
    mnemonics?: boolean
    test_type?: boolean
    sub_department?: boolean
    sample_type?: boolean
    container_type?: boolean
    confidential?: boolean
    methodology?: boolean
    transport_temperature?: boolean
    tat?: boolean
    outsourcing_status?: boolean
    instrument?: boolean
    laboratory_id?: boolean
    test_price?: boolean
    custom_test_name?: boolean
    instruction?: boolean
    test_method?: boolean
    status?: boolean
    status_changed_by?: boolean
    status_changed_on?: boolean
    unit?: boolean
    reference_range?: boolean
    age_gender_specific?: boolean
    critical_alert?: boolean
    interpretation?: boolean
    sort_order?: boolean
    title_required?: boolean
  }

  export type laboratory_test_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laboratory_details?: boolean | laboratory_detailsDefaultArgs<ExtArgs>
  }

  export type $laboratory_test_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "laboratory_test_details"
    objects: {
      laboratory_details: Prisma.$laboratory_detailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      laboratory_testid: number
      laboratory_tests: string
      code: string
      display_order: number | null
      mnemonics: string | null
      test_type: string | null
      sub_department: string | null
      sample_type: string | null
      container_type: string | null
      confidential: string | null
      methodology: string | null
      transport_temperature: string | null
      tat: string | null
      outsourcing_status: string | null
      instrument: string | null
      laboratory_id: number
      test_price: bigint
      custom_test_name: string
      instruction: string
      test_method: string
      status: $Enums.laboratory_test_details_status
      status_changed_by: string
      status_changed_on: string
      unit: string
      reference_range: string
      age_gender_specific: string | null
      critical_alert: string | null
      interpretation: string | null
      sort_order: number
      title_required: number
    }, ExtArgs["result"]["laboratory_test_details"]>
    composites: {}
  }

  type laboratory_test_detailsGetPayload<S extends boolean | null | undefined | laboratory_test_detailsDefaultArgs> = $Result.GetResult<Prisma.$laboratory_test_detailsPayload, S>

  type laboratory_test_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<laboratory_test_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Laboratory_test_detailsCountAggregateInputType | true
    }

  export interface laboratory_test_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['laboratory_test_details'], meta: { name: 'laboratory_test_details' } }
    /**
     * Find zero or one Laboratory_test_details that matches the filter.
     * @param {laboratory_test_detailsFindUniqueArgs} args - Arguments to find a Laboratory_test_details
     * @example
     * // Get one Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends laboratory_test_detailsFindUniqueArgs>(args: SelectSubset<T, laboratory_test_detailsFindUniqueArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Laboratory_test_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {laboratory_test_detailsFindUniqueOrThrowArgs} args - Arguments to find a Laboratory_test_details
     * @example
     * // Get one Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends laboratory_test_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, laboratory_test_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Laboratory_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsFindFirstArgs} args - Arguments to find a Laboratory_test_details
     * @example
     * // Get one Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends laboratory_test_detailsFindFirstArgs>(args?: SelectSubset<T, laboratory_test_detailsFindFirstArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Laboratory_test_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsFindFirstOrThrowArgs} args - Arguments to find a Laboratory_test_details
     * @example
     * // Get one Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends laboratory_test_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, laboratory_test_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Laboratory_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findMany()
     * 
     * // Get first 10 Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.findMany({ take: 10 })
     * 
     * // Only select the `laboratory_testid`
     * const laboratory_test_detailsWithLaboratory_testidOnly = await prisma.laboratory_test_details.findMany({ select: { laboratory_testid: true } })
     * 
     */
    findMany<T extends laboratory_test_detailsFindManyArgs>(args?: SelectSubset<T, laboratory_test_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Laboratory_test_details.
     * @param {laboratory_test_detailsCreateArgs} args - Arguments to create a Laboratory_test_details.
     * @example
     * // Create one Laboratory_test_details
     * const Laboratory_test_details = await prisma.laboratory_test_details.create({
     *   data: {
     *     // ... data to create a Laboratory_test_details
     *   }
     * })
     * 
     */
    create<T extends laboratory_test_detailsCreateArgs>(args: SelectSubset<T, laboratory_test_detailsCreateArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Laboratory_test_details.
     * @param {laboratory_test_detailsCreateManyArgs} args - Arguments to create many Laboratory_test_details.
     * @example
     * // Create many Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends laboratory_test_detailsCreateManyArgs>(args?: SelectSubset<T, laboratory_test_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Laboratory_test_details.
     * @param {laboratory_test_detailsDeleteArgs} args - Arguments to delete one Laboratory_test_details.
     * @example
     * // Delete one Laboratory_test_details
     * const Laboratory_test_details = await prisma.laboratory_test_details.delete({
     *   where: {
     *     // ... filter to delete one Laboratory_test_details
     *   }
     * })
     * 
     */
    delete<T extends laboratory_test_detailsDeleteArgs>(args: SelectSubset<T, laboratory_test_detailsDeleteArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Laboratory_test_details.
     * @param {laboratory_test_detailsUpdateArgs} args - Arguments to update one Laboratory_test_details.
     * @example
     * // Update one Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends laboratory_test_detailsUpdateArgs>(args: SelectSubset<T, laboratory_test_detailsUpdateArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Laboratory_test_details.
     * @param {laboratory_test_detailsDeleteManyArgs} args - Arguments to filter Laboratory_test_details to delete.
     * @example
     * // Delete a few Laboratory_test_details
     * const { count } = await prisma.laboratory_test_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends laboratory_test_detailsDeleteManyArgs>(args?: SelectSubset<T, laboratory_test_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Laboratory_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends laboratory_test_detailsUpdateManyArgs>(args: SelectSubset<T, laboratory_test_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Laboratory_test_details.
     * @param {laboratory_test_detailsUpsertArgs} args - Arguments to update or create a Laboratory_test_details.
     * @example
     * // Update or create a Laboratory_test_details
     * const laboratory_test_details = await prisma.laboratory_test_details.upsert({
     *   create: {
     *     // ... data to create a Laboratory_test_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Laboratory_test_details we want to update
     *   }
     * })
     */
    upsert<T extends laboratory_test_detailsUpsertArgs>(args: SelectSubset<T, laboratory_test_detailsUpsertArgs<ExtArgs>>): Prisma__laboratory_test_detailsClient<$Result.GetResult<Prisma.$laboratory_test_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Laboratory_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsCountArgs} args - Arguments to filter Laboratory_test_details to count.
     * @example
     * // Count the number of Laboratory_test_details
     * const count = await prisma.laboratory_test_details.count({
     *   where: {
     *     // ... the filter for the Laboratory_test_details we want to count
     *   }
     * })
    **/
    count<T extends laboratory_test_detailsCountArgs>(
      args?: Subset<T, laboratory_test_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Laboratory_test_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Laboratory_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Laboratory_test_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Laboratory_test_detailsAggregateArgs>(args: Subset<T, Laboratory_test_detailsAggregateArgs>): Prisma.PrismaPromise<GetLaboratory_test_detailsAggregateType<T>>

    /**
     * Group by Laboratory_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {laboratory_test_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends laboratory_test_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: laboratory_test_detailsGroupByArgs['orderBy'] }
        : { orderBy?: laboratory_test_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, laboratory_test_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaboratory_test_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the laboratory_test_details model
   */
  readonly fields: laboratory_test_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for laboratory_test_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__laboratory_test_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    laboratory_details<T extends laboratory_detailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, laboratory_detailsDefaultArgs<ExtArgs>>): Prisma__laboratory_detailsClient<$Result.GetResult<Prisma.$laboratory_detailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the laboratory_test_details model
   */ 
  interface laboratory_test_detailsFieldRefs {
    readonly laboratory_testid: FieldRef<"laboratory_test_details", 'Int'>
    readonly laboratory_tests: FieldRef<"laboratory_test_details", 'String'>
    readonly code: FieldRef<"laboratory_test_details", 'String'>
    readonly display_order: FieldRef<"laboratory_test_details", 'Int'>
    readonly mnemonics: FieldRef<"laboratory_test_details", 'String'>
    readonly test_type: FieldRef<"laboratory_test_details", 'String'>
    readonly sub_department: FieldRef<"laboratory_test_details", 'String'>
    readonly sample_type: FieldRef<"laboratory_test_details", 'String'>
    readonly container_type: FieldRef<"laboratory_test_details", 'String'>
    readonly confidential: FieldRef<"laboratory_test_details", 'String'>
    readonly methodology: FieldRef<"laboratory_test_details", 'String'>
    readonly transport_temperature: FieldRef<"laboratory_test_details", 'String'>
    readonly tat: FieldRef<"laboratory_test_details", 'String'>
    readonly outsourcing_status: FieldRef<"laboratory_test_details", 'String'>
    readonly instrument: FieldRef<"laboratory_test_details", 'String'>
    readonly laboratory_id: FieldRef<"laboratory_test_details", 'Int'>
    readonly test_price: FieldRef<"laboratory_test_details", 'BigInt'>
    readonly custom_test_name: FieldRef<"laboratory_test_details", 'String'>
    readonly instruction: FieldRef<"laboratory_test_details", 'String'>
    readonly test_method: FieldRef<"laboratory_test_details", 'String'>
    readonly status: FieldRef<"laboratory_test_details", 'laboratory_test_details_status'>
    readonly status_changed_by: FieldRef<"laboratory_test_details", 'String'>
    readonly status_changed_on: FieldRef<"laboratory_test_details", 'String'>
    readonly unit: FieldRef<"laboratory_test_details", 'String'>
    readonly reference_range: FieldRef<"laboratory_test_details", 'String'>
    readonly age_gender_specific: FieldRef<"laboratory_test_details", 'String'>
    readonly critical_alert: FieldRef<"laboratory_test_details", 'String'>
    readonly interpretation: FieldRef<"laboratory_test_details", 'String'>
    readonly sort_order: FieldRef<"laboratory_test_details", 'Int'>
    readonly title_required: FieldRef<"laboratory_test_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * laboratory_test_details findUnique
   */
  export type laboratory_test_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_test_details to fetch.
     */
    where: laboratory_test_detailsWhereUniqueInput
  }

  /**
   * laboratory_test_details findUniqueOrThrow
   */
  export type laboratory_test_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_test_details to fetch.
     */
    where: laboratory_test_detailsWhereUniqueInput
  }

  /**
   * laboratory_test_details findFirst
   */
  export type laboratory_test_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_test_details to fetch.
     */
    where?: laboratory_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_test_details to fetch.
     */
    orderBy?: laboratory_test_detailsOrderByWithRelationInput | laboratory_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_test_details.
     */
    cursor?: laboratory_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_test_details.
     */
    distinct?: Laboratory_test_detailsScalarFieldEnum | Laboratory_test_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_test_details findFirstOrThrow
   */
  export type laboratory_test_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_test_details to fetch.
     */
    where?: laboratory_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_test_details to fetch.
     */
    orderBy?: laboratory_test_detailsOrderByWithRelationInput | laboratory_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for laboratory_test_details.
     */
    cursor?: laboratory_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of laboratory_test_details.
     */
    distinct?: Laboratory_test_detailsScalarFieldEnum | Laboratory_test_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_test_details findMany
   */
  export type laboratory_test_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter, which laboratory_test_details to fetch.
     */
    where?: laboratory_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of laboratory_test_details to fetch.
     */
    orderBy?: laboratory_test_detailsOrderByWithRelationInput | laboratory_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing laboratory_test_details.
     */
    cursor?: laboratory_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` laboratory_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` laboratory_test_details.
     */
    skip?: number
    distinct?: Laboratory_test_detailsScalarFieldEnum | Laboratory_test_detailsScalarFieldEnum[]
  }

  /**
   * laboratory_test_details create
   */
  export type laboratory_test_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a laboratory_test_details.
     */
    data: XOR<laboratory_test_detailsCreateInput, laboratory_test_detailsUncheckedCreateInput>
  }

  /**
   * laboratory_test_details createMany
   */
  export type laboratory_test_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many laboratory_test_details.
     */
    data: laboratory_test_detailsCreateManyInput | laboratory_test_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * laboratory_test_details update
   */
  export type laboratory_test_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a laboratory_test_details.
     */
    data: XOR<laboratory_test_detailsUpdateInput, laboratory_test_detailsUncheckedUpdateInput>
    /**
     * Choose, which laboratory_test_details to update.
     */
    where: laboratory_test_detailsWhereUniqueInput
  }

  /**
   * laboratory_test_details updateMany
   */
  export type laboratory_test_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update laboratory_test_details.
     */
    data: XOR<laboratory_test_detailsUpdateManyMutationInput, laboratory_test_detailsUncheckedUpdateManyInput>
    /**
     * Filter which laboratory_test_details to update
     */
    where?: laboratory_test_detailsWhereInput
  }

  /**
   * laboratory_test_details upsert
   */
  export type laboratory_test_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the laboratory_test_details to update in case it exists.
     */
    where: laboratory_test_detailsWhereUniqueInput
    /**
     * In case the laboratory_test_details found by the `where` argument doesn't exist, create a new laboratory_test_details with this data.
     */
    create: XOR<laboratory_test_detailsCreateInput, laboratory_test_detailsUncheckedCreateInput>
    /**
     * In case the laboratory_test_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<laboratory_test_detailsUpdateInput, laboratory_test_detailsUncheckedUpdateInput>
  }

  /**
   * laboratory_test_details delete
   */
  export type laboratory_test_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
    /**
     * Filter which laboratory_test_details to delete.
     */
    where: laboratory_test_detailsWhereUniqueInput
  }

  /**
   * laboratory_test_details deleteMany
   */
  export type laboratory_test_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which laboratory_test_details to delete
     */
    where?: laboratory_test_detailsWhereInput
  }

  /**
   * laboratory_test_details without action
   */
  export type laboratory_test_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the laboratory_test_details
     */
    select?: laboratory_test_detailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: laboratory_test_detailsInclude<ExtArgs> | null
  }


  /**
   * Model locality
   */

  export type AggregateLocality = {
    _count: LocalityCountAggregateOutputType | null
    _avg: LocalityAvgAggregateOutputType | null
    _sum: LocalitySumAggregateOutputType | null
    _min: LocalityMinAggregateOutputType | null
    _max: LocalityMaxAggregateOutputType | null
  }

  export type LocalityAvgAggregateOutputType = {
    locality_id: number | null
    city_id: number | null
    active: number | null
  }

  export type LocalitySumAggregateOutputType = {
    locality_id: number | null
    city_id: number | null
    active: number | null
  }

  export type LocalityMinAggregateOutputType = {
    locality_id: number | null
    locality_name: string | null
    city_id: number | null
    active: number | null
  }

  export type LocalityMaxAggregateOutputType = {
    locality_id: number | null
    locality_name: string | null
    city_id: number | null
    active: number | null
  }

  export type LocalityCountAggregateOutputType = {
    locality_id: number
    locality_name: number
    city_id: number
    active: number
    _all: number
  }


  export type LocalityAvgAggregateInputType = {
    locality_id?: true
    city_id?: true
    active?: true
  }

  export type LocalitySumAggregateInputType = {
    locality_id?: true
    city_id?: true
    active?: true
  }

  export type LocalityMinAggregateInputType = {
    locality_id?: true
    locality_name?: true
    city_id?: true
    active?: true
  }

  export type LocalityMaxAggregateInputType = {
    locality_id?: true
    locality_name?: true
    city_id?: true
    active?: true
  }

  export type LocalityCountAggregateInputType = {
    locality_id?: true
    locality_name?: true
    city_id?: true
    active?: true
    _all?: true
  }

  export type LocalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locality to aggregate.
     */
    where?: localityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localities to fetch.
     */
    orderBy?: localityOrderByWithRelationInput | localityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: localityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned localities
    **/
    _count?: true | LocalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalityMaxAggregateInputType
  }

  export type GetLocalityAggregateType<T extends LocalityAggregateArgs> = {
        [P in keyof T & keyof AggregateLocality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocality[P]>
      : GetScalarType<T[P], AggregateLocality[P]>
  }




  export type localityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localityWhereInput
    orderBy?: localityOrderByWithAggregationInput | localityOrderByWithAggregationInput[]
    by: LocalityScalarFieldEnum[] | LocalityScalarFieldEnum
    having?: localityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalityCountAggregateInputType | true
    _avg?: LocalityAvgAggregateInputType
    _sum?: LocalitySumAggregateInputType
    _min?: LocalityMinAggregateInputType
    _max?: LocalityMaxAggregateInputType
  }

  export type LocalityGroupByOutputType = {
    locality_id: number
    locality_name: string
    city_id: number
    active: number
    _count: LocalityCountAggregateOutputType | null
    _avg: LocalityAvgAggregateOutputType | null
    _sum: LocalitySumAggregateOutputType | null
    _min: LocalityMinAggregateOutputType | null
    _max: LocalityMaxAggregateOutputType | null
  }

  type GetLocalityGroupByPayload<T extends localityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalityGroupByOutputType[P]>
            : GetScalarType<T[P], LocalityGroupByOutputType[P]>
        }
      >
    >


  export type localitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locality_id?: boolean
    locality_name?: boolean
    city_id?: boolean
    active?: boolean
  }, ExtArgs["result"]["locality"]>


  export type localitySelectScalar = {
    locality_id?: boolean
    locality_name?: boolean
    city_id?: boolean
    active?: boolean
  }


  export type $localityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locality"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      locality_id: number
      locality_name: string
      city_id: number
      active: number
    }, ExtArgs["result"]["locality"]>
    composites: {}
  }

  type localityGetPayload<S extends boolean | null | undefined | localityDefaultArgs> = $Result.GetResult<Prisma.$localityPayload, S>

  type localityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<localityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalityCountAggregateInputType | true
    }

  export interface localityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locality'], meta: { name: 'locality' } }
    /**
     * Find zero or one Locality that matches the filter.
     * @param {localityFindUniqueArgs} args - Arguments to find a Locality
     * @example
     * // Get one Locality
     * const locality = await prisma.locality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends localityFindUniqueArgs>(args: SelectSubset<T, localityFindUniqueArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Locality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {localityFindUniqueOrThrowArgs} args - Arguments to find a Locality
     * @example
     * // Get one Locality
     * const locality = await prisma.locality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends localityFindUniqueOrThrowArgs>(args: SelectSubset<T, localityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Locality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityFindFirstArgs} args - Arguments to find a Locality
     * @example
     * // Get one Locality
     * const locality = await prisma.locality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends localityFindFirstArgs>(args?: SelectSubset<T, localityFindFirstArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Locality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityFindFirstOrThrowArgs} args - Arguments to find a Locality
     * @example
     * // Get one Locality
     * const locality = await prisma.locality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends localityFindFirstOrThrowArgs>(args?: SelectSubset<T, localityFindFirstOrThrowArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Localities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Localities
     * const localities = await prisma.locality.findMany()
     * 
     * // Get first 10 Localities
     * const localities = await prisma.locality.findMany({ take: 10 })
     * 
     * // Only select the `locality_id`
     * const localityWithLocality_idOnly = await prisma.locality.findMany({ select: { locality_id: true } })
     * 
     */
    findMany<T extends localityFindManyArgs>(args?: SelectSubset<T, localityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Locality.
     * @param {localityCreateArgs} args - Arguments to create a Locality.
     * @example
     * // Create one Locality
     * const Locality = await prisma.locality.create({
     *   data: {
     *     // ... data to create a Locality
     *   }
     * })
     * 
     */
    create<T extends localityCreateArgs>(args: SelectSubset<T, localityCreateArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Localities.
     * @param {localityCreateManyArgs} args - Arguments to create many Localities.
     * @example
     * // Create many Localities
     * const locality = await prisma.locality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends localityCreateManyArgs>(args?: SelectSubset<T, localityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locality.
     * @param {localityDeleteArgs} args - Arguments to delete one Locality.
     * @example
     * // Delete one Locality
     * const Locality = await prisma.locality.delete({
     *   where: {
     *     // ... filter to delete one Locality
     *   }
     * })
     * 
     */
    delete<T extends localityDeleteArgs>(args: SelectSubset<T, localityDeleteArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Locality.
     * @param {localityUpdateArgs} args - Arguments to update one Locality.
     * @example
     * // Update one Locality
     * const locality = await prisma.locality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends localityUpdateArgs>(args: SelectSubset<T, localityUpdateArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Localities.
     * @param {localityDeleteManyArgs} args - Arguments to filter Localities to delete.
     * @example
     * // Delete a few Localities
     * const { count } = await prisma.locality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends localityDeleteManyArgs>(args?: SelectSubset<T, localityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Localities
     * const locality = await prisma.locality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends localityUpdateManyArgs>(args: SelectSubset<T, localityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locality.
     * @param {localityUpsertArgs} args - Arguments to update or create a Locality.
     * @example
     * // Update or create a Locality
     * const locality = await prisma.locality.upsert({
     *   create: {
     *     // ... data to create a Locality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locality we want to update
     *   }
     * })
     */
    upsert<T extends localityUpsertArgs>(args: SelectSubset<T, localityUpsertArgs<ExtArgs>>): Prisma__localityClient<$Result.GetResult<Prisma.$localityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Localities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityCountArgs} args - Arguments to filter Localities to count.
     * @example
     * // Count the number of Localities
     * const count = await prisma.locality.count({
     *   where: {
     *     // ... the filter for the Localities we want to count
     *   }
     * })
    **/
    count<T extends localityCountArgs>(
      args?: Subset<T, localityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalityAggregateArgs>(args: Subset<T, LocalityAggregateArgs>): Prisma.PrismaPromise<GetLocalityAggregateType<T>>

    /**
     * Group by Locality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends localityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: localityGroupByArgs['orderBy'] }
        : { orderBy?: localityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, localityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locality model
   */
  readonly fields: localityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__localityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locality model
   */ 
  interface localityFieldRefs {
    readonly locality_id: FieldRef<"locality", 'Int'>
    readonly locality_name: FieldRef<"locality", 'String'>
    readonly city_id: FieldRef<"locality", 'Int'>
    readonly active: FieldRef<"locality", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * locality findUnique
   */
  export type localityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter, which locality to fetch.
     */
    where: localityWhereUniqueInput
  }

  /**
   * locality findUniqueOrThrow
   */
  export type localityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter, which locality to fetch.
     */
    where: localityWhereUniqueInput
  }

  /**
   * locality findFirst
   */
  export type localityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter, which locality to fetch.
     */
    where?: localityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localities to fetch.
     */
    orderBy?: localityOrderByWithRelationInput | localityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localities.
     */
    cursor?: localityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localities.
     */
    distinct?: LocalityScalarFieldEnum | LocalityScalarFieldEnum[]
  }

  /**
   * locality findFirstOrThrow
   */
  export type localityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter, which locality to fetch.
     */
    where?: localityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localities to fetch.
     */
    orderBy?: localityOrderByWithRelationInput | localityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localities.
     */
    cursor?: localityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localities.
     */
    distinct?: LocalityScalarFieldEnum | LocalityScalarFieldEnum[]
  }

  /**
   * locality findMany
   */
  export type localityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter, which localities to fetch.
     */
    where?: localityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localities to fetch.
     */
    orderBy?: localityOrderByWithRelationInput | localityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing localities.
     */
    cursor?: localityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localities.
     */
    skip?: number
    distinct?: LocalityScalarFieldEnum | LocalityScalarFieldEnum[]
  }

  /**
   * locality create
   */
  export type localityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * The data needed to create a locality.
     */
    data: XOR<localityCreateInput, localityUncheckedCreateInput>
  }

  /**
   * locality createMany
   */
  export type localityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many localities.
     */
    data: localityCreateManyInput | localityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locality update
   */
  export type localityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * The data needed to update a locality.
     */
    data: XOR<localityUpdateInput, localityUncheckedUpdateInput>
    /**
     * Choose, which locality to update.
     */
    where: localityWhereUniqueInput
  }

  /**
   * locality updateMany
   */
  export type localityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update localities.
     */
    data: XOR<localityUpdateManyMutationInput, localityUncheckedUpdateManyInput>
    /**
     * Filter which localities to update
     */
    where?: localityWhereInput
  }

  /**
   * locality upsert
   */
  export type localityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * The filter to search for the locality to update in case it exists.
     */
    where: localityWhereUniqueInput
    /**
     * In case the locality found by the `where` argument doesn't exist, create a new locality with this data.
     */
    create: XOR<localityCreateInput, localityUncheckedCreateInput>
    /**
     * In case the locality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<localityUpdateInput, localityUncheckedUpdateInput>
  }

  /**
   * locality delete
   */
  export type localityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
    /**
     * Filter which locality to delete.
     */
    where: localityWhereUniqueInput
  }

  /**
   * locality deleteMany
   */
  export type localityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localities to delete
     */
    where?: localityWhereInput
  }

  /**
   * locality without action
   */
  export type localityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locality
     */
    select?: localitySelect<ExtArgs> | null
  }


  /**
   * Model login_details
   */

  export type AggregateLogin_details = {
    _count: Login_detailsCountAggregateOutputType | null
    _avg: Login_detailsAvgAggregateOutputType | null
    _sum: Login_detailsSumAggregateOutputType | null
    _min: Login_detailsMinAggregateOutputType | null
    _max: Login_detailsMaxAggregateOutputType | null
  }

  export type Login_detailsAvgAggregateOutputType = {
    login_id: number | null
    physician_id: number | null
    laboratory_id: number | null
    patient_id: number | null
    phy_admin_id: number | null
    state: number | null
    city: number | null
    count: number | null
    role_id: number | null
    active: number | null
    otp: number | null
  }

  export type Login_detailsSumAggregateOutputType = {
    login_id: number | null
    physician_id: number | null
    laboratory_id: number | null
    patient_id: number | null
    phy_admin_id: number | null
    state: number | null
    city: number | null
    count: number | null
    role_id: number | null
    active: number | null
    otp: number | null
  }

  export type Login_detailsMinAggregateOutputType = {
    login_id: number | null
    firstname: string | null
    physician_id: number | null
    laboratory_id: number | null
    patient_id: number | null
    phy_admin_id: number | null
    username: string | null
    password: string | null
    phone_num: string | null
    state: number | null
    city: number | null
    count: number | null
    role_id: number | null
    active: number | null
    last_login: Date | null
    created_on: Date | null
    updated_on: Date | null
    otp: number | null
    device_id: string | null
    player_id: string | null
  }

  export type Login_detailsMaxAggregateOutputType = {
    login_id: number | null
    firstname: string | null
    physician_id: number | null
    laboratory_id: number | null
    patient_id: number | null
    phy_admin_id: number | null
    username: string | null
    password: string | null
    phone_num: string | null
    state: number | null
    city: number | null
    count: number | null
    role_id: number | null
    active: number | null
    last_login: Date | null
    created_on: Date | null
    updated_on: Date | null
    otp: number | null
    device_id: string | null
    player_id: string | null
  }

  export type Login_detailsCountAggregateOutputType = {
    login_id: number
    firstname: number
    physician_id: number
    laboratory_id: number
    patient_id: number
    phy_admin_id: number
    username: number
    password: number
    phone_num: number
    state: number
    city: number
    count: number
    role_id: number
    active: number
    last_login: number
    created_on: number
    updated_on: number
    otp: number
    device_id: number
    player_id: number
    _all: number
  }


  export type Login_detailsAvgAggregateInputType = {
    login_id?: true
    physician_id?: true
    laboratory_id?: true
    patient_id?: true
    phy_admin_id?: true
    state?: true
    city?: true
    count?: true
    role_id?: true
    active?: true
    otp?: true
  }

  export type Login_detailsSumAggregateInputType = {
    login_id?: true
    physician_id?: true
    laboratory_id?: true
    patient_id?: true
    phy_admin_id?: true
    state?: true
    city?: true
    count?: true
    role_id?: true
    active?: true
    otp?: true
  }

  export type Login_detailsMinAggregateInputType = {
    login_id?: true
    firstname?: true
    physician_id?: true
    laboratory_id?: true
    patient_id?: true
    phy_admin_id?: true
    username?: true
    password?: true
    phone_num?: true
    state?: true
    city?: true
    count?: true
    role_id?: true
    active?: true
    last_login?: true
    created_on?: true
    updated_on?: true
    otp?: true
    device_id?: true
    player_id?: true
  }

  export type Login_detailsMaxAggregateInputType = {
    login_id?: true
    firstname?: true
    physician_id?: true
    laboratory_id?: true
    patient_id?: true
    phy_admin_id?: true
    username?: true
    password?: true
    phone_num?: true
    state?: true
    city?: true
    count?: true
    role_id?: true
    active?: true
    last_login?: true
    created_on?: true
    updated_on?: true
    otp?: true
    device_id?: true
    player_id?: true
  }

  export type Login_detailsCountAggregateInputType = {
    login_id?: true
    firstname?: true
    physician_id?: true
    laboratory_id?: true
    patient_id?: true
    phy_admin_id?: true
    username?: true
    password?: true
    phone_num?: true
    state?: true
    city?: true
    count?: true
    role_id?: true
    active?: true
    last_login?: true
    created_on?: true
    updated_on?: true
    otp?: true
    device_id?: true
    player_id?: true
    _all?: true
  }

  export type Login_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_details to aggregate.
     */
    where?: login_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_details to fetch.
     */
    orderBy?: login_detailsOrderByWithRelationInput | login_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: login_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned login_details
    **/
    _count?: true | Login_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Login_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Login_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Login_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Login_detailsMaxAggregateInputType
  }

  export type GetLogin_detailsAggregateType<T extends Login_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin_details[P]>
      : GetScalarType<T[P], AggregateLogin_details[P]>
  }




  export type login_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: login_detailsWhereInput
    orderBy?: login_detailsOrderByWithAggregationInput | login_detailsOrderByWithAggregationInput[]
    by: Login_detailsScalarFieldEnum[] | Login_detailsScalarFieldEnum
    having?: login_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Login_detailsCountAggregateInputType | true
    _avg?: Login_detailsAvgAggregateInputType
    _sum?: Login_detailsSumAggregateInputType
    _min?: Login_detailsMinAggregateInputType
    _max?: Login_detailsMaxAggregateInputType
  }

  export type Login_detailsGroupByOutputType = {
    login_id: number
    firstname: string
    physician_id: number | null
    laboratory_id: number | null
    patient_id: number | null
    phy_admin_id: number | null
    username: string
    password: string
    phone_num: string
    state: number
    city: number
    count: number
    role_id: number
    active: number
    last_login: Date | null
    created_on: Date
    updated_on: Date
    otp: number
    device_id: string
    player_id: string
    _count: Login_detailsCountAggregateOutputType | null
    _avg: Login_detailsAvgAggregateOutputType | null
    _sum: Login_detailsSumAggregateOutputType | null
    _min: Login_detailsMinAggregateOutputType | null
    _max: Login_detailsMaxAggregateOutputType | null
  }

  type GetLogin_detailsGroupByPayload<T extends login_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Login_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Login_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Login_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Login_detailsGroupByOutputType[P]>
        }
      >
    >


  export type login_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    login_id?: boolean
    firstname?: boolean
    physician_id?: boolean
    laboratory_id?: boolean
    patient_id?: boolean
    phy_admin_id?: boolean
    username?: boolean
    password?: boolean
    phone_num?: boolean
    state?: boolean
    city?: boolean
    count?: boolean
    role_id?: boolean
    active?: boolean
    last_login?: boolean
    created_on?: boolean
    updated_on?: boolean
    otp?: boolean
    device_id?: boolean
    player_id?: boolean
  }, ExtArgs["result"]["login_details"]>


  export type login_detailsSelectScalar = {
    login_id?: boolean
    firstname?: boolean
    physician_id?: boolean
    laboratory_id?: boolean
    patient_id?: boolean
    phy_admin_id?: boolean
    username?: boolean
    password?: boolean
    phone_num?: boolean
    state?: boolean
    city?: boolean
    count?: boolean
    role_id?: boolean
    active?: boolean
    last_login?: boolean
    created_on?: boolean
    updated_on?: boolean
    otp?: boolean
    device_id?: boolean
    player_id?: boolean
  }


  export type $login_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "login_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      login_id: number
      firstname: string
      physician_id: number | null
      laboratory_id: number | null
      patient_id: number | null
      phy_admin_id: number | null
      username: string
      password: string
      phone_num: string
      state: number
      city: number
      count: number
      role_id: number
      active: number
      last_login: Date | null
      created_on: Date
      updated_on: Date
      otp: number
      device_id: string
      player_id: string
    }, ExtArgs["result"]["login_details"]>
    composites: {}
  }

  type login_detailsGetPayload<S extends boolean | null | undefined | login_detailsDefaultArgs> = $Result.GetResult<Prisma.$login_detailsPayload, S>

  type login_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<login_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Login_detailsCountAggregateInputType | true
    }

  export interface login_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['login_details'], meta: { name: 'login_details' } }
    /**
     * Find zero or one Login_details that matches the filter.
     * @param {login_detailsFindUniqueArgs} args - Arguments to find a Login_details
     * @example
     * // Get one Login_details
     * const login_details = await prisma.login_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends login_detailsFindUniqueArgs>(args: SelectSubset<T, login_detailsFindUniqueArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Login_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {login_detailsFindUniqueOrThrowArgs} args - Arguments to find a Login_details
     * @example
     * // Get one Login_details
     * const login_details = await prisma.login_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends login_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, login_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Login_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsFindFirstArgs} args - Arguments to find a Login_details
     * @example
     * // Get one Login_details
     * const login_details = await prisma.login_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends login_detailsFindFirstArgs>(args?: SelectSubset<T, login_detailsFindFirstArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Login_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsFindFirstOrThrowArgs} args - Arguments to find a Login_details
     * @example
     * // Get one Login_details
     * const login_details = await prisma.login_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends login_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, login_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Login_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Login_details
     * const login_details = await prisma.login_details.findMany()
     * 
     * // Get first 10 Login_details
     * const login_details = await prisma.login_details.findMany({ take: 10 })
     * 
     * // Only select the `login_id`
     * const login_detailsWithLogin_idOnly = await prisma.login_details.findMany({ select: { login_id: true } })
     * 
     */
    findMany<T extends login_detailsFindManyArgs>(args?: SelectSubset<T, login_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Login_details.
     * @param {login_detailsCreateArgs} args - Arguments to create a Login_details.
     * @example
     * // Create one Login_details
     * const Login_details = await prisma.login_details.create({
     *   data: {
     *     // ... data to create a Login_details
     *   }
     * })
     * 
     */
    create<T extends login_detailsCreateArgs>(args: SelectSubset<T, login_detailsCreateArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Login_details.
     * @param {login_detailsCreateManyArgs} args - Arguments to create many Login_details.
     * @example
     * // Create many Login_details
     * const login_details = await prisma.login_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends login_detailsCreateManyArgs>(args?: SelectSubset<T, login_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Login_details.
     * @param {login_detailsDeleteArgs} args - Arguments to delete one Login_details.
     * @example
     * // Delete one Login_details
     * const Login_details = await prisma.login_details.delete({
     *   where: {
     *     // ... filter to delete one Login_details
     *   }
     * })
     * 
     */
    delete<T extends login_detailsDeleteArgs>(args: SelectSubset<T, login_detailsDeleteArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Login_details.
     * @param {login_detailsUpdateArgs} args - Arguments to update one Login_details.
     * @example
     * // Update one Login_details
     * const login_details = await prisma.login_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends login_detailsUpdateArgs>(args: SelectSubset<T, login_detailsUpdateArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Login_details.
     * @param {login_detailsDeleteManyArgs} args - Arguments to filter Login_details to delete.
     * @example
     * // Delete a few Login_details
     * const { count } = await prisma.login_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends login_detailsDeleteManyArgs>(args?: SelectSubset<T, login_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Login_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Login_details
     * const login_details = await prisma.login_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends login_detailsUpdateManyArgs>(args: SelectSubset<T, login_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login_details.
     * @param {login_detailsUpsertArgs} args - Arguments to update or create a Login_details.
     * @example
     * // Update or create a Login_details
     * const login_details = await prisma.login_details.upsert({
     *   create: {
     *     // ... data to create a Login_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login_details we want to update
     *   }
     * })
     */
    upsert<T extends login_detailsUpsertArgs>(args: SelectSubset<T, login_detailsUpsertArgs<ExtArgs>>): Prisma__login_detailsClient<$Result.GetResult<Prisma.$login_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Login_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsCountArgs} args - Arguments to filter Login_details to count.
     * @example
     * // Count the number of Login_details
     * const count = await prisma.login_details.count({
     *   where: {
     *     // ... the filter for the Login_details we want to count
     *   }
     * })
    **/
    count<T extends login_detailsCountArgs>(
      args?: Subset<T, login_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Login_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Login_detailsAggregateArgs>(args: Subset<T, Login_detailsAggregateArgs>): Prisma.PrismaPromise<GetLogin_detailsAggregateType<T>>

    /**
     * Group by Login_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends login_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: login_detailsGroupByArgs['orderBy'] }
        : { orderBy?: login_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, login_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogin_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the login_details model
   */
  readonly fields: login_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for login_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__login_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the login_details model
   */ 
  interface login_detailsFieldRefs {
    readonly login_id: FieldRef<"login_details", 'Int'>
    readonly firstname: FieldRef<"login_details", 'String'>
    readonly physician_id: FieldRef<"login_details", 'Int'>
    readonly laboratory_id: FieldRef<"login_details", 'Int'>
    readonly patient_id: FieldRef<"login_details", 'Int'>
    readonly phy_admin_id: FieldRef<"login_details", 'Int'>
    readonly username: FieldRef<"login_details", 'String'>
    readonly password: FieldRef<"login_details", 'String'>
    readonly phone_num: FieldRef<"login_details", 'String'>
    readonly state: FieldRef<"login_details", 'Int'>
    readonly city: FieldRef<"login_details", 'Int'>
    readonly count: FieldRef<"login_details", 'Int'>
    readonly role_id: FieldRef<"login_details", 'Int'>
    readonly active: FieldRef<"login_details", 'Int'>
    readonly last_login: FieldRef<"login_details", 'DateTime'>
    readonly created_on: FieldRef<"login_details", 'DateTime'>
    readonly updated_on: FieldRef<"login_details", 'DateTime'>
    readonly otp: FieldRef<"login_details", 'Int'>
    readonly device_id: FieldRef<"login_details", 'String'>
    readonly player_id: FieldRef<"login_details", 'String'>
  }
    

  // Custom InputTypes
  /**
   * login_details findUnique
   */
  export type login_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter, which login_details to fetch.
     */
    where: login_detailsWhereUniqueInput
  }

  /**
   * login_details findUniqueOrThrow
   */
  export type login_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter, which login_details to fetch.
     */
    where: login_detailsWhereUniqueInput
  }

  /**
   * login_details findFirst
   */
  export type login_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter, which login_details to fetch.
     */
    where?: login_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_details to fetch.
     */
    orderBy?: login_detailsOrderByWithRelationInput | login_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_details.
     */
    cursor?: login_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_details.
     */
    distinct?: Login_detailsScalarFieldEnum | Login_detailsScalarFieldEnum[]
  }

  /**
   * login_details findFirstOrThrow
   */
  export type login_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter, which login_details to fetch.
     */
    where?: login_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_details to fetch.
     */
    orderBy?: login_detailsOrderByWithRelationInput | login_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_details.
     */
    cursor?: login_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_details.
     */
    distinct?: Login_detailsScalarFieldEnum | Login_detailsScalarFieldEnum[]
  }

  /**
   * login_details findMany
   */
  export type login_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter, which login_details to fetch.
     */
    where?: login_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_details to fetch.
     */
    orderBy?: login_detailsOrderByWithRelationInput | login_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing login_details.
     */
    cursor?: login_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_details.
     */
    skip?: number
    distinct?: Login_detailsScalarFieldEnum | Login_detailsScalarFieldEnum[]
  }

  /**
   * login_details create
   */
  export type login_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a login_details.
     */
    data: XOR<login_detailsCreateInput, login_detailsUncheckedCreateInput>
  }

  /**
   * login_details createMany
   */
  export type login_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many login_details.
     */
    data: login_detailsCreateManyInput | login_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * login_details update
   */
  export type login_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a login_details.
     */
    data: XOR<login_detailsUpdateInput, login_detailsUncheckedUpdateInput>
    /**
     * Choose, which login_details to update.
     */
    where: login_detailsWhereUniqueInput
  }

  /**
   * login_details updateMany
   */
  export type login_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update login_details.
     */
    data: XOR<login_detailsUpdateManyMutationInput, login_detailsUncheckedUpdateManyInput>
    /**
     * Filter which login_details to update
     */
    where?: login_detailsWhereInput
  }

  /**
   * login_details upsert
   */
  export type login_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the login_details to update in case it exists.
     */
    where: login_detailsWhereUniqueInput
    /**
     * In case the login_details found by the `where` argument doesn't exist, create a new login_details with this data.
     */
    create: XOR<login_detailsCreateInput, login_detailsUncheckedCreateInput>
    /**
     * In case the login_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<login_detailsUpdateInput, login_detailsUncheckedUpdateInput>
  }

  /**
   * login_details delete
   */
  export type login_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
    /**
     * Filter which login_details to delete.
     */
    where: login_detailsWhereUniqueInput
  }

  /**
   * login_details deleteMany
   */
  export type login_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_details to delete
     */
    where?: login_detailsWhereInput
  }

  /**
   * login_details without action
   */
  export type login_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_details
     */
    select?: login_detailsSelect<ExtArgs> | null
  }


  /**
   * Model medicine
   */

  export type AggregateMedicine = {
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  export type MedicineAvgAggregateOutputType = {
    ID: number | null
    active: number | null
  }

  export type MedicineSumAggregateOutputType = {
    ID: number | null
    active: number | null
  }

  export type MedicineMinAggregateOutputType = {
    ID: number | null
    medicine_name: string | null
    active: number | null
  }

  export type MedicineMaxAggregateOutputType = {
    ID: number | null
    medicine_name: string | null
    active: number | null
  }

  export type MedicineCountAggregateOutputType = {
    ID: number
    medicine_name: number
    active: number
    _all: number
  }


  export type MedicineAvgAggregateInputType = {
    ID?: true
    active?: true
  }

  export type MedicineSumAggregateInputType = {
    ID?: true
    active?: true
  }

  export type MedicineMinAggregateInputType = {
    ID?: true
    medicine_name?: true
    active?: true
  }

  export type MedicineMaxAggregateInputType = {
    ID?: true
    medicine_name?: true
    active?: true
  }

  export type MedicineCountAggregateInputType = {
    ID?: true
    medicine_name?: true
    active?: true
    _all?: true
  }

  export type MedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicine to aggregate.
     */
    where?: medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicines to fetch.
     */
    orderBy?: medicineOrderByWithRelationInput | medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicines
    **/
    _count?: true | MedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineMaxAggregateInputType
  }

  export type GetMedicineAggregateType<T extends MedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicine[P]>
      : GetScalarType<T[P], AggregateMedicine[P]>
  }




  export type medicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicineWhereInput
    orderBy?: medicineOrderByWithAggregationInput | medicineOrderByWithAggregationInput[]
    by: MedicineScalarFieldEnum[] | MedicineScalarFieldEnum
    having?: medicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineCountAggregateInputType | true
    _avg?: MedicineAvgAggregateInputType
    _sum?: MedicineSumAggregateInputType
    _min?: MedicineMinAggregateInputType
    _max?: MedicineMaxAggregateInputType
  }

  export type MedicineGroupByOutputType = {
    ID: number
    medicine_name: string
    active: number
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  type GetMedicineGroupByPayload<T extends medicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineGroupByOutputType[P]>
        }
      >
    >


  export type medicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    medicine_name?: boolean
    active?: boolean
  }, ExtArgs["result"]["medicine"]>


  export type medicineSelectScalar = {
    ID?: boolean
    medicine_name?: boolean
    active?: boolean
  }


  export type $medicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicine"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      medicine_name: string
      active: number
    }, ExtArgs["result"]["medicine"]>
    composites: {}
  }

  type medicineGetPayload<S extends boolean | null | undefined | medicineDefaultArgs> = $Result.GetResult<Prisma.$medicinePayload, S>

  type medicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medicineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicineCountAggregateInputType | true
    }

  export interface medicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicine'], meta: { name: 'medicine' } }
    /**
     * Find zero or one Medicine that matches the filter.
     * @param {medicineFindUniqueArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicineFindUniqueArgs>(args: SelectSubset<T, medicineFindUniqueArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medicineFindUniqueOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicineFindUniqueOrThrowArgs>(args: SelectSubset<T, medicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineFindFirstArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicineFindFirstArgs>(args?: SelectSubset<T, medicineFindFirstArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineFindFirstOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicineFindFirstOrThrowArgs>(args?: SelectSubset<T, medicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicines
     * const medicines = await prisma.medicine.findMany()
     * 
     * // Get first 10 Medicines
     * const medicines = await prisma.medicine.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const medicineWithIDOnly = await prisma.medicine.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends medicineFindManyArgs>(args?: SelectSubset<T, medicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicine.
     * @param {medicineCreateArgs} args - Arguments to create a Medicine.
     * @example
     * // Create one Medicine
     * const Medicine = await prisma.medicine.create({
     *   data: {
     *     // ... data to create a Medicine
     *   }
     * })
     * 
     */
    create<T extends medicineCreateArgs>(args: SelectSubset<T, medicineCreateArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicines.
     * @param {medicineCreateManyArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicineCreateManyArgs>(args?: SelectSubset<T, medicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medicine.
     * @param {medicineDeleteArgs} args - Arguments to delete one Medicine.
     * @example
     * // Delete one Medicine
     * const Medicine = await prisma.medicine.delete({
     *   where: {
     *     // ... filter to delete one Medicine
     *   }
     * })
     * 
     */
    delete<T extends medicineDeleteArgs>(args: SelectSubset<T, medicineDeleteArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicine.
     * @param {medicineUpdateArgs} args - Arguments to update one Medicine.
     * @example
     * // Update one Medicine
     * const medicine = await prisma.medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicineUpdateArgs>(args: SelectSubset<T, medicineUpdateArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicines.
     * @param {medicineDeleteManyArgs} args - Arguments to filter Medicines to delete.
     * @example
     * // Delete a few Medicines
     * const { count } = await prisma.medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicineDeleteManyArgs>(args?: SelectSubset<T, medicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicineUpdateManyArgs>(args: SelectSubset<T, medicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicine.
     * @param {medicineUpsertArgs} args - Arguments to update or create a Medicine.
     * @example
     * // Update or create a Medicine
     * const medicine = await prisma.medicine.upsert({
     *   create: {
     *     // ... data to create a Medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicine we want to update
     *   }
     * })
     */
    upsert<T extends medicineUpsertArgs>(args: SelectSubset<T, medicineUpsertArgs<ExtArgs>>): Prisma__medicineClient<$Result.GetResult<Prisma.$medicinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineCountArgs} args - Arguments to filter Medicines to count.
     * @example
     * // Count the number of Medicines
     * const count = await prisma.medicine.count({
     *   where: {
     *     // ... the filter for the Medicines we want to count
     *   }
     * })
    **/
    count<T extends medicineCountArgs>(
      args?: Subset<T, medicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAggregateArgs>(args: Subset<T, MedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicineAggregateType<T>>

    /**
     * Group by Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicineGroupByArgs['orderBy'] }
        : { orderBy?: medicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicine model
   */
  readonly fields: medicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicine model
   */ 
  interface medicineFieldRefs {
    readonly ID: FieldRef<"medicine", 'Int'>
    readonly medicine_name: FieldRef<"medicine", 'String'>
    readonly active: FieldRef<"medicine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * medicine findUnique
   */
  export type medicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter, which medicine to fetch.
     */
    where: medicineWhereUniqueInput
  }

  /**
   * medicine findUniqueOrThrow
   */
  export type medicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter, which medicine to fetch.
     */
    where: medicineWhereUniqueInput
  }

  /**
   * medicine findFirst
   */
  export type medicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter, which medicine to fetch.
     */
    where?: medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicines to fetch.
     */
    orderBy?: medicineOrderByWithRelationInput | medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicines.
     */
    cursor?: medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * medicine findFirstOrThrow
   */
  export type medicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter, which medicine to fetch.
     */
    where?: medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicines to fetch.
     */
    orderBy?: medicineOrderByWithRelationInput | medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicines.
     */
    cursor?: medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * medicine findMany
   */
  export type medicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter, which medicines to fetch.
     */
    where?: medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicines to fetch.
     */
    orderBy?: medicineOrderByWithRelationInput | medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicines.
     */
    cursor?: medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicines.
     */
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * medicine create
   */
  export type medicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * The data needed to create a medicine.
     */
    data: XOR<medicineCreateInput, medicineUncheckedCreateInput>
  }

  /**
   * medicine createMany
   */
  export type medicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicines.
     */
    data: medicineCreateManyInput | medicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicine update
   */
  export type medicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * The data needed to update a medicine.
     */
    data: XOR<medicineUpdateInput, medicineUncheckedUpdateInput>
    /**
     * Choose, which medicine to update.
     */
    where: medicineWhereUniqueInput
  }

  /**
   * medicine updateMany
   */
  export type medicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicines.
     */
    data: XOR<medicineUpdateManyMutationInput, medicineUncheckedUpdateManyInput>
    /**
     * Filter which medicines to update
     */
    where?: medicineWhereInput
  }

  /**
   * medicine upsert
   */
  export type medicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * The filter to search for the medicine to update in case it exists.
     */
    where: medicineWhereUniqueInput
    /**
     * In case the medicine found by the `where` argument doesn't exist, create a new medicine with this data.
     */
    create: XOR<medicineCreateInput, medicineUncheckedCreateInput>
    /**
     * In case the medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicineUpdateInput, medicineUncheckedUpdateInput>
  }

  /**
   * medicine delete
   */
  export type medicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
    /**
     * Filter which medicine to delete.
     */
    where: medicineWhereUniqueInput
  }

  /**
   * medicine deleteMany
   */
  export type medicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicines to delete
     */
    where?: medicineWhereInput
  }

  /**
   * medicine without action
   */
  export type medicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicine
     */
    select?: medicineSelect<ExtArgs> | null
  }


  /**
   * Model notification_keys
   */

  export type AggregateNotification_keys = {
    _count: Notification_keysCountAggregateOutputType | null
    _avg: Notification_keysAvgAggregateOutputType | null
    _sum: Notification_keysSumAggregateOutputType | null
    _min: Notification_keysMinAggregateOutputType | null
    _max: Notification_keysMaxAggregateOutputType | null
  }

  export type Notification_keysAvgAggregateOutputType = {
    notification_keys_id: number | null
  }

  export type Notification_keysSumAggregateOutputType = {
    notification_keys_id: number | null
  }

  export type Notification_keysMinAggregateOutputType = {
    notification_keys_id: number | null
    app_id: string | null
    rest_api_key: string | null
  }

  export type Notification_keysMaxAggregateOutputType = {
    notification_keys_id: number | null
    app_id: string | null
    rest_api_key: string | null
  }

  export type Notification_keysCountAggregateOutputType = {
    notification_keys_id: number
    app_id: number
    rest_api_key: number
    _all: number
  }


  export type Notification_keysAvgAggregateInputType = {
    notification_keys_id?: true
  }

  export type Notification_keysSumAggregateInputType = {
    notification_keys_id?: true
  }

  export type Notification_keysMinAggregateInputType = {
    notification_keys_id?: true
    app_id?: true
    rest_api_key?: true
  }

  export type Notification_keysMaxAggregateInputType = {
    notification_keys_id?: true
    app_id?: true
    rest_api_key?: true
  }

  export type Notification_keysCountAggregateInputType = {
    notification_keys_id?: true
    app_id?: true
    rest_api_key?: true
    _all?: true
  }

  export type Notification_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_keys to aggregate.
     */
    where?: notification_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_keys to fetch.
     */
    orderBy?: notification_keysOrderByWithRelationInput | notification_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_keys
    **/
    _count?: true | Notification_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Notification_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Notification_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_keysMaxAggregateInputType
  }

  export type GetNotification_keysAggregateType<T extends Notification_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_keys[P]>
      : GetScalarType<T[P], AggregateNotification_keys[P]>
  }




  export type notification_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_keysWhereInput
    orderBy?: notification_keysOrderByWithAggregationInput | notification_keysOrderByWithAggregationInput[]
    by: Notification_keysScalarFieldEnum[] | Notification_keysScalarFieldEnum
    having?: notification_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_keysCountAggregateInputType | true
    _avg?: Notification_keysAvgAggregateInputType
    _sum?: Notification_keysSumAggregateInputType
    _min?: Notification_keysMinAggregateInputType
    _max?: Notification_keysMaxAggregateInputType
  }

  export type Notification_keysGroupByOutputType = {
    notification_keys_id: number
    app_id: string
    rest_api_key: string
    _count: Notification_keysCountAggregateOutputType | null
    _avg: Notification_keysAvgAggregateOutputType | null
    _sum: Notification_keysSumAggregateOutputType | null
    _min: Notification_keysMinAggregateOutputType | null
    _max: Notification_keysMaxAggregateOutputType | null
  }

  type GetNotification_keysGroupByPayload<T extends notification_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_keysGroupByOutputType[P]>
        }
      >
    >


  export type notification_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    notification_keys_id?: boolean
    app_id?: boolean
    rest_api_key?: boolean
  }, ExtArgs["result"]["notification_keys"]>


  export type notification_keysSelectScalar = {
    notification_keys_id?: boolean
    app_id?: boolean
    rest_api_key?: boolean
  }


  export type $notification_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_keys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      notification_keys_id: number
      app_id: string
      rest_api_key: string
    }, ExtArgs["result"]["notification_keys"]>
    composites: {}
  }

  type notification_keysGetPayload<S extends boolean | null | undefined | notification_keysDefaultArgs> = $Result.GetResult<Prisma.$notification_keysPayload, S>

  type notification_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notification_keysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Notification_keysCountAggregateInputType | true
    }

  export interface notification_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_keys'], meta: { name: 'notification_keys' } }
    /**
     * Find zero or one Notification_keys that matches the filter.
     * @param {notification_keysFindUniqueArgs} args - Arguments to find a Notification_keys
     * @example
     * // Get one Notification_keys
     * const notification_keys = await prisma.notification_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_keysFindUniqueArgs>(args: SelectSubset<T, notification_keysFindUniqueArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification_keys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notification_keysFindUniqueOrThrowArgs} args - Arguments to find a Notification_keys
     * @example
     * // Get one Notification_keys
     * const notification_keys = await prisma.notification_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysFindFirstArgs} args - Arguments to find a Notification_keys
     * @example
     * // Get one Notification_keys
     * const notification_keys = await prisma.notification_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_keysFindFirstArgs>(args?: SelectSubset<T, notification_keysFindFirstArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysFindFirstOrThrowArgs} args - Arguments to find a Notification_keys
     * @example
     * // Get one Notification_keys
     * const notification_keys = await prisma.notification_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notification_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_keys
     * const notification_keys = await prisma.notification_keys.findMany()
     * 
     * // Get first 10 Notification_keys
     * const notification_keys = await prisma.notification_keys.findMany({ take: 10 })
     * 
     * // Only select the `notification_keys_id`
     * const notification_keysWithNotification_keys_idOnly = await prisma.notification_keys.findMany({ select: { notification_keys_id: true } })
     * 
     */
    findMany<T extends notification_keysFindManyArgs>(args?: SelectSubset<T, notification_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification_keys.
     * @param {notification_keysCreateArgs} args - Arguments to create a Notification_keys.
     * @example
     * // Create one Notification_keys
     * const Notification_keys = await prisma.notification_keys.create({
     *   data: {
     *     // ... data to create a Notification_keys
     *   }
     * })
     * 
     */
    create<T extends notification_keysCreateArgs>(args: SelectSubset<T, notification_keysCreateArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notification_keys.
     * @param {notification_keysCreateManyArgs} args - Arguments to create many Notification_keys.
     * @example
     * // Create many Notification_keys
     * const notification_keys = await prisma.notification_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_keysCreateManyArgs>(args?: SelectSubset<T, notification_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification_keys.
     * @param {notification_keysDeleteArgs} args - Arguments to delete one Notification_keys.
     * @example
     * // Delete one Notification_keys
     * const Notification_keys = await prisma.notification_keys.delete({
     *   where: {
     *     // ... filter to delete one Notification_keys
     *   }
     * })
     * 
     */
    delete<T extends notification_keysDeleteArgs>(args: SelectSubset<T, notification_keysDeleteArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification_keys.
     * @param {notification_keysUpdateArgs} args - Arguments to update one Notification_keys.
     * @example
     * // Update one Notification_keys
     * const notification_keys = await prisma.notification_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_keysUpdateArgs>(args: SelectSubset<T, notification_keysUpdateArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notification_keys.
     * @param {notification_keysDeleteManyArgs} args - Arguments to filter Notification_keys to delete.
     * @example
     * // Delete a few Notification_keys
     * const { count } = await prisma.notification_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_keysDeleteManyArgs>(args?: SelectSubset<T, notification_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_keys
     * const notification_keys = await prisma.notification_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_keysUpdateManyArgs>(args: SelectSubset<T, notification_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification_keys.
     * @param {notification_keysUpsertArgs} args - Arguments to update or create a Notification_keys.
     * @example
     * // Update or create a Notification_keys
     * const notification_keys = await prisma.notification_keys.upsert({
     *   create: {
     *     // ... data to create a Notification_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_keys we want to update
     *   }
     * })
     */
    upsert<T extends notification_keysUpsertArgs>(args: SelectSubset<T, notification_keysUpsertArgs<ExtArgs>>): Prisma__notification_keysClient<$Result.GetResult<Prisma.$notification_keysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notification_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysCountArgs} args - Arguments to filter Notification_keys to count.
     * @example
     * // Count the number of Notification_keys
     * const count = await prisma.notification_keys.count({
     *   where: {
     *     // ... the filter for the Notification_keys we want to count
     *   }
     * })
    **/
    count<T extends notification_keysCountArgs>(
      args?: Subset<T, notification_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_keysAggregateArgs>(args: Subset<T, Notification_keysAggregateArgs>): Prisma.PrismaPromise<GetNotification_keysAggregateType<T>>

    /**
     * Group by Notification_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_keysGroupByArgs['orderBy'] }
        : { orderBy?: notification_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_keys model
   */
  readonly fields: notification_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_keys model
   */ 
  interface notification_keysFieldRefs {
    readonly notification_keys_id: FieldRef<"notification_keys", 'Int'>
    readonly app_id: FieldRef<"notification_keys", 'String'>
    readonly rest_api_key: FieldRef<"notification_keys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification_keys findUnique
   */
  export type notification_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter, which notification_keys to fetch.
     */
    where: notification_keysWhereUniqueInput
  }

  /**
   * notification_keys findUniqueOrThrow
   */
  export type notification_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter, which notification_keys to fetch.
     */
    where: notification_keysWhereUniqueInput
  }

  /**
   * notification_keys findFirst
   */
  export type notification_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter, which notification_keys to fetch.
     */
    where?: notification_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_keys to fetch.
     */
    orderBy?: notification_keysOrderByWithRelationInput | notification_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_keys.
     */
    cursor?: notification_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_keys.
     */
    distinct?: Notification_keysScalarFieldEnum | Notification_keysScalarFieldEnum[]
  }

  /**
   * notification_keys findFirstOrThrow
   */
  export type notification_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter, which notification_keys to fetch.
     */
    where?: notification_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_keys to fetch.
     */
    orderBy?: notification_keysOrderByWithRelationInput | notification_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_keys.
     */
    cursor?: notification_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_keys.
     */
    distinct?: Notification_keysScalarFieldEnum | Notification_keysScalarFieldEnum[]
  }

  /**
   * notification_keys findMany
   */
  export type notification_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter, which notification_keys to fetch.
     */
    where?: notification_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_keys to fetch.
     */
    orderBy?: notification_keysOrderByWithRelationInput | notification_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_keys.
     */
    cursor?: notification_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_keys.
     */
    skip?: number
    distinct?: Notification_keysScalarFieldEnum | Notification_keysScalarFieldEnum[]
  }

  /**
   * notification_keys create
   */
  export type notification_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * The data needed to create a notification_keys.
     */
    data: XOR<notification_keysCreateInput, notification_keysUncheckedCreateInput>
  }

  /**
   * notification_keys createMany
   */
  export type notification_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_keys.
     */
    data: notification_keysCreateManyInput | notification_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_keys update
   */
  export type notification_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * The data needed to update a notification_keys.
     */
    data: XOR<notification_keysUpdateInput, notification_keysUncheckedUpdateInput>
    /**
     * Choose, which notification_keys to update.
     */
    where: notification_keysWhereUniqueInput
  }

  /**
   * notification_keys updateMany
   */
  export type notification_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_keys.
     */
    data: XOR<notification_keysUpdateManyMutationInput, notification_keysUncheckedUpdateManyInput>
    /**
     * Filter which notification_keys to update
     */
    where?: notification_keysWhereInput
  }

  /**
   * notification_keys upsert
   */
  export type notification_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * The filter to search for the notification_keys to update in case it exists.
     */
    where: notification_keysWhereUniqueInput
    /**
     * In case the notification_keys found by the `where` argument doesn't exist, create a new notification_keys with this data.
     */
    create: XOR<notification_keysCreateInput, notification_keysUncheckedCreateInput>
    /**
     * In case the notification_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_keysUpdateInput, notification_keysUncheckedUpdateInput>
  }

  /**
   * notification_keys delete
   */
  export type notification_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
    /**
     * Filter which notification_keys to delete.
     */
    where: notification_keysWhereUniqueInput
  }

  /**
   * notification_keys deleteMany
   */
  export type notification_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_keys to delete
     */
    where?: notification_keysWhereInput
  }

  /**
   * notification_keys without action
   */
  export type notification_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_keys
     */
    select?: notification_keysSelect<ExtArgs> | null
  }


  /**
   * Model notificationattempt
   */

  export type AggregateNotificationattempt = {
    _count: NotificationattemptCountAggregateOutputType | null
    _avg: NotificationattemptAvgAggregateOutputType | null
    _sum: NotificationattemptSumAggregateOutputType | null
    _min: NotificationattemptMinAggregateOutputType | null
    _max: NotificationattemptMaxAggregateOutputType | null
  }

  export type NotificationattemptAvgAggregateOutputType = {
    notificationattempt_id: number | null
    login_id: number | null
    notification_medium: number | null
    status: number | null
  }

  export type NotificationattemptSumAggregateOutputType = {
    notificationattempt_id: number | null
    login_id: number | null
    notification_medium: number | null
    status: number | null
  }

  export type NotificationattemptMinAggregateOutputType = {
    notificationattempt_id: number | null
    login_id: number | null
    notification_heading: string | null
    notification_message: string | null
    notification_type: string | null
    CreatedDateTime: Date | null
    notification_medium: number | null
    SendDateTime: Date | null
    status: number | null
  }

  export type NotificationattemptMaxAggregateOutputType = {
    notificationattempt_id: number | null
    login_id: number | null
    notification_heading: string | null
    notification_message: string | null
    notification_type: string | null
    CreatedDateTime: Date | null
    notification_medium: number | null
    SendDateTime: Date | null
    status: number | null
  }

  export type NotificationattemptCountAggregateOutputType = {
    notificationattempt_id: number
    login_id: number
    notification_heading: number
    notification_message: number
    notification_type: number
    CreatedDateTime: number
    notification_medium: number
    SendDateTime: number
    status: number
    _all: number
  }


  export type NotificationattemptAvgAggregateInputType = {
    notificationattempt_id?: true
    login_id?: true
    notification_medium?: true
    status?: true
  }

  export type NotificationattemptSumAggregateInputType = {
    notificationattempt_id?: true
    login_id?: true
    notification_medium?: true
    status?: true
  }

  export type NotificationattemptMinAggregateInputType = {
    notificationattempt_id?: true
    login_id?: true
    notification_heading?: true
    notification_message?: true
    notification_type?: true
    CreatedDateTime?: true
    notification_medium?: true
    SendDateTime?: true
    status?: true
  }

  export type NotificationattemptMaxAggregateInputType = {
    notificationattempt_id?: true
    login_id?: true
    notification_heading?: true
    notification_message?: true
    notification_type?: true
    CreatedDateTime?: true
    notification_medium?: true
    SendDateTime?: true
    status?: true
  }

  export type NotificationattemptCountAggregateInputType = {
    notificationattempt_id?: true
    login_id?: true
    notification_heading?: true
    notification_message?: true
    notification_type?: true
    CreatedDateTime?: true
    notification_medium?: true
    SendDateTime?: true
    status?: true
    _all?: true
  }

  export type NotificationattemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationattempt to aggregate.
     */
    where?: notificationattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationattempts to fetch.
     */
    orderBy?: notificationattemptOrderByWithRelationInput | notificationattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notificationattempts
    **/
    _count?: true | NotificationattemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationattemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationattemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationattemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationattemptMaxAggregateInputType
  }

  export type GetNotificationattemptAggregateType<T extends NotificationattemptAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationattempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationattempt[P]>
      : GetScalarType<T[P], AggregateNotificationattempt[P]>
  }




  export type notificationattemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationattemptWhereInput
    orderBy?: notificationattemptOrderByWithAggregationInput | notificationattemptOrderByWithAggregationInput[]
    by: NotificationattemptScalarFieldEnum[] | NotificationattemptScalarFieldEnum
    having?: notificationattemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationattemptCountAggregateInputType | true
    _avg?: NotificationattemptAvgAggregateInputType
    _sum?: NotificationattemptSumAggregateInputType
    _min?: NotificationattemptMinAggregateInputType
    _max?: NotificationattemptMaxAggregateInputType
  }

  export type NotificationattemptGroupByOutputType = {
    notificationattempt_id: number
    login_id: number
    notification_heading: string
    notification_message: string
    notification_type: string
    CreatedDateTime: Date
    notification_medium: number
    SendDateTime: Date
    status: number
    _count: NotificationattemptCountAggregateOutputType | null
    _avg: NotificationattemptAvgAggregateOutputType | null
    _sum: NotificationattemptSumAggregateOutputType | null
    _min: NotificationattemptMinAggregateOutputType | null
    _max: NotificationattemptMaxAggregateOutputType | null
  }

  type GetNotificationattemptGroupByPayload<T extends notificationattemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationattemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationattemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationattemptGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationattemptGroupByOutputType[P]>
        }
      >
    >


  export type notificationattemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    notificationattempt_id?: boolean
    login_id?: boolean
    notification_heading?: boolean
    notification_message?: boolean
    notification_type?: boolean
    CreatedDateTime?: boolean
    notification_medium?: boolean
    SendDateTime?: boolean
    status?: boolean
  }, ExtArgs["result"]["notificationattempt"]>


  export type notificationattemptSelectScalar = {
    notificationattempt_id?: boolean
    login_id?: boolean
    notification_heading?: boolean
    notification_message?: boolean
    notification_type?: boolean
    CreatedDateTime?: boolean
    notification_medium?: boolean
    SendDateTime?: boolean
    status?: boolean
  }


  export type $notificationattemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notificationattempt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      notificationattempt_id: number
      login_id: number
      notification_heading: string
      notification_message: string
      notification_type: string
      CreatedDateTime: Date
      notification_medium: number
      SendDateTime: Date
      status: number
    }, ExtArgs["result"]["notificationattempt"]>
    composites: {}
  }

  type notificationattemptGetPayload<S extends boolean | null | undefined | notificationattemptDefaultArgs> = $Result.GetResult<Prisma.$notificationattemptPayload, S>

  type notificationattemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationattemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationattemptCountAggregateInputType | true
    }

  export interface notificationattemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notificationattempt'], meta: { name: 'notificationattempt' } }
    /**
     * Find zero or one Notificationattempt that matches the filter.
     * @param {notificationattemptFindUniqueArgs} args - Arguments to find a Notificationattempt
     * @example
     * // Get one Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationattemptFindUniqueArgs>(args: SelectSubset<T, notificationattemptFindUniqueArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notificationattempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationattemptFindUniqueOrThrowArgs} args - Arguments to find a Notificationattempt
     * @example
     * // Get one Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationattemptFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationattemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notificationattempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptFindFirstArgs} args - Arguments to find a Notificationattempt
     * @example
     * // Get one Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationattemptFindFirstArgs>(args?: SelectSubset<T, notificationattemptFindFirstArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notificationattempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptFindFirstOrThrowArgs} args - Arguments to find a Notificationattempt
     * @example
     * // Get one Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationattemptFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationattemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notificationattempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificationattempts
     * const notificationattempts = await prisma.notificationattempt.findMany()
     * 
     * // Get first 10 Notificationattempts
     * const notificationattempts = await prisma.notificationattempt.findMany({ take: 10 })
     * 
     * // Only select the `notificationattempt_id`
     * const notificationattemptWithNotificationattempt_idOnly = await prisma.notificationattempt.findMany({ select: { notificationattempt_id: true } })
     * 
     */
    findMany<T extends notificationattemptFindManyArgs>(args?: SelectSubset<T, notificationattemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notificationattempt.
     * @param {notificationattemptCreateArgs} args - Arguments to create a Notificationattempt.
     * @example
     * // Create one Notificationattempt
     * const Notificationattempt = await prisma.notificationattempt.create({
     *   data: {
     *     // ... data to create a Notificationattempt
     *   }
     * })
     * 
     */
    create<T extends notificationattemptCreateArgs>(args: SelectSubset<T, notificationattemptCreateArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notificationattempts.
     * @param {notificationattemptCreateManyArgs} args - Arguments to create many Notificationattempts.
     * @example
     * // Create many Notificationattempts
     * const notificationattempt = await prisma.notificationattempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationattemptCreateManyArgs>(args?: SelectSubset<T, notificationattemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notificationattempt.
     * @param {notificationattemptDeleteArgs} args - Arguments to delete one Notificationattempt.
     * @example
     * // Delete one Notificationattempt
     * const Notificationattempt = await prisma.notificationattempt.delete({
     *   where: {
     *     // ... filter to delete one Notificationattempt
     *   }
     * })
     * 
     */
    delete<T extends notificationattemptDeleteArgs>(args: SelectSubset<T, notificationattemptDeleteArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notificationattempt.
     * @param {notificationattemptUpdateArgs} args - Arguments to update one Notificationattempt.
     * @example
     * // Update one Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationattemptUpdateArgs>(args: SelectSubset<T, notificationattemptUpdateArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notificationattempts.
     * @param {notificationattemptDeleteManyArgs} args - Arguments to filter Notificationattempts to delete.
     * @example
     * // Delete a few Notificationattempts
     * const { count } = await prisma.notificationattempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationattemptDeleteManyArgs>(args?: SelectSubset<T, notificationattemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificationattempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificationattempts
     * const notificationattempt = await prisma.notificationattempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationattemptUpdateManyArgs>(args: SelectSubset<T, notificationattemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notificationattempt.
     * @param {notificationattemptUpsertArgs} args - Arguments to update or create a Notificationattempt.
     * @example
     * // Update or create a Notificationattempt
     * const notificationattempt = await prisma.notificationattempt.upsert({
     *   create: {
     *     // ... data to create a Notificationattempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificationattempt we want to update
     *   }
     * })
     */
    upsert<T extends notificationattemptUpsertArgs>(args: SelectSubset<T, notificationattemptUpsertArgs<ExtArgs>>): Prisma__notificationattemptClient<$Result.GetResult<Prisma.$notificationattemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notificationattempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptCountArgs} args - Arguments to filter Notificationattempts to count.
     * @example
     * // Count the number of Notificationattempts
     * const count = await prisma.notificationattempt.count({
     *   where: {
     *     // ... the filter for the Notificationattempts we want to count
     *   }
     * })
    **/
    count<T extends notificationattemptCountArgs>(
      args?: Subset<T, notificationattemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationattemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificationattempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationattemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationattemptAggregateArgs>(args: Subset<T, NotificationattemptAggregateArgs>): Prisma.PrismaPromise<GetNotificationattemptAggregateType<T>>

    /**
     * Group by Notificationattempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationattemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationattemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationattemptGroupByArgs['orderBy'] }
        : { orderBy?: notificationattemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationattemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationattemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notificationattempt model
   */
  readonly fields: notificationattemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notificationattempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationattemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notificationattempt model
   */ 
  interface notificationattemptFieldRefs {
    readonly notificationattempt_id: FieldRef<"notificationattempt", 'Int'>
    readonly login_id: FieldRef<"notificationattempt", 'Int'>
    readonly notification_heading: FieldRef<"notificationattempt", 'String'>
    readonly notification_message: FieldRef<"notificationattempt", 'String'>
    readonly notification_type: FieldRef<"notificationattempt", 'String'>
    readonly CreatedDateTime: FieldRef<"notificationattempt", 'DateTime'>
    readonly notification_medium: FieldRef<"notificationattempt", 'Int'>
    readonly SendDateTime: FieldRef<"notificationattempt", 'DateTime'>
    readonly status: FieldRef<"notificationattempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * notificationattempt findUnique
   */
  export type notificationattemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter, which notificationattempt to fetch.
     */
    where: notificationattemptWhereUniqueInput
  }

  /**
   * notificationattempt findUniqueOrThrow
   */
  export type notificationattemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter, which notificationattempt to fetch.
     */
    where: notificationattemptWhereUniqueInput
  }

  /**
   * notificationattempt findFirst
   */
  export type notificationattemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter, which notificationattempt to fetch.
     */
    where?: notificationattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationattempts to fetch.
     */
    orderBy?: notificationattemptOrderByWithRelationInput | notificationattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationattempts.
     */
    cursor?: notificationattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationattempts.
     */
    distinct?: NotificationattemptScalarFieldEnum | NotificationattemptScalarFieldEnum[]
  }

  /**
   * notificationattempt findFirstOrThrow
   */
  export type notificationattemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter, which notificationattempt to fetch.
     */
    where?: notificationattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationattempts to fetch.
     */
    orderBy?: notificationattemptOrderByWithRelationInput | notificationattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationattempts.
     */
    cursor?: notificationattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationattempts.
     */
    distinct?: NotificationattemptScalarFieldEnum | NotificationattemptScalarFieldEnum[]
  }

  /**
   * notificationattempt findMany
   */
  export type notificationattemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter, which notificationattempts to fetch.
     */
    where?: notificationattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationattempts to fetch.
     */
    orderBy?: notificationattemptOrderByWithRelationInput | notificationattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notificationattempts.
     */
    cursor?: notificationattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationattempts.
     */
    skip?: number
    distinct?: NotificationattemptScalarFieldEnum | NotificationattemptScalarFieldEnum[]
  }

  /**
   * notificationattempt create
   */
  export type notificationattemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * The data needed to create a notificationattempt.
     */
    data: XOR<notificationattemptCreateInput, notificationattemptUncheckedCreateInput>
  }

  /**
   * notificationattempt createMany
   */
  export type notificationattemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notificationattempts.
     */
    data: notificationattemptCreateManyInput | notificationattemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notificationattempt update
   */
  export type notificationattemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * The data needed to update a notificationattempt.
     */
    data: XOR<notificationattemptUpdateInput, notificationattemptUncheckedUpdateInput>
    /**
     * Choose, which notificationattempt to update.
     */
    where: notificationattemptWhereUniqueInput
  }

  /**
   * notificationattempt updateMany
   */
  export type notificationattemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notificationattempts.
     */
    data: XOR<notificationattemptUpdateManyMutationInput, notificationattemptUncheckedUpdateManyInput>
    /**
     * Filter which notificationattempts to update
     */
    where?: notificationattemptWhereInput
  }

  /**
   * notificationattempt upsert
   */
  export type notificationattemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * The filter to search for the notificationattempt to update in case it exists.
     */
    where: notificationattemptWhereUniqueInput
    /**
     * In case the notificationattempt found by the `where` argument doesn't exist, create a new notificationattempt with this data.
     */
    create: XOR<notificationattemptCreateInput, notificationattemptUncheckedCreateInput>
    /**
     * In case the notificationattempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationattemptUpdateInput, notificationattemptUncheckedUpdateInput>
  }

  /**
   * notificationattempt delete
   */
  export type notificationattemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
    /**
     * Filter which notificationattempt to delete.
     */
    where: notificationattemptWhereUniqueInput
  }

  /**
   * notificationattempt deleteMany
   */
  export type notificationattemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationattempts to delete
     */
    where?: notificationattemptWhereInput
  }

  /**
   * notificationattempt without action
   */
  export type notificationattemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationattempt
     */
    select?: notificationattemptSelect<ExtArgs> | null
  }


  /**
   * Model Renamedpackage
   */

  export type AggregateRenamedpackage = {
    _count: RenamedpackageCountAggregateOutputType | null
    _avg: RenamedpackageAvgAggregateOutputType | null
    _sum: RenamedpackageSumAggregateOutputType | null
    _min: RenamedpackageMinAggregateOutputType | null
    _max: RenamedpackageMaxAggregateOutputType | null
  }

  export type RenamedpackageAvgAggregateOutputType = {
    id: number | null
  }

  export type RenamedpackageSumAggregateOutputType = {
    id: number | null
  }

  export type RenamedpackageMinAggregateOutputType = {
    id: number | null
    package_name: string | null
    created_on: string | null
    created_by: string | null
  }

  export type RenamedpackageMaxAggregateOutputType = {
    id: number | null
    package_name: string | null
    created_on: string | null
    created_by: string | null
  }

  export type RenamedpackageCountAggregateOutputType = {
    id: number
    package_name: number
    created_on: number
    created_by: number
    _all: number
  }


  export type RenamedpackageAvgAggregateInputType = {
    id?: true
  }

  export type RenamedpackageSumAggregateInputType = {
    id?: true
  }

  export type RenamedpackageMinAggregateInputType = {
    id?: true
    package_name?: true
    created_on?: true
    created_by?: true
  }

  export type RenamedpackageMaxAggregateInputType = {
    id?: true
    package_name?: true
    created_on?: true
    created_by?: true
  }

  export type RenamedpackageCountAggregateInputType = {
    id?: true
    package_name?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type RenamedpackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Renamedpackage to aggregate.
     */
    where?: RenamedpackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renamedpackages to fetch.
     */
    orderBy?: RenamedpackageOrderByWithRelationInput | RenamedpackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RenamedpackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renamedpackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renamedpackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Renamedpackages
    **/
    _count?: true | RenamedpackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RenamedpackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RenamedpackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RenamedpackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RenamedpackageMaxAggregateInputType
  }

  export type GetRenamedpackageAggregateType<T extends RenamedpackageAggregateArgs> = {
        [P in keyof T & keyof AggregateRenamedpackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRenamedpackage[P]>
      : GetScalarType<T[P], AggregateRenamedpackage[P]>
  }




  export type RenamedpackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RenamedpackageWhereInput
    orderBy?: RenamedpackageOrderByWithAggregationInput | RenamedpackageOrderByWithAggregationInput[]
    by: RenamedpackageScalarFieldEnum[] | RenamedpackageScalarFieldEnum
    having?: RenamedpackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RenamedpackageCountAggregateInputType | true
    _avg?: RenamedpackageAvgAggregateInputType
    _sum?: RenamedpackageSumAggregateInputType
    _min?: RenamedpackageMinAggregateInputType
    _max?: RenamedpackageMaxAggregateInputType
  }

  export type RenamedpackageGroupByOutputType = {
    id: number
    package_name: string
    created_on: string | null
    created_by: string | null
    _count: RenamedpackageCountAggregateOutputType | null
    _avg: RenamedpackageAvgAggregateOutputType | null
    _sum: RenamedpackageSumAggregateOutputType | null
    _min: RenamedpackageMinAggregateOutputType | null
    _max: RenamedpackageMaxAggregateOutputType | null
  }

  type GetRenamedpackageGroupByPayload<T extends RenamedpackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RenamedpackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RenamedpackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RenamedpackageGroupByOutputType[P]>
            : GetScalarType<T[P], RenamedpackageGroupByOutputType[P]>
        }
      >
    >


  export type RenamedpackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_name?: boolean
    created_on?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["renamedpackage"]>


  export type RenamedpackageSelectScalar = {
    id?: boolean
    package_name?: boolean
    created_on?: boolean
    created_by?: boolean
  }


  export type $RenamedpackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Renamedpackage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      package_name: string
      created_on: string | null
      created_by: string | null
    }, ExtArgs["result"]["renamedpackage"]>
    composites: {}
  }

  type RenamedpackageGetPayload<S extends boolean | null | undefined | RenamedpackageDefaultArgs> = $Result.GetResult<Prisma.$RenamedpackagePayload, S>

  type RenamedpackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RenamedpackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RenamedpackageCountAggregateInputType | true
    }

  export interface RenamedpackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Renamedpackage'], meta: { name: 'Renamedpackage' } }
    /**
     * Find zero or one Renamedpackage that matches the filter.
     * @param {RenamedpackageFindUniqueArgs} args - Arguments to find a Renamedpackage
     * @example
     * // Get one Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RenamedpackageFindUniqueArgs>(args: SelectSubset<T, RenamedpackageFindUniqueArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Renamedpackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RenamedpackageFindUniqueOrThrowArgs} args - Arguments to find a Renamedpackage
     * @example
     * // Get one Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RenamedpackageFindUniqueOrThrowArgs>(args: SelectSubset<T, RenamedpackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Renamedpackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageFindFirstArgs} args - Arguments to find a Renamedpackage
     * @example
     * // Get one Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RenamedpackageFindFirstArgs>(args?: SelectSubset<T, RenamedpackageFindFirstArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Renamedpackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageFindFirstOrThrowArgs} args - Arguments to find a Renamedpackage
     * @example
     * // Get one Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RenamedpackageFindFirstOrThrowArgs>(args?: SelectSubset<T, RenamedpackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Renamedpackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Renamedpackages
     * const renamedpackages = await prisma.renamedpackage.findMany()
     * 
     * // Get first 10 Renamedpackages
     * const renamedpackages = await prisma.renamedpackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const renamedpackageWithIdOnly = await prisma.renamedpackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RenamedpackageFindManyArgs>(args?: SelectSubset<T, RenamedpackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Renamedpackage.
     * @param {RenamedpackageCreateArgs} args - Arguments to create a Renamedpackage.
     * @example
     * // Create one Renamedpackage
     * const Renamedpackage = await prisma.renamedpackage.create({
     *   data: {
     *     // ... data to create a Renamedpackage
     *   }
     * })
     * 
     */
    create<T extends RenamedpackageCreateArgs>(args: SelectSubset<T, RenamedpackageCreateArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Renamedpackages.
     * @param {RenamedpackageCreateManyArgs} args - Arguments to create many Renamedpackages.
     * @example
     * // Create many Renamedpackages
     * const renamedpackage = await prisma.renamedpackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RenamedpackageCreateManyArgs>(args?: SelectSubset<T, RenamedpackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Renamedpackage.
     * @param {RenamedpackageDeleteArgs} args - Arguments to delete one Renamedpackage.
     * @example
     * // Delete one Renamedpackage
     * const Renamedpackage = await prisma.renamedpackage.delete({
     *   where: {
     *     // ... filter to delete one Renamedpackage
     *   }
     * })
     * 
     */
    delete<T extends RenamedpackageDeleteArgs>(args: SelectSubset<T, RenamedpackageDeleteArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Renamedpackage.
     * @param {RenamedpackageUpdateArgs} args - Arguments to update one Renamedpackage.
     * @example
     * // Update one Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RenamedpackageUpdateArgs>(args: SelectSubset<T, RenamedpackageUpdateArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Renamedpackages.
     * @param {RenamedpackageDeleteManyArgs} args - Arguments to filter Renamedpackages to delete.
     * @example
     * // Delete a few Renamedpackages
     * const { count } = await prisma.renamedpackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RenamedpackageDeleteManyArgs>(args?: SelectSubset<T, RenamedpackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Renamedpackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Renamedpackages
     * const renamedpackage = await prisma.renamedpackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RenamedpackageUpdateManyArgs>(args: SelectSubset<T, RenamedpackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Renamedpackage.
     * @param {RenamedpackageUpsertArgs} args - Arguments to update or create a Renamedpackage.
     * @example
     * // Update or create a Renamedpackage
     * const renamedpackage = await prisma.renamedpackage.upsert({
     *   create: {
     *     // ... data to create a Renamedpackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Renamedpackage we want to update
     *   }
     * })
     */
    upsert<T extends RenamedpackageUpsertArgs>(args: SelectSubset<T, RenamedpackageUpsertArgs<ExtArgs>>): Prisma__RenamedpackageClient<$Result.GetResult<Prisma.$RenamedpackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Renamedpackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageCountArgs} args - Arguments to filter Renamedpackages to count.
     * @example
     * // Count the number of Renamedpackages
     * const count = await prisma.renamedpackage.count({
     *   where: {
     *     // ... the filter for the Renamedpackages we want to count
     *   }
     * })
    **/
    count<T extends RenamedpackageCountArgs>(
      args?: Subset<T, RenamedpackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RenamedpackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Renamedpackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RenamedpackageAggregateArgs>(args: Subset<T, RenamedpackageAggregateArgs>): Prisma.PrismaPromise<GetRenamedpackageAggregateType<T>>

    /**
     * Group by Renamedpackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenamedpackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RenamedpackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RenamedpackageGroupByArgs['orderBy'] }
        : { orderBy?: RenamedpackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RenamedpackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRenamedpackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Renamedpackage model
   */
  readonly fields: RenamedpackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Renamedpackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RenamedpackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Renamedpackage model
   */ 
  interface RenamedpackageFieldRefs {
    readonly id: FieldRef<"Renamedpackage", 'Int'>
    readonly package_name: FieldRef<"Renamedpackage", 'String'>
    readonly created_on: FieldRef<"Renamedpackage", 'String'>
    readonly created_by: FieldRef<"Renamedpackage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Renamedpackage findUnique
   */
  export type RenamedpackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter, which Renamedpackage to fetch.
     */
    where: RenamedpackageWhereUniqueInput
  }

  /**
   * Renamedpackage findUniqueOrThrow
   */
  export type RenamedpackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter, which Renamedpackage to fetch.
     */
    where: RenamedpackageWhereUniqueInput
  }

  /**
   * Renamedpackage findFirst
   */
  export type RenamedpackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter, which Renamedpackage to fetch.
     */
    where?: RenamedpackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renamedpackages to fetch.
     */
    orderBy?: RenamedpackageOrderByWithRelationInput | RenamedpackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Renamedpackages.
     */
    cursor?: RenamedpackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renamedpackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renamedpackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Renamedpackages.
     */
    distinct?: RenamedpackageScalarFieldEnum | RenamedpackageScalarFieldEnum[]
  }

  /**
   * Renamedpackage findFirstOrThrow
   */
  export type RenamedpackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter, which Renamedpackage to fetch.
     */
    where?: RenamedpackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renamedpackages to fetch.
     */
    orderBy?: RenamedpackageOrderByWithRelationInput | RenamedpackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Renamedpackages.
     */
    cursor?: RenamedpackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renamedpackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renamedpackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Renamedpackages.
     */
    distinct?: RenamedpackageScalarFieldEnum | RenamedpackageScalarFieldEnum[]
  }

  /**
   * Renamedpackage findMany
   */
  export type RenamedpackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter, which Renamedpackages to fetch.
     */
    where?: RenamedpackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renamedpackages to fetch.
     */
    orderBy?: RenamedpackageOrderByWithRelationInput | RenamedpackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Renamedpackages.
     */
    cursor?: RenamedpackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renamedpackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renamedpackages.
     */
    skip?: number
    distinct?: RenamedpackageScalarFieldEnum | RenamedpackageScalarFieldEnum[]
  }

  /**
   * Renamedpackage create
   */
  export type RenamedpackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * The data needed to create a Renamedpackage.
     */
    data: XOR<RenamedpackageCreateInput, RenamedpackageUncheckedCreateInput>
  }

  /**
   * Renamedpackage createMany
   */
  export type RenamedpackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Renamedpackages.
     */
    data: RenamedpackageCreateManyInput | RenamedpackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Renamedpackage update
   */
  export type RenamedpackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * The data needed to update a Renamedpackage.
     */
    data: XOR<RenamedpackageUpdateInput, RenamedpackageUncheckedUpdateInput>
    /**
     * Choose, which Renamedpackage to update.
     */
    where: RenamedpackageWhereUniqueInput
  }

  /**
   * Renamedpackage updateMany
   */
  export type RenamedpackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Renamedpackages.
     */
    data: XOR<RenamedpackageUpdateManyMutationInput, RenamedpackageUncheckedUpdateManyInput>
    /**
     * Filter which Renamedpackages to update
     */
    where?: RenamedpackageWhereInput
  }

  /**
   * Renamedpackage upsert
   */
  export type RenamedpackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * The filter to search for the Renamedpackage to update in case it exists.
     */
    where: RenamedpackageWhereUniqueInput
    /**
     * In case the Renamedpackage found by the `where` argument doesn't exist, create a new Renamedpackage with this data.
     */
    create: XOR<RenamedpackageCreateInput, RenamedpackageUncheckedCreateInput>
    /**
     * In case the Renamedpackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RenamedpackageUpdateInput, RenamedpackageUncheckedUpdateInput>
  }

  /**
   * Renamedpackage delete
   */
  export type RenamedpackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
    /**
     * Filter which Renamedpackage to delete.
     */
    where: RenamedpackageWhereUniqueInput
  }

  /**
   * Renamedpackage deleteMany
   */
  export type RenamedpackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Renamedpackages to delete
     */
    where?: RenamedpackageWhereInput
  }

  /**
   * Renamedpackage without action
   */
  export type RenamedpackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renamedpackage
     */
    select?: RenamedpackageSelect<ExtArgs> | null
  }


  /**
   * Model package_contains
   */

  export type AggregatePackage_contains = {
    _count: Package_containsCountAggregateOutputType | null
    _avg: Package_containsAvgAggregateOutputType | null
    _sum: Package_containsSumAggregateOutputType | null
    _min: Package_containsMinAggregateOutputType | null
    _max: Package_containsMaxAggregateOutputType | null
  }

  export type Package_containsAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
  }

  export type Package_containsSumAggregateOutputType = {
    id: number | null
    is_active: number | null
  }

  export type Package_containsMinAggregateOutputType = {
    id: number | null
    package_id: string | null
    test_id: string | null
    created_on: string | null
    is_active: number | null
  }

  export type Package_containsMaxAggregateOutputType = {
    id: number | null
    package_id: string | null
    test_id: string | null
    created_on: string | null
    is_active: number | null
  }

  export type Package_containsCountAggregateOutputType = {
    id: number
    package_id: number
    test_id: number
    created_on: number
    is_active: number
    _all: number
  }


  export type Package_containsAvgAggregateInputType = {
    id?: true
    is_active?: true
  }

  export type Package_containsSumAggregateInputType = {
    id?: true
    is_active?: true
  }

  export type Package_containsMinAggregateInputType = {
    id?: true
    package_id?: true
    test_id?: true
    created_on?: true
    is_active?: true
  }

  export type Package_containsMaxAggregateInputType = {
    id?: true
    package_id?: true
    test_id?: true
    created_on?: true
    is_active?: true
  }

  export type Package_containsCountAggregateInputType = {
    id?: true
    package_id?: true
    test_id?: true
    created_on?: true
    is_active?: true
    _all?: true
  }

  export type Package_containsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_contains to aggregate.
     */
    where?: package_containsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_contains to fetch.
     */
    orderBy?: package_containsOrderByWithRelationInput | package_containsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: package_containsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_contains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_contains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned package_contains
    **/
    _count?: true | Package_containsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Package_containsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Package_containsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Package_containsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Package_containsMaxAggregateInputType
  }

  export type GetPackage_containsAggregateType<T extends Package_containsAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage_contains]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage_contains[P]>
      : GetScalarType<T[P], AggregatePackage_contains[P]>
  }




  export type package_containsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: package_containsWhereInput
    orderBy?: package_containsOrderByWithAggregationInput | package_containsOrderByWithAggregationInput[]
    by: Package_containsScalarFieldEnum[] | Package_containsScalarFieldEnum
    having?: package_containsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Package_containsCountAggregateInputType | true
    _avg?: Package_containsAvgAggregateInputType
    _sum?: Package_containsSumAggregateInputType
    _min?: Package_containsMinAggregateInputType
    _max?: Package_containsMaxAggregateInputType
  }

  export type Package_containsGroupByOutputType = {
    id: number
    package_id: string
    test_id: string
    created_on: string | null
    is_active: number
    _count: Package_containsCountAggregateOutputType | null
    _avg: Package_containsAvgAggregateOutputType | null
    _sum: Package_containsSumAggregateOutputType | null
    _min: Package_containsMinAggregateOutputType | null
    _max: Package_containsMaxAggregateOutputType | null
  }

  type GetPackage_containsGroupByPayload<T extends package_containsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Package_containsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Package_containsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Package_containsGroupByOutputType[P]>
            : GetScalarType<T[P], Package_containsGroupByOutputType[P]>
        }
      >
    >


  export type package_containsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_id?: boolean
    test_id?: boolean
    created_on?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["package_contains"]>


  export type package_containsSelectScalar = {
    id?: boolean
    package_id?: boolean
    test_id?: boolean
    created_on?: boolean
    is_active?: boolean
  }


  export type $package_containsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "package_contains"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      package_id: string
      test_id: string
      created_on: string | null
      is_active: number
    }, ExtArgs["result"]["package_contains"]>
    composites: {}
  }

  type package_containsGetPayload<S extends boolean | null | undefined | package_containsDefaultArgs> = $Result.GetResult<Prisma.$package_containsPayload, S>

  type package_containsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<package_containsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Package_containsCountAggregateInputType | true
    }

  export interface package_containsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['package_contains'], meta: { name: 'package_contains' } }
    /**
     * Find zero or one Package_contains that matches the filter.
     * @param {package_containsFindUniqueArgs} args - Arguments to find a Package_contains
     * @example
     * // Get one Package_contains
     * const package_contains = await prisma.package_contains.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends package_containsFindUniqueArgs>(args: SelectSubset<T, package_containsFindUniqueArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Package_contains that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {package_containsFindUniqueOrThrowArgs} args - Arguments to find a Package_contains
     * @example
     * // Get one Package_contains
     * const package_contains = await prisma.package_contains.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends package_containsFindUniqueOrThrowArgs>(args: SelectSubset<T, package_containsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Package_contains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsFindFirstArgs} args - Arguments to find a Package_contains
     * @example
     * // Get one Package_contains
     * const package_contains = await prisma.package_contains.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends package_containsFindFirstArgs>(args?: SelectSubset<T, package_containsFindFirstArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Package_contains that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsFindFirstOrThrowArgs} args - Arguments to find a Package_contains
     * @example
     * // Get one Package_contains
     * const package_contains = await prisma.package_contains.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends package_containsFindFirstOrThrowArgs>(args?: SelectSubset<T, package_containsFindFirstOrThrowArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Package_contains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Package_contains
     * const package_contains = await prisma.package_contains.findMany()
     * 
     * // Get first 10 Package_contains
     * const package_contains = await prisma.package_contains.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const package_containsWithIdOnly = await prisma.package_contains.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends package_containsFindManyArgs>(args?: SelectSubset<T, package_containsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Package_contains.
     * @param {package_containsCreateArgs} args - Arguments to create a Package_contains.
     * @example
     * // Create one Package_contains
     * const Package_contains = await prisma.package_contains.create({
     *   data: {
     *     // ... data to create a Package_contains
     *   }
     * })
     * 
     */
    create<T extends package_containsCreateArgs>(args: SelectSubset<T, package_containsCreateArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Package_contains.
     * @param {package_containsCreateManyArgs} args - Arguments to create many Package_contains.
     * @example
     * // Create many Package_contains
     * const package_contains = await prisma.package_contains.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends package_containsCreateManyArgs>(args?: SelectSubset<T, package_containsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package_contains.
     * @param {package_containsDeleteArgs} args - Arguments to delete one Package_contains.
     * @example
     * // Delete one Package_contains
     * const Package_contains = await prisma.package_contains.delete({
     *   where: {
     *     // ... filter to delete one Package_contains
     *   }
     * })
     * 
     */
    delete<T extends package_containsDeleteArgs>(args: SelectSubset<T, package_containsDeleteArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Package_contains.
     * @param {package_containsUpdateArgs} args - Arguments to update one Package_contains.
     * @example
     * // Update one Package_contains
     * const package_contains = await prisma.package_contains.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends package_containsUpdateArgs>(args: SelectSubset<T, package_containsUpdateArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Package_contains.
     * @param {package_containsDeleteManyArgs} args - Arguments to filter Package_contains to delete.
     * @example
     * // Delete a few Package_contains
     * const { count } = await prisma.package_contains.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends package_containsDeleteManyArgs>(args?: SelectSubset<T, package_containsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Package_contains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Package_contains
     * const package_contains = await prisma.package_contains.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends package_containsUpdateManyArgs>(args: SelectSubset<T, package_containsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package_contains.
     * @param {package_containsUpsertArgs} args - Arguments to update or create a Package_contains.
     * @example
     * // Update or create a Package_contains
     * const package_contains = await prisma.package_contains.upsert({
     *   create: {
     *     // ... data to create a Package_contains
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package_contains we want to update
     *   }
     * })
     */
    upsert<T extends package_containsUpsertArgs>(args: SelectSubset<T, package_containsUpsertArgs<ExtArgs>>): Prisma__package_containsClient<$Result.GetResult<Prisma.$package_containsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Package_contains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsCountArgs} args - Arguments to filter Package_contains to count.
     * @example
     * // Count the number of Package_contains
     * const count = await prisma.package_contains.count({
     *   where: {
     *     // ... the filter for the Package_contains we want to count
     *   }
     * })
    **/
    count<T extends package_containsCountArgs>(
      args?: Subset<T, package_containsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Package_containsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package_contains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_containsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Package_containsAggregateArgs>(args: Subset<T, Package_containsAggregateArgs>): Prisma.PrismaPromise<GetPackage_containsAggregateType<T>>

    /**
     * Group by Package_contains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_containsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends package_containsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: package_containsGroupByArgs['orderBy'] }
        : { orderBy?: package_containsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, package_containsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackage_containsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the package_contains model
   */
  readonly fields: package_containsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for package_contains.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__package_containsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the package_contains model
   */ 
  interface package_containsFieldRefs {
    readonly id: FieldRef<"package_contains", 'Int'>
    readonly package_id: FieldRef<"package_contains", 'String'>
    readonly test_id: FieldRef<"package_contains", 'String'>
    readonly created_on: FieldRef<"package_contains", 'String'>
    readonly is_active: FieldRef<"package_contains", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * package_contains findUnique
   */
  export type package_containsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter, which package_contains to fetch.
     */
    where: package_containsWhereUniqueInput
  }

  /**
   * package_contains findUniqueOrThrow
   */
  export type package_containsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter, which package_contains to fetch.
     */
    where: package_containsWhereUniqueInput
  }

  /**
   * package_contains findFirst
   */
  export type package_containsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter, which package_contains to fetch.
     */
    where?: package_containsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_contains to fetch.
     */
    orderBy?: package_containsOrderByWithRelationInput | package_containsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_contains.
     */
    cursor?: package_containsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_contains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_contains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_contains.
     */
    distinct?: Package_containsScalarFieldEnum | Package_containsScalarFieldEnum[]
  }

  /**
   * package_contains findFirstOrThrow
   */
  export type package_containsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter, which package_contains to fetch.
     */
    where?: package_containsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_contains to fetch.
     */
    orderBy?: package_containsOrderByWithRelationInput | package_containsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_contains.
     */
    cursor?: package_containsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_contains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_contains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_contains.
     */
    distinct?: Package_containsScalarFieldEnum | Package_containsScalarFieldEnum[]
  }

  /**
   * package_contains findMany
   */
  export type package_containsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter, which package_contains to fetch.
     */
    where?: package_containsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_contains to fetch.
     */
    orderBy?: package_containsOrderByWithRelationInput | package_containsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing package_contains.
     */
    cursor?: package_containsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_contains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_contains.
     */
    skip?: number
    distinct?: Package_containsScalarFieldEnum | Package_containsScalarFieldEnum[]
  }

  /**
   * package_contains create
   */
  export type package_containsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * The data needed to create a package_contains.
     */
    data: XOR<package_containsCreateInput, package_containsUncheckedCreateInput>
  }

  /**
   * package_contains createMany
   */
  export type package_containsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many package_contains.
     */
    data: package_containsCreateManyInput | package_containsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * package_contains update
   */
  export type package_containsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * The data needed to update a package_contains.
     */
    data: XOR<package_containsUpdateInput, package_containsUncheckedUpdateInput>
    /**
     * Choose, which package_contains to update.
     */
    where: package_containsWhereUniqueInput
  }

  /**
   * package_contains updateMany
   */
  export type package_containsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update package_contains.
     */
    data: XOR<package_containsUpdateManyMutationInput, package_containsUncheckedUpdateManyInput>
    /**
     * Filter which package_contains to update
     */
    where?: package_containsWhereInput
  }

  /**
   * package_contains upsert
   */
  export type package_containsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * The filter to search for the package_contains to update in case it exists.
     */
    where: package_containsWhereUniqueInput
    /**
     * In case the package_contains found by the `where` argument doesn't exist, create a new package_contains with this data.
     */
    create: XOR<package_containsCreateInput, package_containsUncheckedCreateInput>
    /**
     * In case the package_contains was found with the provided `where` argument, update it with this data.
     */
    update: XOR<package_containsUpdateInput, package_containsUncheckedUpdateInput>
  }

  /**
   * package_contains delete
   */
  export type package_containsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
    /**
     * Filter which package_contains to delete.
     */
    where: package_containsWhereUniqueInput
  }

  /**
   * package_contains deleteMany
   */
  export type package_containsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_contains to delete
     */
    where?: package_containsWhereInput
  }

  /**
   * package_contains without action
   */
  export type package_containsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_contains
     */
    select?: package_containsSelect<ExtArgs> | null
  }


  /**
   * Model package_labs
   */

  export type AggregatePackage_labs = {
    _count: Package_labsCountAggregateOutputType | null
    _avg: Package_labsAvgAggregateOutputType | null
    _sum: Package_labsSumAggregateOutputType | null
    _min: Package_labsMinAggregateOutputType | null
    _max: Package_labsMaxAggregateOutputType | null
  }

  export type Package_labsAvgAggregateOutputType = {
    id: number | null
  }

  export type Package_labsSumAggregateOutputType = {
    id: number | null
  }

  export type Package_labsMinAggregateOutputType = {
    id: number | null
    package_id: string | null
    lab_id: string | null
    package_price: string | null
    created_on: string | null
    created_by: string | null
  }

  export type Package_labsMaxAggregateOutputType = {
    id: number | null
    package_id: string | null
    lab_id: string | null
    package_price: string | null
    created_on: string | null
    created_by: string | null
  }

  export type Package_labsCountAggregateOutputType = {
    id: number
    package_id: number
    lab_id: number
    package_price: number
    created_on: number
    created_by: number
    _all: number
  }


  export type Package_labsAvgAggregateInputType = {
    id?: true
  }

  export type Package_labsSumAggregateInputType = {
    id?: true
  }

  export type Package_labsMinAggregateInputType = {
    id?: true
    package_id?: true
    lab_id?: true
    package_price?: true
    created_on?: true
    created_by?: true
  }

  export type Package_labsMaxAggregateInputType = {
    id?: true
    package_id?: true
    lab_id?: true
    package_price?: true
    created_on?: true
    created_by?: true
  }

  export type Package_labsCountAggregateInputType = {
    id?: true
    package_id?: true
    lab_id?: true
    package_price?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type Package_labsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_labs to aggregate.
     */
    where?: package_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_labs to fetch.
     */
    orderBy?: package_labsOrderByWithRelationInput | package_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: package_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned package_labs
    **/
    _count?: true | Package_labsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Package_labsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Package_labsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Package_labsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Package_labsMaxAggregateInputType
  }

  export type GetPackage_labsAggregateType<T extends Package_labsAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage_labs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage_labs[P]>
      : GetScalarType<T[P], AggregatePackage_labs[P]>
  }




  export type package_labsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: package_labsWhereInput
    orderBy?: package_labsOrderByWithAggregationInput | package_labsOrderByWithAggregationInput[]
    by: Package_labsScalarFieldEnum[] | Package_labsScalarFieldEnum
    having?: package_labsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Package_labsCountAggregateInputType | true
    _avg?: Package_labsAvgAggregateInputType
    _sum?: Package_labsSumAggregateInputType
    _min?: Package_labsMinAggregateInputType
    _max?: Package_labsMaxAggregateInputType
  }

  export type Package_labsGroupByOutputType = {
    id: number
    package_id: string
    lab_id: string
    package_price: string
    created_on: string | null
    created_by: string | null
    _count: Package_labsCountAggregateOutputType | null
    _avg: Package_labsAvgAggregateOutputType | null
    _sum: Package_labsSumAggregateOutputType | null
    _min: Package_labsMinAggregateOutputType | null
    _max: Package_labsMaxAggregateOutputType | null
  }

  type GetPackage_labsGroupByPayload<T extends package_labsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Package_labsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Package_labsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Package_labsGroupByOutputType[P]>
            : GetScalarType<T[P], Package_labsGroupByOutputType[P]>
        }
      >
    >


  export type package_labsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_id?: boolean
    lab_id?: boolean
    package_price?: boolean
    created_on?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["package_labs"]>


  export type package_labsSelectScalar = {
    id?: boolean
    package_id?: boolean
    lab_id?: boolean
    package_price?: boolean
    created_on?: boolean
    created_by?: boolean
  }


  export type $package_labsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "package_labs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      package_id: string
      lab_id: string
      package_price: string
      created_on: string | null
      created_by: string | null
    }, ExtArgs["result"]["package_labs"]>
    composites: {}
  }

  type package_labsGetPayload<S extends boolean | null | undefined | package_labsDefaultArgs> = $Result.GetResult<Prisma.$package_labsPayload, S>

  type package_labsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<package_labsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Package_labsCountAggregateInputType | true
    }

  export interface package_labsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['package_labs'], meta: { name: 'package_labs' } }
    /**
     * Find zero or one Package_labs that matches the filter.
     * @param {package_labsFindUniqueArgs} args - Arguments to find a Package_labs
     * @example
     * // Get one Package_labs
     * const package_labs = await prisma.package_labs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends package_labsFindUniqueArgs>(args: SelectSubset<T, package_labsFindUniqueArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Package_labs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {package_labsFindUniqueOrThrowArgs} args - Arguments to find a Package_labs
     * @example
     * // Get one Package_labs
     * const package_labs = await prisma.package_labs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends package_labsFindUniqueOrThrowArgs>(args: SelectSubset<T, package_labsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Package_labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsFindFirstArgs} args - Arguments to find a Package_labs
     * @example
     * // Get one Package_labs
     * const package_labs = await prisma.package_labs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends package_labsFindFirstArgs>(args?: SelectSubset<T, package_labsFindFirstArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Package_labs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsFindFirstOrThrowArgs} args - Arguments to find a Package_labs
     * @example
     * // Get one Package_labs
     * const package_labs = await prisma.package_labs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends package_labsFindFirstOrThrowArgs>(args?: SelectSubset<T, package_labsFindFirstOrThrowArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Package_labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Package_labs
     * const package_labs = await prisma.package_labs.findMany()
     * 
     * // Get first 10 Package_labs
     * const package_labs = await prisma.package_labs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const package_labsWithIdOnly = await prisma.package_labs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends package_labsFindManyArgs>(args?: SelectSubset<T, package_labsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Package_labs.
     * @param {package_labsCreateArgs} args - Arguments to create a Package_labs.
     * @example
     * // Create one Package_labs
     * const Package_labs = await prisma.package_labs.create({
     *   data: {
     *     // ... data to create a Package_labs
     *   }
     * })
     * 
     */
    create<T extends package_labsCreateArgs>(args: SelectSubset<T, package_labsCreateArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Package_labs.
     * @param {package_labsCreateManyArgs} args - Arguments to create many Package_labs.
     * @example
     * // Create many Package_labs
     * const package_labs = await prisma.package_labs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends package_labsCreateManyArgs>(args?: SelectSubset<T, package_labsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package_labs.
     * @param {package_labsDeleteArgs} args - Arguments to delete one Package_labs.
     * @example
     * // Delete one Package_labs
     * const Package_labs = await prisma.package_labs.delete({
     *   where: {
     *     // ... filter to delete one Package_labs
     *   }
     * })
     * 
     */
    delete<T extends package_labsDeleteArgs>(args: SelectSubset<T, package_labsDeleteArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Package_labs.
     * @param {package_labsUpdateArgs} args - Arguments to update one Package_labs.
     * @example
     * // Update one Package_labs
     * const package_labs = await prisma.package_labs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends package_labsUpdateArgs>(args: SelectSubset<T, package_labsUpdateArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Package_labs.
     * @param {package_labsDeleteManyArgs} args - Arguments to filter Package_labs to delete.
     * @example
     * // Delete a few Package_labs
     * const { count } = await prisma.package_labs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends package_labsDeleteManyArgs>(args?: SelectSubset<T, package_labsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Package_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Package_labs
     * const package_labs = await prisma.package_labs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends package_labsUpdateManyArgs>(args: SelectSubset<T, package_labsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package_labs.
     * @param {package_labsUpsertArgs} args - Arguments to update or create a Package_labs.
     * @example
     * // Update or create a Package_labs
     * const package_labs = await prisma.package_labs.upsert({
     *   create: {
     *     // ... data to create a Package_labs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package_labs we want to update
     *   }
     * })
     */
    upsert<T extends package_labsUpsertArgs>(args: SelectSubset<T, package_labsUpsertArgs<ExtArgs>>): Prisma__package_labsClient<$Result.GetResult<Prisma.$package_labsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Package_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsCountArgs} args - Arguments to filter Package_labs to count.
     * @example
     * // Count the number of Package_labs
     * const count = await prisma.package_labs.count({
     *   where: {
     *     // ... the filter for the Package_labs we want to count
     *   }
     * })
    **/
    count<T extends package_labsCountArgs>(
      args?: Subset<T, package_labsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Package_labsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_labsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Package_labsAggregateArgs>(args: Subset<T, Package_labsAggregateArgs>): Prisma.PrismaPromise<GetPackage_labsAggregateType<T>>

    /**
     * Group by Package_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_labsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends package_labsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: package_labsGroupByArgs['orderBy'] }
        : { orderBy?: package_labsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, package_labsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackage_labsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the package_labs model
   */
  readonly fields: package_labsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for package_labs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__package_labsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the package_labs model
   */ 
  interface package_labsFieldRefs {
    readonly id: FieldRef<"package_labs", 'Int'>
    readonly package_id: FieldRef<"package_labs", 'String'>
    readonly lab_id: FieldRef<"package_labs", 'String'>
    readonly package_price: FieldRef<"package_labs", 'String'>
    readonly created_on: FieldRef<"package_labs", 'String'>
    readonly created_by: FieldRef<"package_labs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * package_labs findUnique
   */
  export type package_labsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter, which package_labs to fetch.
     */
    where: package_labsWhereUniqueInput
  }

  /**
   * package_labs findUniqueOrThrow
   */
  export type package_labsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter, which package_labs to fetch.
     */
    where: package_labsWhereUniqueInput
  }

  /**
   * package_labs findFirst
   */
  export type package_labsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter, which package_labs to fetch.
     */
    where?: package_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_labs to fetch.
     */
    orderBy?: package_labsOrderByWithRelationInput | package_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_labs.
     */
    cursor?: package_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_labs.
     */
    distinct?: Package_labsScalarFieldEnum | Package_labsScalarFieldEnum[]
  }

  /**
   * package_labs findFirstOrThrow
   */
  export type package_labsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter, which package_labs to fetch.
     */
    where?: package_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_labs to fetch.
     */
    orderBy?: package_labsOrderByWithRelationInput | package_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_labs.
     */
    cursor?: package_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_labs.
     */
    distinct?: Package_labsScalarFieldEnum | Package_labsScalarFieldEnum[]
  }

  /**
   * package_labs findMany
   */
  export type package_labsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter, which package_labs to fetch.
     */
    where?: package_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_labs to fetch.
     */
    orderBy?: package_labsOrderByWithRelationInput | package_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing package_labs.
     */
    cursor?: package_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_labs.
     */
    skip?: number
    distinct?: Package_labsScalarFieldEnum | Package_labsScalarFieldEnum[]
  }

  /**
   * package_labs create
   */
  export type package_labsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * The data needed to create a package_labs.
     */
    data: XOR<package_labsCreateInput, package_labsUncheckedCreateInput>
  }

  /**
   * package_labs createMany
   */
  export type package_labsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many package_labs.
     */
    data: package_labsCreateManyInput | package_labsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * package_labs update
   */
  export type package_labsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * The data needed to update a package_labs.
     */
    data: XOR<package_labsUpdateInput, package_labsUncheckedUpdateInput>
    /**
     * Choose, which package_labs to update.
     */
    where: package_labsWhereUniqueInput
  }

  /**
   * package_labs updateMany
   */
  export type package_labsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update package_labs.
     */
    data: XOR<package_labsUpdateManyMutationInput, package_labsUncheckedUpdateManyInput>
    /**
     * Filter which package_labs to update
     */
    where?: package_labsWhereInput
  }

  /**
   * package_labs upsert
   */
  export type package_labsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * The filter to search for the package_labs to update in case it exists.
     */
    where: package_labsWhereUniqueInput
    /**
     * In case the package_labs found by the `where` argument doesn't exist, create a new package_labs with this data.
     */
    create: XOR<package_labsCreateInput, package_labsUncheckedCreateInput>
    /**
     * In case the package_labs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<package_labsUpdateInput, package_labsUncheckedUpdateInput>
  }

  /**
   * package_labs delete
   */
  export type package_labsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
    /**
     * Filter which package_labs to delete.
     */
    where: package_labsWhereUniqueInput
  }

  /**
   * package_labs deleteMany
   */
  export type package_labsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_labs to delete
     */
    where?: package_labsWhereInput
  }

  /**
   * package_labs without action
   */
  export type package_labsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_labs
     */
    select?: package_labsSelect<ExtArgs> | null
  }


  /**
   * Model package_queue
   */

  export type AggregatePackage_queue = {
    _count: Package_queueCountAggregateOutputType | null
    _avg: Package_queueAvgAggregateOutputType | null
    _sum: Package_queueSumAggregateOutputType | null
    _min: Package_queueMinAggregateOutputType | null
    _max: Package_queueMaxAggregateOutputType | null
  }

  export type Package_queueAvgAggregateOutputType = {
    id: number | null
  }

  export type Package_queueSumAggregateOutputType = {
    id: bigint | null
  }

  export type Package_queueMinAggregateOutputType = {
    id: bigint | null
    medical_num: string | null
    package_id: string | null
    lab_id: string | null
    patient_id: string | null
    dependent_id: string | null
    doctor_id: string | null
    referdate: string | null
    created_by: string | null
    created_on: string | null
    package_status: string | null
  }

  export type Package_queueMaxAggregateOutputType = {
    id: bigint | null
    medical_num: string | null
    package_id: string | null
    lab_id: string | null
    patient_id: string | null
    dependent_id: string | null
    doctor_id: string | null
    referdate: string | null
    created_by: string | null
    created_on: string | null
    package_status: string | null
  }

  export type Package_queueCountAggregateOutputType = {
    id: number
    medical_num: number
    package_id: number
    lab_id: number
    patient_id: number
    dependent_id: number
    doctor_id: number
    referdate: number
    created_by: number
    created_on: number
    package_status: number
    _all: number
  }


  export type Package_queueAvgAggregateInputType = {
    id?: true
  }

  export type Package_queueSumAggregateInputType = {
    id?: true
  }

  export type Package_queueMinAggregateInputType = {
    id?: true
    medical_num?: true
    package_id?: true
    lab_id?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    referdate?: true
    created_by?: true
    created_on?: true
    package_status?: true
  }

  export type Package_queueMaxAggregateInputType = {
    id?: true
    medical_num?: true
    package_id?: true
    lab_id?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    referdate?: true
    created_by?: true
    created_on?: true
    package_status?: true
  }

  export type Package_queueCountAggregateInputType = {
    id?: true
    medical_num?: true
    package_id?: true
    lab_id?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    referdate?: true
    created_by?: true
    created_on?: true
    package_status?: true
    _all?: true
  }

  export type Package_queueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_queue to aggregate.
     */
    where?: package_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_queues to fetch.
     */
    orderBy?: package_queueOrderByWithRelationInput | package_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: package_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned package_queues
    **/
    _count?: true | Package_queueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Package_queueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Package_queueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Package_queueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Package_queueMaxAggregateInputType
  }

  export type GetPackage_queueAggregateType<T extends Package_queueAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage_queue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage_queue[P]>
      : GetScalarType<T[P], AggregatePackage_queue[P]>
  }




  export type package_queueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: package_queueWhereInput
    orderBy?: package_queueOrderByWithAggregationInput | package_queueOrderByWithAggregationInput[]
    by: Package_queueScalarFieldEnum[] | Package_queueScalarFieldEnum
    having?: package_queueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Package_queueCountAggregateInputType | true
    _avg?: Package_queueAvgAggregateInputType
    _sum?: Package_queueSumAggregateInputType
    _min?: Package_queueMinAggregateInputType
    _max?: Package_queueMaxAggregateInputType
  }

  export type Package_queueGroupByOutputType = {
    id: bigint
    medical_num: string | null
    package_id: string | null
    lab_id: string | null
    patient_id: string | null
    dependent_id: string
    doctor_id: string | null
    referdate: string | null
    created_by: string | null
    created_on: string | null
    package_status: string | null
    _count: Package_queueCountAggregateOutputType | null
    _avg: Package_queueAvgAggregateOutputType | null
    _sum: Package_queueSumAggregateOutputType | null
    _min: Package_queueMinAggregateOutputType | null
    _max: Package_queueMaxAggregateOutputType | null
  }

  type GetPackage_queueGroupByPayload<T extends package_queueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Package_queueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Package_queueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Package_queueGroupByOutputType[P]>
            : GetScalarType<T[P], Package_queueGroupByOutputType[P]>
        }
      >
    >


  export type package_queueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medical_num?: boolean
    package_id?: boolean
    lab_id?: boolean
    patient_id?: boolean
    dependent_id?: boolean
    doctor_id?: boolean
    referdate?: boolean
    created_by?: boolean
    created_on?: boolean
    package_status?: boolean
  }, ExtArgs["result"]["package_queue"]>


  export type package_queueSelectScalar = {
    id?: boolean
    medical_num?: boolean
    package_id?: boolean
    lab_id?: boolean
    patient_id?: boolean
    dependent_id?: boolean
    doctor_id?: boolean
    referdate?: boolean
    created_by?: boolean
    created_on?: boolean
    package_status?: boolean
  }


  export type $package_queuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "package_queue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      medical_num: string | null
      package_id: string | null
      lab_id: string | null
      patient_id: string | null
      dependent_id: string
      doctor_id: string | null
      referdate: string | null
      created_by: string | null
      created_on: string | null
      package_status: string | null
    }, ExtArgs["result"]["package_queue"]>
    composites: {}
  }

  type package_queueGetPayload<S extends boolean | null | undefined | package_queueDefaultArgs> = $Result.GetResult<Prisma.$package_queuePayload, S>

  type package_queueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<package_queueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Package_queueCountAggregateInputType | true
    }

  export interface package_queueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['package_queue'], meta: { name: 'package_queue' } }
    /**
     * Find zero or one Package_queue that matches the filter.
     * @param {package_queueFindUniqueArgs} args - Arguments to find a Package_queue
     * @example
     * // Get one Package_queue
     * const package_queue = await prisma.package_queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends package_queueFindUniqueArgs>(args: SelectSubset<T, package_queueFindUniqueArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Package_queue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {package_queueFindUniqueOrThrowArgs} args - Arguments to find a Package_queue
     * @example
     * // Get one Package_queue
     * const package_queue = await prisma.package_queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends package_queueFindUniqueOrThrowArgs>(args: SelectSubset<T, package_queueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Package_queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueFindFirstArgs} args - Arguments to find a Package_queue
     * @example
     * // Get one Package_queue
     * const package_queue = await prisma.package_queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends package_queueFindFirstArgs>(args?: SelectSubset<T, package_queueFindFirstArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Package_queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueFindFirstOrThrowArgs} args - Arguments to find a Package_queue
     * @example
     * // Get one Package_queue
     * const package_queue = await prisma.package_queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends package_queueFindFirstOrThrowArgs>(args?: SelectSubset<T, package_queueFindFirstOrThrowArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Package_queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Package_queues
     * const package_queues = await prisma.package_queue.findMany()
     * 
     * // Get first 10 Package_queues
     * const package_queues = await prisma.package_queue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const package_queueWithIdOnly = await prisma.package_queue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends package_queueFindManyArgs>(args?: SelectSubset<T, package_queueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Package_queue.
     * @param {package_queueCreateArgs} args - Arguments to create a Package_queue.
     * @example
     * // Create one Package_queue
     * const Package_queue = await prisma.package_queue.create({
     *   data: {
     *     // ... data to create a Package_queue
     *   }
     * })
     * 
     */
    create<T extends package_queueCreateArgs>(args: SelectSubset<T, package_queueCreateArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Package_queues.
     * @param {package_queueCreateManyArgs} args - Arguments to create many Package_queues.
     * @example
     * // Create many Package_queues
     * const package_queue = await prisma.package_queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends package_queueCreateManyArgs>(args?: SelectSubset<T, package_queueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package_queue.
     * @param {package_queueDeleteArgs} args - Arguments to delete one Package_queue.
     * @example
     * // Delete one Package_queue
     * const Package_queue = await prisma.package_queue.delete({
     *   where: {
     *     // ... filter to delete one Package_queue
     *   }
     * })
     * 
     */
    delete<T extends package_queueDeleteArgs>(args: SelectSubset<T, package_queueDeleteArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Package_queue.
     * @param {package_queueUpdateArgs} args - Arguments to update one Package_queue.
     * @example
     * // Update one Package_queue
     * const package_queue = await prisma.package_queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends package_queueUpdateArgs>(args: SelectSubset<T, package_queueUpdateArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Package_queues.
     * @param {package_queueDeleteManyArgs} args - Arguments to filter Package_queues to delete.
     * @example
     * // Delete a few Package_queues
     * const { count } = await prisma.package_queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends package_queueDeleteManyArgs>(args?: SelectSubset<T, package_queueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Package_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Package_queues
     * const package_queue = await prisma.package_queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends package_queueUpdateManyArgs>(args: SelectSubset<T, package_queueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package_queue.
     * @param {package_queueUpsertArgs} args - Arguments to update or create a Package_queue.
     * @example
     * // Update or create a Package_queue
     * const package_queue = await prisma.package_queue.upsert({
     *   create: {
     *     // ... data to create a Package_queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package_queue we want to update
     *   }
     * })
     */
    upsert<T extends package_queueUpsertArgs>(args: SelectSubset<T, package_queueUpsertArgs<ExtArgs>>): Prisma__package_queueClient<$Result.GetResult<Prisma.$package_queuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Package_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueCountArgs} args - Arguments to filter Package_queues to count.
     * @example
     * // Count the number of Package_queues
     * const count = await prisma.package_queue.count({
     *   where: {
     *     // ... the filter for the Package_queues we want to count
     *   }
     * })
    **/
    count<T extends package_queueCountArgs>(
      args?: Subset<T, package_queueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Package_queueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_queueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Package_queueAggregateArgs>(args: Subset<T, Package_queueAggregateArgs>): Prisma.PrismaPromise<GetPackage_queueAggregateType<T>>

    /**
     * Group by Package_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_queueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends package_queueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: package_queueGroupByArgs['orderBy'] }
        : { orderBy?: package_queueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, package_queueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackage_queueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the package_queue model
   */
  readonly fields: package_queueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for package_queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__package_queueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the package_queue model
   */ 
  interface package_queueFieldRefs {
    readonly id: FieldRef<"package_queue", 'BigInt'>
    readonly medical_num: FieldRef<"package_queue", 'String'>
    readonly package_id: FieldRef<"package_queue", 'String'>
    readonly lab_id: FieldRef<"package_queue", 'String'>
    readonly patient_id: FieldRef<"package_queue", 'String'>
    readonly dependent_id: FieldRef<"package_queue", 'String'>
    readonly doctor_id: FieldRef<"package_queue", 'String'>
    readonly referdate: FieldRef<"package_queue", 'String'>
    readonly created_by: FieldRef<"package_queue", 'String'>
    readonly created_on: FieldRef<"package_queue", 'String'>
    readonly package_status: FieldRef<"package_queue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * package_queue findUnique
   */
  export type package_queueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter, which package_queue to fetch.
     */
    where: package_queueWhereUniqueInput
  }

  /**
   * package_queue findUniqueOrThrow
   */
  export type package_queueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter, which package_queue to fetch.
     */
    where: package_queueWhereUniqueInput
  }

  /**
   * package_queue findFirst
   */
  export type package_queueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter, which package_queue to fetch.
     */
    where?: package_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_queues to fetch.
     */
    orderBy?: package_queueOrderByWithRelationInput | package_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_queues.
     */
    cursor?: package_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_queues.
     */
    distinct?: Package_queueScalarFieldEnum | Package_queueScalarFieldEnum[]
  }

  /**
   * package_queue findFirstOrThrow
   */
  export type package_queueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter, which package_queue to fetch.
     */
    where?: package_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_queues to fetch.
     */
    orderBy?: package_queueOrderByWithRelationInput | package_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_queues.
     */
    cursor?: package_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_queues.
     */
    distinct?: Package_queueScalarFieldEnum | Package_queueScalarFieldEnum[]
  }

  /**
   * package_queue findMany
   */
  export type package_queueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter, which package_queues to fetch.
     */
    where?: package_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_queues to fetch.
     */
    orderBy?: package_queueOrderByWithRelationInput | package_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing package_queues.
     */
    cursor?: package_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_queues.
     */
    skip?: number
    distinct?: Package_queueScalarFieldEnum | Package_queueScalarFieldEnum[]
  }

  /**
   * package_queue create
   */
  export type package_queueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * The data needed to create a package_queue.
     */
    data?: XOR<package_queueCreateInput, package_queueUncheckedCreateInput>
  }

  /**
   * package_queue createMany
   */
  export type package_queueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many package_queues.
     */
    data: package_queueCreateManyInput | package_queueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * package_queue update
   */
  export type package_queueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * The data needed to update a package_queue.
     */
    data: XOR<package_queueUpdateInput, package_queueUncheckedUpdateInput>
    /**
     * Choose, which package_queue to update.
     */
    where: package_queueWhereUniqueInput
  }

  /**
   * package_queue updateMany
   */
  export type package_queueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update package_queues.
     */
    data: XOR<package_queueUpdateManyMutationInput, package_queueUncheckedUpdateManyInput>
    /**
     * Filter which package_queues to update
     */
    where?: package_queueWhereInput
  }

  /**
   * package_queue upsert
   */
  export type package_queueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * The filter to search for the package_queue to update in case it exists.
     */
    where: package_queueWhereUniqueInput
    /**
     * In case the package_queue found by the `where` argument doesn't exist, create a new package_queue with this data.
     */
    create: XOR<package_queueCreateInput, package_queueUncheckedCreateInput>
    /**
     * In case the package_queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<package_queueUpdateInput, package_queueUncheckedUpdateInput>
  }

  /**
   * package_queue delete
   */
  export type package_queueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
    /**
     * Filter which package_queue to delete.
     */
    where: package_queueWhereUniqueInput
  }

  /**
   * package_queue deleteMany
   */
  export type package_queueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which package_queues to delete
     */
    where?: package_queueWhereInput
  }

  /**
   * package_queue without action
   */
  export type package_queueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the package_queue
     */
    select?: package_queueSelect<ExtArgs> | null
  }


  /**
   * Model patient_dep_details
   */

  export type AggregatePatient_dep_details = {
    _count: Patient_dep_detailsCountAggregateOutputType | null
    _avg: Patient_dep_detailsAvgAggregateOutputType | null
    _sum: Patient_dep_detailsSumAggregateOutputType | null
    _min: Patient_dep_detailsMinAggregateOutputType | null
    _max: Patient_dep_detailsMaxAggregateOutputType | null
  }

  export type Patient_dep_detailsAvgAggregateOutputType = {
    patient_dep_id: number | null
    main_pat_id: number | null
    active: number | null
    role_id: number | null
    r_count: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Patient_dep_detailsSumAggregateOutputType = {
    patient_dep_id: number | null
    main_pat_id: number | null
    active: number | null
    role_id: number | null
    r_count: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Patient_dep_detailsMinAggregateOutputType = {
    patient_dep_id: number | null
    firstname: string | null
    lastname: string | null
    gender: string | null
    date_of_birth: Date | null
    age: string | null
    address: string | null
    city: string | null
    pincode: string | null
    mailid: string | null
    phonenum: string | null
    alt_phonenum: string | null
    relationship: string | null
    main_pat_id: number | null
    created_on: Date | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    patient_unique_id: string | null
    physician_id: string | null
    status: string | null
    r_count: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Patient_dep_detailsMaxAggregateOutputType = {
    patient_dep_id: number | null
    firstname: string | null
    lastname: string | null
    gender: string | null
    date_of_birth: Date | null
    age: string | null
    address: string | null
    city: string | null
    pincode: string | null
    mailid: string | null
    phonenum: string | null
    alt_phonenum: string | null
    relationship: string | null
    main_pat_id: number | null
    created_on: Date | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    patient_unique_id: string | null
    physician_id: string | null
    status: string | null
    r_count: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Patient_dep_detailsCountAggregateOutputType = {
    patient_dep_id: number
    firstname: number
    lastname: number
    gender: number
    date_of_birth: number
    age: number
    address: number
    city: number
    pincode: number
    mailid: number
    phonenum: number
    alt_phonenum: number
    relationship: number
    main_pat_id: number
    created_on: number
    updated_on: number
    active: number
    role_id: number
    patient_unique_id: number
    physician_id: number
    status: number
    r_count: number
    count: number
    prescribe_receipt: number
    _all: number
  }


  export type Patient_dep_detailsAvgAggregateInputType = {
    patient_dep_id?: true
    main_pat_id?: true
    active?: true
    role_id?: true
    r_count?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Patient_dep_detailsSumAggregateInputType = {
    patient_dep_id?: true
    main_pat_id?: true
    active?: true
    role_id?: true
    r_count?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Patient_dep_detailsMinAggregateInputType = {
    patient_dep_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    relationship?: true
    main_pat_id?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Patient_dep_detailsMaxAggregateInputType = {
    patient_dep_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    relationship?: true
    main_pat_id?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Patient_dep_detailsCountAggregateInputType = {
    patient_dep_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    relationship?: true
    main_pat_id?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    count?: true
    prescribe_receipt?: true
    _all?: true
  }

  export type Patient_dep_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_dep_details to aggregate.
     */
    where?: patient_dep_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_dep_details to fetch.
     */
    orderBy?: patient_dep_detailsOrderByWithRelationInput | patient_dep_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_dep_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_dep_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_dep_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_dep_details
    **/
    _count?: true | Patient_dep_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_dep_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_dep_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_dep_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_dep_detailsMaxAggregateInputType
  }

  export type GetPatient_dep_detailsAggregateType<T extends Patient_dep_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_dep_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_dep_details[P]>
      : GetScalarType<T[P], AggregatePatient_dep_details[P]>
  }




  export type patient_dep_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_dep_detailsWhereInput
    orderBy?: patient_dep_detailsOrderByWithAggregationInput | patient_dep_detailsOrderByWithAggregationInput[]
    by: Patient_dep_detailsScalarFieldEnum[] | Patient_dep_detailsScalarFieldEnum
    having?: patient_dep_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_dep_detailsCountAggregateInputType | true
    _avg?: Patient_dep_detailsAvgAggregateInputType
    _sum?: Patient_dep_detailsSumAggregateInputType
    _min?: Patient_dep_detailsMinAggregateInputType
    _max?: Patient_dep_detailsMaxAggregateInputType
  }

  export type Patient_dep_detailsGroupByOutputType = {
    patient_dep_id: number
    firstname: string | null
    lastname: string
    gender: string | null
    date_of_birth: Date
    age: string | null
    address: string | null
    city: string | null
    pincode: string
    mailid: string | null
    phonenum: string | null
    alt_phonenum: string
    relationship: string
    main_pat_id: number
    created_on: Date | null
    updated_on: Date | null
    active: number | null
    role_id: number
    patient_unique_id: string
    physician_id: string
    status: string
    r_count: number
    count: number
    prescribe_receipt: number
    _count: Patient_dep_detailsCountAggregateOutputType | null
    _avg: Patient_dep_detailsAvgAggregateOutputType | null
    _sum: Patient_dep_detailsSumAggregateOutputType | null
    _min: Patient_dep_detailsMinAggregateOutputType | null
    _max: Patient_dep_detailsMaxAggregateOutputType | null
  }

  type GetPatient_dep_detailsGroupByPayload<T extends patient_dep_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_dep_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_dep_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_dep_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_dep_detailsGroupByOutputType[P]>
        }
      >
    >


  export type patient_dep_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_dep_id?: boolean
    firstname?: boolean
    lastname?: boolean
    gender?: boolean
    date_of_birth?: boolean
    age?: boolean
    address?: boolean
    city?: boolean
    pincode?: boolean
    mailid?: boolean
    phonenum?: boolean
    alt_phonenum?: boolean
    relationship?: boolean
    main_pat_id?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    status?: boolean
    r_count?: boolean
    count?: boolean
    prescribe_receipt?: boolean
  }, ExtArgs["result"]["patient_dep_details"]>


  export type patient_dep_detailsSelectScalar = {
    patient_dep_id?: boolean
    firstname?: boolean
    lastname?: boolean
    gender?: boolean
    date_of_birth?: boolean
    age?: boolean
    address?: boolean
    city?: boolean
    pincode?: boolean
    mailid?: boolean
    phonenum?: boolean
    alt_phonenum?: boolean
    relationship?: boolean
    main_pat_id?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    status?: boolean
    r_count?: boolean
    count?: boolean
    prescribe_receipt?: boolean
  }


  export type $patient_dep_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_dep_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      patient_dep_id: number
      firstname: string | null
      lastname: string
      gender: string | null
      date_of_birth: Date
      age: string | null
      address: string | null
      city: string | null
      pincode: string
      mailid: string | null
      phonenum: string | null
      alt_phonenum: string
      relationship: string
      main_pat_id: number
      created_on: Date | null
      updated_on: Date | null
      active: number | null
      role_id: number
      patient_unique_id: string
      physician_id: string
      status: string
      r_count: number
      count: number
      prescribe_receipt: number
    }, ExtArgs["result"]["patient_dep_details"]>
    composites: {}
  }

  type patient_dep_detailsGetPayload<S extends boolean | null | undefined | patient_dep_detailsDefaultArgs> = $Result.GetResult<Prisma.$patient_dep_detailsPayload, S>

  type patient_dep_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<patient_dep_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Patient_dep_detailsCountAggregateInputType | true
    }

  export interface patient_dep_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_dep_details'], meta: { name: 'patient_dep_details' } }
    /**
     * Find zero or one Patient_dep_details that matches the filter.
     * @param {patient_dep_detailsFindUniqueArgs} args - Arguments to find a Patient_dep_details
     * @example
     * // Get one Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_dep_detailsFindUniqueArgs>(args: SelectSubset<T, patient_dep_detailsFindUniqueArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient_dep_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {patient_dep_detailsFindUniqueOrThrowArgs} args - Arguments to find a Patient_dep_details
     * @example
     * // Get one Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_dep_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_dep_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient_dep_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsFindFirstArgs} args - Arguments to find a Patient_dep_details
     * @example
     * // Get one Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_dep_detailsFindFirstArgs>(args?: SelectSubset<T, patient_dep_detailsFindFirstArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient_dep_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsFindFirstOrThrowArgs} args - Arguments to find a Patient_dep_details
     * @example
     * // Get one Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_dep_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_dep_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patient_dep_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findMany()
     * 
     * // Get first 10 Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.findMany({ take: 10 })
     * 
     * // Only select the `patient_dep_id`
     * const patient_dep_detailsWithPatient_dep_idOnly = await prisma.patient_dep_details.findMany({ select: { patient_dep_id: true } })
     * 
     */
    findMany<T extends patient_dep_detailsFindManyArgs>(args?: SelectSubset<T, patient_dep_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient_dep_details.
     * @param {patient_dep_detailsCreateArgs} args - Arguments to create a Patient_dep_details.
     * @example
     * // Create one Patient_dep_details
     * const Patient_dep_details = await prisma.patient_dep_details.create({
     *   data: {
     *     // ... data to create a Patient_dep_details
     *   }
     * })
     * 
     */
    create<T extends patient_dep_detailsCreateArgs>(args: SelectSubset<T, patient_dep_detailsCreateArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patient_dep_details.
     * @param {patient_dep_detailsCreateManyArgs} args - Arguments to create many Patient_dep_details.
     * @example
     * // Create many Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_dep_detailsCreateManyArgs>(args?: SelectSubset<T, patient_dep_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient_dep_details.
     * @param {patient_dep_detailsDeleteArgs} args - Arguments to delete one Patient_dep_details.
     * @example
     * // Delete one Patient_dep_details
     * const Patient_dep_details = await prisma.patient_dep_details.delete({
     *   where: {
     *     // ... filter to delete one Patient_dep_details
     *   }
     * })
     * 
     */
    delete<T extends patient_dep_detailsDeleteArgs>(args: SelectSubset<T, patient_dep_detailsDeleteArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient_dep_details.
     * @param {patient_dep_detailsUpdateArgs} args - Arguments to update one Patient_dep_details.
     * @example
     * // Update one Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_dep_detailsUpdateArgs>(args: SelectSubset<T, patient_dep_detailsUpdateArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patient_dep_details.
     * @param {patient_dep_detailsDeleteManyArgs} args - Arguments to filter Patient_dep_details to delete.
     * @example
     * // Delete a few Patient_dep_details
     * const { count } = await prisma.patient_dep_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_dep_detailsDeleteManyArgs>(args?: SelectSubset<T, patient_dep_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_dep_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_dep_detailsUpdateManyArgs>(args: SelectSubset<T, patient_dep_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient_dep_details.
     * @param {patient_dep_detailsUpsertArgs} args - Arguments to update or create a Patient_dep_details.
     * @example
     * // Update or create a Patient_dep_details
     * const patient_dep_details = await prisma.patient_dep_details.upsert({
     *   create: {
     *     // ... data to create a Patient_dep_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_dep_details we want to update
     *   }
     * })
     */
    upsert<T extends patient_dep_detailsUpsertArgs>(args: SelectSubset<T, patient_dep_detailsUpsertArgs<ExtArgs>>): Prisma__patient_dep_detailsClient<$Result.GetResult<Prisma.$patient_dep_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patient_dep_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsCountArgs} args - Arguments to filter Patient_dep_details to count.
     * @example
     * // Count the number of Patient_dep_details
     * const count = await prisma.patient_dep_details.count({
     *   where: {
     *     // ... the filter for the Patient_dep_details we want to count
     *   }
     * })
    **/
    count<T extends patient_dep_detailsCountArgs>(
      args?: Subset<T, patient_dep_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_dep_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_dep_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_dep_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_dep_detailsAggregateArgs>(args: Subset<T, Patient_dep_detailsAggregateArgs>): Prisma.PrismaPromise<GetPatient_dep_detailsAggregateType<T>>

    /**
     * Group by Patient_dep_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_dep_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_dep_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_dep_detailsGroupByArgs['orderBy'] }
        : { orderBy?: patient_dep_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_dep_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_dep_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_dep_details model
   */
  readonly fields: patient_dep_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_dep_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_dep_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_dep_details model
   */ 
  interface patient_dep_detailsFieldRefs {
    readonly patient_dep_id: FieldRef<"patient_dep_details", 'Int'>
    readonly firstname: FieldRef<"patient_dep_details", 'String'>
    readonly lastname: FieldRef<"patient_dep_details", 'String'>
    readonly gender: FieldRef<"patient_dep_details", 'String'>
    readonly date_of_birth: FieldRef<"patient_dep_details", 'DateTime'>
    readonly age: FieldRef<"patient_dep_details", 'String'>
    readonly address: FieldRef<"patient_dep_details", 'String'>
    readonly city: FieldRef<"patient_dep_details", 'String'>
    readonly pincode: FieldRef<"patient_dep_details", 'String'>
    readonly mailid: FieldRef<"patient_dep_details", 'String'>
    readonly phonenum: FieldRef<"patient_dep_details", 'String'>
    readonly alt_phonenum: FieldRef<"patient_dep_details", 'String'>
    readonly relationship: FieldRef<"patient_dep_details", 'String'>
    readonly main_pat_id: FieldRef<"patient_dep_details", 'Int'>
    readonly created_on: FieldRef<"patient_dep_details", 'DateTime'>
    readonly updated_on: FieldRef<"patient_dep_details", 'DateTime'>
    readonly active: FieldRef<"patient_dep_details", 'Int'>
    readonly role_id: FieldRef<"patient_dep_details", 'Int'>
    readonly patient_unique_id: FieldRef<"patient_dep_details", 'String'>
    readonly physician_id: FieldRef<"patient_dep_details", 'String'>
    readonly status: FieldRef<"patient_dep_details", 'String'>
    readonly r_count: FieldRef<"patient_dep_details", 'Int'>
    readonly count: FieldRef<"patient_dep_details", 'Int'>
    readonly prescribe_receipt: FieldRef<"patient_dep_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * patient_dep_details findUnique
   */
  export type patient_dep_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter, which patient_dep_details to fetch.
     */
    where: patient_dep_detailsWhereUniqueInput
  }

  /**
   * patient_dep_details findUniqueOrThrow
   */
  export type patient_dep_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter, which patient_dep_details to fetch.
     */
    where: patient_dep_detailsWhereUniqueInput
  }

  /**
   * patient_dep_details findFirst
   */
  export type patient_dep_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter, which patient_dep_details to fetch.
     */
    where?: patient_dep_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_dep_details to fetch.
     */
    orderBy?: patient_dep_detailsOrderByWithRelationInput | patient_dep_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_dep_details.
     */
    cursor?: patient_dep_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_dep_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_dep_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_dep_details.
     */
    distinct?: Patient_dep_detailsScalarFieldEnum | Patient_dep_detailsScalarFieldEnum[]
  }

  /**
   * patient_dep_details findFirstOrThrow
   */
  export type patient_dep_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter, which patient_dep_details to fetch.
     */
    where?: patient_dep_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_dep_details to fetch.
     */
    orderBy?: patient_dep_detailsOrderByWithRelationInput | patient_dep_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_dep_details.
     */
    cursor?: patient_dep_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_dep_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_dep_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_dep_details.
     */
    distinct?: Patient_dep_detailsScalarFieldEnum | Patient_dep_detailsScalarFieldEnum[]
  }

  /**
   * patient_dep_details findMany
   */
  export type patient_dep_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter, which patient_dep_details to fetch.
     */
    where?: patient_dep_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_dep_details to fetch.
     */
    orderBy?: patient_dep_detailsOrderByWithRelationInput | patient_dep_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_dep_details.
     */
    cursor?: patient_dep_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_dep_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_dep_details.
     */
    skip?: number
    distinct?: Patient_dep_detailsScalarFieldEnum | Patient_dep_detailsScalarFieldEnum[]
  }

  /**
   * patient_dep_details create
   */
  export type patient_dep_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a patient_dep_details.
     */
    data: XOR<patient_dep_detailsCreateInput, patient_dep_detailsUncheckedCreateInput>
  }

  /**
   * patient_dep_details createMany
   */
  export type patient_dep_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_dep_details.
     */
    data: patient_dep_detailsCreateManyInput | patient_dep_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_dep_details update
   */
  export type patient_dep_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a patient_dep_details.
     */
    data: XOR<patient_dep_detailsUpdateInput, patient_dep_detailsUncheckedUpdateInput>
    /**
     * Choose, which patient_dep_details to update.
     */
    where: patient_dep_detailsWhereUniqueInput
  }

  /**
   * patient_dep_details updateMany
   */
  export type patient_dep_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_dep_details.
     */
    data: XOR<patient_dep_detailsUpdateManyMutationInput, patient_dep_detailsUncheckedUpdateManyInput>
    /**
     * Filter which patient_dep_details to update
     */
    where?: patient_dep_detailsWhereInput
  }

  /**
   * patient_dep_details upsert
   */
  export type patient_dep_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the patient_dep_details to update in case it exists.
     */
    where: patient_dep_detailsWhereUniqueInput
    /**
     * In case the patient_dep_details found by the `where` argument doesn't exist, create a new patient_dep_details with this data.
     */
    create: XOR<patient_dep_detailsCreateInput, patient_dep_detailsUncheckedCreateInput>
    /**
     * In case the patient_dep_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_dep_detailsUpdateInput, patient_dep_detailsUncheckedUpdateInput>
  }

  /**
   * patient_dep_details delete
   */
  export type patient_dep_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
    /**
     * Filter which patient_dep_details to delete.
     */
    where: patient_dep_detailsWhereUniqueInput
  }

  /**
   * patient_dep_details deleteMany
   */
  export type patient_dep_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_dep_details to delete
     */
    where?: patient_dep_detailsWhereInput
  }

  /**
   * patient_dep_details without action
   */
  export type patient_dep_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_dep_details
     */
    select?: patient_dep_detailsSelect<ExtArgs> | null
  }


  /**
   * Model patient_doctor_mapping
   */

  export type AggregatePatient_doctor_mapping = {
    _count: Patient_doctor_mappingCountAggregateOutputType | null
    _avg: Patient_doctor_mappingAvgAggregateOutputType | null
    _sum: Patient_doctor_mappingSumAggregateOutputType | null
    _min: Patient_doctor_mappingMinAggregateOutputType | null
    _max: Patient_doctor_mappingMaxAggregateOutputType | null
  }

  export type Patient_doctor_mappingAvgAggregateOutputType = {
    patient_doctor_mapping_id: number | null
    referral_patient_id: number | null
    prev_physician_id: number | null
    new_physician_id: number | null
  }

  export type Patient_doctor_mappingSumAggregateOutputType = {
    patient_doctor_mapping_id: number | null
    referral_patient_id: number | null
    prev_physician_id: number | null
    new_physician_id: number | null
  }

  export type Patient_doctor_mappingMinAggregateOutputType = {
    patient_doctor_mapping_id: number | null
    referral_patient_id: number | null
    prev_physician_id: number | null
    new_physician_id: number | null
    patient_unique_id: string | null
    added_date: Date | null
  }

  export type Patient_doctor_mappingMaxAggregateOutputType = {
    patient_doctor_mapping_id: number | null
    referral_patient_id: number | null
    prev_physician_id: number | null
    new_physician_id: number | null
    patient_unique_id: string | null
    added_date: Date | null
  }

  export type Patient_doctor_mappingCountAggregateOutputType = {
    patient_doctor_mapping_id: number
    referral_patient_id: number
    prev_physician_id: number
    new_physician_id: number
    patient_unique_id: number
    added_date: number
    _all: number
  }


  export type Patient_doctor_mappingAvgAggregateInputType = {
    patient_doctor_mapping_id?: true
    referral_patient_id?: true
    prev_physician_id?: true
    new_physician_id?: true
  }

  export type Patient_doctor_mappingSumAggregateInputType = {
    patient_doctor_mapping_id?: true
    referral_patient_id?: true
    prev_physician_id?: true
    new_physician_id?: true
  }

  export type Patient_doctor_mappingMinAggregateInputType = {
    patient_doctor_mapping_id?: true
    referral_patient_id?: true
    prev_physician_id?: true
    new_physician_id?: true
    patient_unique_id?: true
    added_date?: true
  }

  export type Patient_doctor_mappingMaxAggregateInputType = {
    patient_doctor_mapping_id?: true
    referral_patient_id?: true
    prev_physician_id?: true
    new_physician_id?: true
    patient_unique_id?: true
    added_date?: true
  }

  export type Patient_doctor_mappingCountAggregateInputType = {
    patient_doctor_mapping_id?: true
    referral_patient_id?: true
    prev_physician_id?: true
    new_physician_id?: true
    patient_unique_id?: true
    added_date?: true
    _all?: true
  }

  export type Patient_doctor_mappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_doctor_mapping to aggregate.
     */
    where?: patient_doctor_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_doctor_mappings to fetch.
     */
    orderBy?: patient_doctor_mappingOrderByWithRelationInput | patient_doctor_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_doctor_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_doctor_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_doctor_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_doctor_mappings
    **/
    _count?: true | Patient_doctor_mappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_doctor_mappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_doctor_mappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_doctor_mappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_doctor_mappingMaxAggregateInputType
  }

  export type GetPatient_doctor_mappingAggregateType<T extends Patient_doctor_mappingAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_doctor_mapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_doctor_mapping[P]>
      : GetScalarType<T[P], AggregatePatient_doctor_mapping[P]>
  }




  export type patient_doctor_mappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_doctor_mappingWhereInput
    orderBy?: patient_doctor_mappingOrderByWithAggregationInput | patient_doctor_mappingOrderByWithAggregationInput[]
    by: Patient_doctor_mappingScalarFieldEnum[] | Patient_doctor_mappingScalarFieldEnum
    having?: patient_doctor_mappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_doctor_mappingCountAggregateInputType | true
    _avg?: Patient_doctor_mappingAvgAggregateInputType
    _sum?: Patient_doctor_mappingSumAggregateInputType
    _min?: Patient_doctor_mappingMinAggregateInputType
    _max?: Patient_doctor_mappingMaxAggregateInputType
  }

  export type Patient_doctor_mappingGroupByOutputType = {
    patient_doctor_mapping_id: number
    referral_patient_id: number
    prev_physician_id: number
    new_physician_id: number
    patient_unique_id: string
    added_date: Date
    _count: Patient_doctor_mappingCountAggregateOutputType | null
    _avg: Patient_doctor_mappingAvgAggregateOutputType | null
    _sum: Patient_doctor_mappingSumAggregateOutputType | null
    _min: Patient_doctor_mappingMinAggregateOutputType | null
    _max: Patient_doctor_mappingMaxAggregateOutputType | null
  }

  type GetPatient_doctor_mappingGroupByPayload<T extends patient_doctor_mappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_doctor_mappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_doctor_mappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_doctor_mappingGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_doctor_mappingGroupByOutputType[P]>
        }
      >
    >


  export type patient_doctor_mappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_doctor_mapping_id?: boolean
    referral_patient_id?: boolean
    prev_physician_id?: boolean
    new_physician_id?: boolean
    patient_unique_id?: boolean
    added_date?: boolean
  }, ExtArgs["result"]["patient_doctor_mapping"]>


  export type patient_doctor_mappingSelectScalar = {
    patient_doctor_mapping_id?: boolean
    referral_patient_id?: boolean
    prev_physician_id?: boolean
    new_physician_id?: boolean
    patient_unique_id?: boolean
    added_date?: boolean
  }


  export type $patient_doctor_mappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_doctor_mapping"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      patient_doctor_mapping_id: number
      referral_patient_id: number
      prev_physician_id: number
      new_physician_id: number
      patient_unique_id: string
      added_date: Date
    }, ExtArgs["result"]["patient_doctor_mapping"]>
    composites: {}
  }

  type patient_doctor_mappingGetPayload<S extends boolean | null | undefined | patient_doctor_mappingDefaultArgs> = $Result.GetResult<Prisma.$patient_doctor_mappingPayload, S>

  type patient_doctor_mappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<patient_doctor_mappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Patient_doctor_mappingCountAggregateInputType | true
    }

  export interface patient_doctor_mappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_doctor_mapping'], meta: { name: 'patient_doctor_mapping' } }
    /**
     * Find zero or one Patient_doctor_mapping that matches the filter.
     * @param {patient_doctor_mappingFindUniqueArgs} args - Arguments to find a Patient_doctor_mapping
     * @example
     * // Get one Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_doctor_mappingFindUniqueArgs>(args: SelectSubset<T, patient_doctor_mappingFindUniqueArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient_doctor_mapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {patient_doctor_mappingFindUniqueOrThrowArgs} args - Arguments to find a Patient_doctor_mapping
     * @example
     * // Get one Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_doctor_mappingFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_doctor_mappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient_doctor_mapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingFindFirstArgs} args - Arguments to find a Patient_doctor_mapping
     * @example
     * // Get one Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_doctor_mappingFindFirstArgs>(args?: SelectSubset<T, patient_doctor_mappingFindFirstArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient_doctor_mapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingFindFirstOrThrowArgs} args - Arguments to find a Patient_doctor_mapping
     * @example
     * // Get one Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_doctor_mappingFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_doctor_mappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patient_doctor_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_doctor_mappings
     * const patient_doctor_mappings = await prisma.patient_doctor_mapping.findMany()
     * 
     * // Get first 10 Patient_doctor_mappings
     * const patient_doctor_mappings = await prisma.patient_doctor_mapping.findMany({ take: 10 })
     * 
     * // Only select the `patient_doctor_mapping_id`
     * const patient_doctor_mappingWithPatient_doctor_mapping_idOnly = await prisma.patient_doctor_mapping.findMany({ select: { patient_doctor_mapping_id: true } })
     * 
     */
    findMany<T extends patient_doctor_mappingFindManyArgs>(args?: SelectSubset<T, patient_doctor_mappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient_doctor_mapping.
     * @param {patient_doctor_mappingCreateArgs} args - Arguments to create a Patient_doctor_mapping.
     * @example
     * // Create one Patient_doctor_mapping
     * const Patient_doctor_mapping = await prisma.patient_doctor_mapping.create({
     *   data: {
     *     // ... data to create a Patient_doctor_mapping
     *   }
     * })
     * 
     */
    create<T extends patient_doctor_mappingCreateArgs>(args: SelectSubset<T, patient_doctor_mappingCreateArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patient_doctor_mappings.
     * @param {patient_doctor_mappingCreateManyArgs} args - Arguments to create many Patient_doctor_mappings.
     * @example
     * // Create many Patient_doctor_mappings
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_doctor_mappingCreateManyArgs>(args?: SelectSubset<T, patient_doctor_mappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient_doctor_mapping.
     * @param {patient_doctor_mappingDeleteArgs} args - Arguments to delete one Patient_doctor_mapping.
     * @example
     * // Delete one Patient_doctor_mapping
     * const Patient_doctor_mapping = await prisma.patient_doctor_mapping.delete({
     *   where: {
     *     // ... filter to delete one Patient_doctor_mapping
     *   }
     * })
     * 
     */
    delete<T extends patient_doctor_mappingDeleteArgs>(args: SelectSubset<T, patient_doctor_mappingDeleteArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient_doctor_mapping.
     * @param {patient_doctor_mappingUpdateArgs} args - Arguments to update one Patient_doctor_mapping.
     * @example
     * // Update one Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_doctor_mappingUpdateArgs>(args: SelectSubset<T, patient_doctor_mappingUpdateArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patient_doctor_mappings.
     * @param {patient_doctor_mappingDeleteManyArgs} args - Arguments to filter Patient_doctor_mappings to delete.
     * @example
     * // Delete a few Patient_doctor_mappings
     * const { count } = await prisma.patient_doctor_mapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_doctor_mappingDeleteManyArgs>(args?: SelectSubset<T, patient_doctor_mappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_doctor_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_doctor_mappings
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_doctor_mappingUpdateManyArgs>(args: SelectSubset<T, patient_doctor_mappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient_doctor_mapping.
     * @param {patient_doctor_mappingUpsertArgs} args - Arguments to update or create a Patient_doctor_mapping.
     * @example
     * // Update or create a Patient_doctor_mapping
     * const patient_doctor_mapping = await prisma.patient_doctor_mapping.upsert({
     *   create: {
     *     // ... data to create a Patient_doctor_mapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_doctor_mapping we want to update
     *   }
     * })
     */
    upsert<T extends patient_doctor_mappingUpsertArgs>(args: SelectSubset<T, patient_doctor_mappingUpsertArgs<ExtArgs>>): Prisma__patient_doctor_mappingClient<$Result.GetResult<Prisma.$patient_doctor_mappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patient_doctor_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingCountArgs} args - Arguments to filter Patient_doctor_mappings to count.
     * @example
     * // Count the number of Patient_doctor_mappings
     * const count = await prisma.patient_doctor_mapping.count({
     *   where: {
     *     // ... the filter for the Patient_doctor_mappings we want to count
     *   }
     * })
    **/
    count<T extends patient_doctor_mappingCountArgs>(
      args?: Subset<T, patient_doctor_mappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_doctor_mappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_doctor_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_doctor_mappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_doctor_mappingAggregateArgs>(args: Subset<T, Patient_doctor_mappingAggregateArgs>): Prisma.PrismaPromise<GetPatient_doctor_mappingAggregateType<T>>

    /**
     * Group by Patient_doctor_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_doctor_mappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_doctor_mappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_doctor_mappingGroupByArgs['orderBy'] }
        : { orderBy?: patient_doctor_mappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_doctor_mappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_doctor_mappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_doctor_mapping model
   */
  readonly fields: patient_doctor_mappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_doctor_mapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_doctor_mappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_doctor_mapping model
   */ 
  interface patient_doctor_mappingFieldRefs {
    readonly patient_doctor_mapping_id: FieldRef<"patient_doctor_mapping", 'Int'>
    readonly referral_patient_id: FieldRef<"patient_doctor_mapping", 'Int'>
    readonly prev_physician_id: FieldRef<"patient_doctor_mapping", 'Int'>
    readonly new_physician_id: FieldRef<"patient_doctor_mapping", 'Int'>
    readonly patient_unique_id: FieldRef<"patient_doctor_mapping", 'String'>
    readonly added_date: FieldRef<"patient_doctor_mapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patient_doctor_mapping findUnique
   */
  export type patient_doctor_mappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter, which patient_doctor_mapping to fetch.
     */
    where: patient_doctor_mappingWhereUniqueInput
  }

  /**
   * patient_doctor_mapping findUniqueOrThrow
   */
  export type patient_doctor_mappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter, which patient_doctor_mapping to fetch.
     */
    where: patient_doctor_mappingWhereUniqueInput
  }

  /**
   * patient_doctor_mapping findFirst
   */
  export type patient_doctor_mappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter, which patient_doctor_mapping to fetch.
     */
    where?: patient_doctor_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_doctor_mappings to fetch.
     */
    orderBy?: patient_doctor_mappingOrderByWithRelationInput | patient_doctor_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_doctor_mappings.
     */
    cursor?: patient_doctor_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_doctor_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_doctor_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_doctor_mappings.
     */
    distinct?: Patient_doctor_mappingScalarFieldEnum | Patient_doctor_mappingScalarFieldEnum[]
  }

  /**
   * patient_doctor_mapping findFirstOrThrow
   */
  export type patient_doctor_mappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter, which patient_doctor_mapping to fetch.
     */
    where?: patient_doctor_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_doctor_mappings to fetch.
     */
    orderBy?: patient_doctor_mappingOrderByWithRelationInput | patient_doctor_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_doctor_mappings.
     */
    cursor?: patient_doctor_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_doctor_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_doctor_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_doctor_mappings.
     */
    distinct?: Patient_doctor_mappingScalarFieldEnum | Patient_doctor_mappingScalarFieldEnum[]
  }

  /**
   * patient_doctor_mapping findMany
   */
  export type patient_doctor_mappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter, which patient_doctor_mappings to fetch.
     */
    where?: patient_doctor_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_doctor_mappings to fetch.
     */
    orderBy?: patient_doctor_mappingOrderByWithRelationInput | patient_doctor_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_doctor_mappings.
     */
    cursor?: patient_doctor_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_doctor_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_doctor_mappings.
     */
    skip?: number
    distinct?: Patient_doctor_mappingScalarFieldEnum | Patient_doctor_mappingScalarFieldEnum[]
  }

  /**
   * patient_doctor_mapping create
   */
  export type patient_doctor_mappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * The data needed to create a patient_doctor_mapping.
     */
    data: XOR<patient_doctor_mappingCreateInput, patient_doctor_mappingUncheckedCreateInput>
  }

  /**
   * patient_doctor_mapping createMany
   */
  export type patient_doctor_mappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_doctor_mappings.
     */
    data: patient_doctor_mappingCreateManyInput | patient_doctor_mappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_doctor_mapping update
   */
  export type patient_doctor_mappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * The data needed to update a patient_doctor_mapping.
     */
    data: XOR<patient_doctor_mappingUpdateInput, patient_doctor_mappingUncheckedUpdateInput>
    /**
     * Choose, which patient_doctor_mapping to update.
     */
    where: patient_doctor_mappingWhereUniqueInput
  }

  /**
   * patient_doctor_mapping updateMany
   */
  export type patient_doctor_mappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_doctor_mappings.
     */
    data: XOR<patient_doctor_mappingUpdateManyMutationInput, patient_doctor_mappingUncheckedUpdateManyInput>
    /**
     * Filter which patient_doctor_mappings to update
     */
    where?: patient_doctor_mappingWhereInput
  }

  /**
   * patient_doctor_mapping upsert
   */
  export type patient_doctor_mappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * The filter to search for the patient_doctor_mapping to update in case it exists.
     */
    where: patient_doctor_mappingWhereUniqueInput
    /**
     * In case the patient_doctor_mapping found by the `where` argument doesn't exist, create a new patient_doctor_mapping with this data.
     */
    create: XOR<patient_doctor_mappingCreateInput, patient_doctor_mappingUncheckedCreateInput>
    /**
     * In case the patient_doctor_mapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_doctor_mappingUpdateInput, patient_doctor_mappingUncheckedUpdateInput>
  }

  /**
   * patient_doctor_mapping delete
   */
  export type patient_doctor_mappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
    /**
     * Filter which patient_doctor_mapping to delete.
     */
    where: patient_doctor_mappingWhereUniqueInput
  }

  /**
   * patient_doctor_mapping deleteMany
   */
  export type patient_doctor_mappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_doctor_mappings to delete
     */
    where?: patient_doctor_mappingWhereInput
  }

  /**
   * patient_doctor_mapping without action
   */
  export type patient_doctor_mappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_doctor_mapping
     */
    select?: patient_doctor_mappingSelect<ExtArgs> | null
  }


  /**
   * Model patient_parameter
   */

  export type AggregatePatient_parameter = {
    _count: Patient_parameterCountAggregateOutputType | null
    _avg: Patient_parameterAvgAggregateOutputType | null
    _sum: Patient_parameterSumAggregateOutputType | null
    _min: Patient_parameterMinAggregateOutputType | null
    _max: Patient_parameterMaxAggregateOutputType | null
  }

  export type Patient_parameterAvgAggregateOutputType = {
    parameter_id: number | null
    blood_group: number | null
    referral_patient_id: number | null
    dependent_id: number | null
  }

  export type Patient_parameterSumAggregateOutputType = {
    parameter_id: number | null
    blood_group: number | null
    referral_patient_id: number | null
    dependent_id: number | null
  }

  export type Patient_parameterMinAggregateOutputType = {
    parameter_id: number | null
    date_of_birth: Date | null
    known_allergies: string | null
    previous_medical_history: string | null
    blood_group: number | null
    diabetic: string | null
    hypertension: string | null
    referral_patient_id: number | null
    dependent_id: number | null
    created_on: string | null
  }

  export type Patient_parameterMaxAggregateOutputType = {
    parameter_id: number | null
    date_of_birth: Date | null
    known_allergies: string | null
    previous_medical_history: string | null
    blood_group: number | null
    diabetic: string | null
    hypertension: string | null
    referral_patient_id: number | null
    dependent_id: number | null
    created_on: string | null
  }

  export type Patient_parameterCountAggregateOutputType = {
    parameter_id: number
    date_of_birth: number
    known_allergies: number
    previous_medical_history: number
    blood_group: number
    diabetic: number
    hypertension: number
    referral_patient_id: number
    dependent_id: number
    created_on: number
    _all: number
  }


  export type Patient_parameterAvgAggregateInputType = {
    parameter_id?: true
    blood_group?: true
    referral_patient_id?: true
    dependent_id?: true
  }

  export type Patient_parameterSumAggregateInputType = {
    parameter_id?: true
    blood_group?: true
    referral_patient_id?: true
    dependent_id?: true
  }

  export type Patient_parameterMinAggregateInputType = {
    parameter_id?: true
    date_of_birth?: true
    known_allergies?: true
    previous_medical_history?: true
    blood_group?: true
    diabetic?: true
    hypertension?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
  }

  export type Patient_parameterMaxAggregateInputType = {
    parameter_id?: true
    date_of_birth?: true
    known_allergies?: true
    previous_medical_history?: true
    blood_group?: true
    diabetic?: true
    hypertension?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
  }

  export type Patient_parameterCountAggregateInputType = {
    parameter_id?: true
    date_of_birth?: true
    known_allergies?: true
    previous_medical_history?: true
    blood_group?: true
    diabetic?: true
    hypertension?: true
    referral_patient_id?: true
    dependent_id?: true
    created_on?: true
    _all?: true
  }

  export type Patient_parameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_parameter to aggregate.
     */
    where?: patient_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_parameters to fetch.
     */
    orderBy?: patient_parameterOrderByWithRelationInput | patient_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_parameters
    **/
    _count?: true | Patient_parameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_parameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_parameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_parameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_parameterMaxAggregateInputType
  }

  export type GetPatient_parameterAggregateType<T extends Patient_parameterAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_parameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_parameter[P]>
      : GetScalarType<T[P], AggregatePatient_parameter[P]>
  }




  export type patient_parameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_parameterWhereInput
    orderBy?: patient_parameterOrderByWithAggregationInput | patient_parameterOrderByWithAggregationInput[]
    by: Patient_parameterScalarFieldEnum[] | Patient_parameterScalarFieldEnum
    having?: patient_parameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_parameterCountAggregateInputType | true
    _avg?: Patient_parameterAvgAggregateInputType
    _sum?: Patient_parameterSumAggregateInputType
    _min?: Patient_parameterMinAggregateInputType
    _max?: Patient_parameterMaxAggregateInputType
  }

  export type Patient_parameterGroupByOutputType = {
    parameter_id: number
    date_of_birth: Date
    known_allergies: string
    previous_medical_history: string
    blood_group: number | null
    diabetic: string | null
    hypertension: string | null
    referral_patient_id: number
    dependent_id: number
    created_on: string | null
    _count: Patient_parameterCountAggregateOutputType | null
    _avg: Patient_parameterAvgAggregateOutputType | null
    _sum: Patient_parameterSumAggregateOutputType | null
    _min: Patient_parameterMinAggregateOutputType | null
    _max: Patient_parameterMaxAggregateOutputType | null
  }

  type GetPatient_parameterGroupByPayload<T extends patient_parameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_parameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_parameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_parameterGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_parameterGroupByOutputType[P]>
        }
      >
    >


  export type patient_parameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parameter_id?: boolean
    date_of_birth?: boolean
    known_allergies?: boolean
    previous_medical_history?: boolean
    blood_group?: boolean
    diabetic?: boolean
    hypertension?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["patient_parameter"]>


  export type patient_parameterSelectScalar = {
    parameter_id?: boolean
    date_of_birth?: boolean
    known_allergies?: boolean
    previous_medical_history?: boolean
    blood_group?: boolean
    diabetic?: boolean
    hypertension?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    created_on?: boolean
  }


  export type $patient_parameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_parameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      parameter_id: number
      date_of_birth: Date
      known_allergies: string
      previous_medical_history: string
      blood_group: number | null
      diabetic: string | null
      hypertension: string | null
      referral_patient_id: number
      dependent_id: number
      created_on: string | null
    }, ExtArgs["result"]["patient_parameter"]>
    composites: {}
  }

  type patient_parameterGetPayload<S extends boolean | null | undefined | patient_parameterDefaultArgs> = $Result.GetResult<Prisma.$patient_parameterPayload, S>

  type patient_parameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<patient_parameterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Patient_parameterCountAggregateInputType | true
    }

  export interface patient_parameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_parameter'], meta: { name: 'patient_parameter' } }
    /**
     * Find zero or one Patient_parameter that matches the filter.
     * @param {patient_parameterFindUniqueArgs} args - Arguments to find a Patient_parameter
     * @example
     * // Get one Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_parameterFindUniqueArgs>(args: SelectSubset<T, patient_parameterFindUniqueArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient_parameter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {patient_parameterFindUniqueOrThrowArgs} args - Arguments to find a Patient_parameter
     * @example
     * // Get one Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_parameterFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_parameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient_parameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterFindFirstArgs} args - Arguments to find a Patient_parameter
     * @example
     * // Get one Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_parameterFindFirstArgs>(args?: SelectSubset<T, patient_parameterFindFirstArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient_parameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterFindFirstOrThrowArgs} args - Arguments to find a Patient_parameter
     * @example
     * // Get one Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_parameterFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_parameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patient_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_parameters
     * const patient_parameters = await prisma.patient_parameter.findMany()
     * 
     * // Get first 10 Patient_parameters
     * const patient_parameters = await prisma.patient_parameter.findMany({ take: 10 })
     * 
     * // Only select the `parameter_id`
     * const patient_parameterWithParameter_idOnly = await prisma.patient_parameter.findMany({ select: { parameter_id: true } })
     * 
     */
    findMany<T extends patient_parameterFindManyArgs>(args?: SelectSubset<T, patient_parameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient_parameter.
     * @param {patient_parameterCreateArgs} args - Arguments to create a Patient_parameter.
     * @example
     * // Create one Patient_parameter
     * const Patient_parameter = await prisma.patient_parameter.create({
     *   data: {
     *     // ... data to create a Patient_parameter
     *   }
     * })
     * 
     */
    create<T extends patient_parameterCreateArgs>(args: SelectSubset<T, patient_parameterCreateArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patient_parameters.
     * @param {patient_parameterCreateManyArgs} args - Arguments to create many Patient_parameters.
     * @example
     * // Create many Patient_parameters
     * const patient_parameter = await prisma.patient_parameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_parameterCreateManyArgs>(args?: SelectSubset<T, patient_parameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient_parameter.
     * @param {patient_parameterDeleteArgs} args - Arguments to delete one Patient_parameter.
     * @example
     * // Delete one Patient_parameter
     * const Patient_parameter = await prisma.patient_parameter.delete({
     *   where: {
     *     // ... filter to delete one Patient_parameter
     *   }
     * })
     * 
     */
    delete<T extends patient_parameterDeleteArgs>(args: SelectSubset<T, patient_parameterDeleteArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient_parameter.
     * @param {patient_parameterUpdateArgs} args - Arguments to update one Patient_parameter.
     * @example
     * // Update one Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_parameterUpdateArgs>(args: SelectSubset<T, patient_parameterUpdateArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patient_parameters.
     * @param {patient_parameterDeleteManyArgs} args - Arguments to filter Patient_parameters to delete.
     * @example
     * // Delete a few Patient_parameters
     * const { count } = await prisma.patient_parameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_parameterDeleteManyArgs>(args?: SelectSubset<T, patient_parameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_parameters
     * const patient_parameter = await prisma.patient_parameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_parameterUpdateManyArgs>(args: SelectSubset<T, patient_parameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient_parameter.
     * @param {patient_parameterUpsertArgs} args - Arguments to update or create a Patient_parameter.
     * @example
     * // Update or create a Patient_parameter
     * const patient_parameter = await prisma.patient_parameter.upsert({
     *   create: {
     *     // ... data to create a Patient_parameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_parameter we want to update
     *   }
     * })
     */
    upsert<T extends patient_parameterUpsertArgs>(args: SelectSubset<T, patient_parameterUpsertArgs<ExtArgs>>): Prisma__patient_parameterClient<$Result.GetResult<Prisma.$patient_parameterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patient_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterCountArgs} args - Arguments to filter Patient_parameters to count.
     * @example
     * // Count the number of Patient_parameters
     * const count = await prisma.patient_parameter.count({
     *   where: {
     *     // ... the filter for the Patient_parameters we want to count
     *   }
     * })
    **/
    count<T extends patient_parameterCountArgs>(
      args?: Subset<T, patient_parameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_parameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_parameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_parameterAggregateArgs>(args: Subset<T, Patient_parameterAggregateArgs>): Prisma.PrismaPromise<GetPatient_parameterAggregateType<T>>

    /**
     * Group by Patient_parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_parameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_parameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_parameterGroupByArgs['orderBy'] }
        : { orderBy?: patient_parameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_parameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_parameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_parameter model
   */
  readonly fields: patient_parameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_parameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_parameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_parameter model
   */ 
  interface patient_parameterFieldRefs {
    readonly parameter_id: FieldRef<"patient_parameter", 'Int'>
    readonly date_of_birth: FieldRef<"patient_parameter", 'DateTime'>
    readonly known_allergies: FieldRef<"patient_parameter", 'String'>
    readonly previous_medical_history: FieldRef<"patient_parameter", 'String'>
    readonly blood_group: FieldRef<"patient_parameter", 'Int'>
    readonly diabetic: FieldRef<"patient_parameter", 'String'>
    readonly hypertension: FieldRef<"patient_parameter", 'String'>
    readonly referral_patient_id: FieldRef<"patient_parameter", 'Int'>
    readonly dependent_id: FieldRef<"patient_parameter", 'Int'>
    readonly created_on: FieldRef<"patient_parameter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * patient_parameter findUnique
   */
  export type patient_parameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter, which patient_parameter to fetch.
     */
    where: patient_parameterWhereUniqueInput
  }

  /**
   * patient_parameter findUniqueOrThrow
   */
  export type patient_parameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter, which patient_parameter to fetch.
     */
    where: patient_parameterWhereUniqueInput
  }

  /**
   * patient_parameter findFirst
   */
  export type patient_parameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter, which patient_parameter to fetch.
     */
    where?: patient_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_parameters to fetch.
     */
    orderBy?: patient_parameterOrderByWithRelationInput | patient_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_parameters.
     */
    cursor?: patient_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_parameters.
     */
    distinct?: Patient_parameterScalarFieldEnum | Patient_parameterScalarFieldEnum[]
  }

  /**
   * patient_parameter findFirstOrThrow
   */
  export type patient_parameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter, which patient_parameter to fetch.
     */
    where?: patient_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_parameters to fetch.
     */
    orderBy?: patient_parameterOrderByWithRelationInput | patient_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_parameters.
     */
    cursor?: patient_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_parameters.
     */
    distinct?: Patient_parameterScalarFieldEnum | Patient_parameterScalarFieldEnum[]
  }

  /**
   * patient_parameter findMany
   */
  export type patient_parameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter, which patient_parameters to fetch.
     */
    where?: patient_parameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_parameters to fetch.
     */
    orderBy?: patient_parameterOrderByWithRelationInput | patient_parameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_parameters.
     */
    cursor?: patient_parameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_parameters.
     */
    skip?: number
    distinct?: Patient_parameterScalarFieldEnum | Patient_parameterScalarFieldEnum[]
  }

  /**
   * patient_parameter create
   */
  export type patient_parameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * The data needed to create a patient_parameter.
     */
    data: XOR<patient_parameterCreateInput, patient_parameterUncheckedCreateInput>
  }

  /**
   * patient_parameter createMany
   */
  export type patient_parameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_parameters.
     */
    data: patient_parameterCreateManyInput | patient_parameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_parameter update
   */
  export type patient_parameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * The data needed to update a patient_parameter.
     */
    data: XOR<patient_parameterUpdateInput, patient_parameterUncheckedUpdateInput>
    /**
     * Choose, which patient_parameter to update.
     */
    where: patient_parameterWhereUniqueInput
  }

  /**
   * patient_parameter updateMany
   */
  export type patient_parameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_parameters.
     */
    data: XOR<patient_parameterUpdateManyMutationInput, patient_parameterUncheckedUpdateManyInput>
    /**
     * Filter which patient_parameters to update
     */
    where?: patient_parameterWhereInput
  }

  /**
   * patient_parameter upsert
   */
  export type patient_parameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * The filter to search for the patient_parameter to update in case it exists.
     */
    where: patient_parameterWhereUniqueInput
    /**
     * In case the patient_parameter found by the `where` argument doesn't exist, create a new patient_parameter with this data.
     */
    create: XOR<patient_parameterCreateInput, patient_parameterUncheckedCreateInput>
    /**
     * In case the patient_parameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_parameterUpdateInput, patient_parameterUncheckedUpdateInput>
  }

  /**
   * patient_parameter delete
   */
  export type patient_parameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
    /**
     * Filter which patient_parameter to delete.
     */
    where: patient_parameterWhereUniqueInput
  }

  /**
   * patient_parameter deleteMany
   */
  export type patient_parameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_parameters to delete
     */
    where?: patient_parameterWhereInput
  }

  /**
   * patient_parameter without action
   */
  export type patient_parameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_parameter
     */
    select?: patient_parameterSelect<ExtArgs> | null
  }


  /**
   * Model patientqueue
   */

  export type AggregatePatientqueue = {
    _count: PatientqueueCountAggregateOutputType | null
    _avg: PatientqueueAvgAggregateOutputType | null
    _sum: PatientqueueSumAggregateOutputType | null
    _min: PatientqueueMinAggregateOutputType | null
    _max: PatientqueueMaxAggregateOutputType | null
  }

  export type PatientqueueAvgAggregateOutputType = {
    patientqueue_id: number | null
    physician_id: number | null
    referred_id: number | null
    ID: number | null
    billing_id: number | null
    laboratory_id: number | null
    lab_test_status: number | null
    billing_status: number | null
    is_sync: number | null
  }

  export type PatientqueueSumAggregateOutputType = {
    patientqueue_id: number | null
    physician_id: number | null
    referred_id: number | null
    ID: number | null
    billing_id: number | null
    laboratory_id: number | null
    lab_test_status: number | null
    billing_status: number | null
    is_sync: number | null
  }

  export type PatientqueueMinAggregateOutputType = {
    patientqueue_id: number | null
    BillId: string | null
    medical_num: string | null
    firstname: string | null
    mailid: string | null
    phonenum: string | null
    refer_date: Date | null
    patient_unique_id: string | null
    physician_id: number | null
    phyfname: string | null
    referred_id: number | null
    ID: number | null
    billing_id: number | null
    laboratory_id: number | null
    ref_type: string | null
    lab_test_status: number | null
    billing_status: number | null
    is_sync: number | null
    created_on: Date | null
  }

  export type PatientqueueMaxAggregateOutputType = {
    patientqueue_id: number | null
    BillId: string | null
    medical_num: string | null
    firstname: string | null
    mailid: string | null
    phonenum: string | null
    refer_date: Date | null
    patient_unique_id: string | null
    physician_id: number | null
    phyfname: string | null
    referred_id: number | null
    ID: number | null
    billing_id: number | null
    laboratory_id: number | null
    ref_type: string | null
    lab_test_status: number | null
    billing_status: number | null
    is_sync: number | null
    created_on: Date | null
  }

  export type PatientqueueCountAggregateOutputType = {
    patientqueue_id: number
    BillId: number
    medical_num: number
    firstname: number
    mailid: number
    phonenum: number
    refer_date: number
    patient_unique_id: number
    physician_id: number
    phyfname: number
    referred_id: number
    ID: number
    billing_id: number
    laboratory_id: number
    ref_type: number
    lab_test_status: number
    billing_status: number
    is_sync: number
    created_on: number
    _all: number
  }


  export type PatientqueueAvgAggregateInputType = {
    patientqueue_id?: true
    physician_id?: true
    referred_id?: true
    ID?: true
    billing_id?: true
    laboratory_id?: true
    lab_test_status?: true
    billing_status?: true
    is_sync?: true
  }

  export type PatientqueueSumAggregateInputType = {
    patientqueue_id?: true
    physician_id?: true
    referred_id?: true
    ID?: true
    billing_id?: true
    laboratory_id?: true
    lab_test_status?: true
    billing_status?: true
    is_sync?: true
  }

  export type PatientqueueMinAggregateInputType = {
    patientqueue_id?: true
    BillId?: true
    medical_num?: true
    firstname?: true
    mailid?: true
    phonenum?: true
    refer_date?: true
    patient_unique_id?: true
    physician_id?: true
    phyfname?: true
    referred_id?: true
    ID?: true
    billing_id?: true
    laboratory_id?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
    is_sync?: true
    created_on?: true
  }

  export type PatientqueueMaxAggregateInputType = {
    patientqueue_id?: true
    BillId?: true
    medical_num?: true
    firstname?: true
    mailid?: true
    phonenum?: true
    refer_date?: true
    patient_unique_id?: true
    physician_id?: true
    phyfname?: true
    referred_id?: true
    ID?: true
    billing_id?: true
    laboratory_id?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
    is_sync?: true
    created_on?: true
  }

  export type PatientqueueCountAggregateInputType = {
    patientqueue_id?: true
    BillId?: true
    medical_num?: true
    firstname?: true
    mailid?: true
    phonenum?: true
    refer_date?: true
    patient_unique_id?: true
    physician_id?: true
    phyfname?: true
    referred_id?: true
    ID?: true
    billing_id?: true
    laboratory_id?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
    is_sync?: true
    created_on?: true
    _all?: true
  }

  export type PatientqueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patientqueue to aggregate.
     */
    where?: patientqueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patientqueues to fetch.
     */
    orderBy?: patientqueueOrderByWithRelationInput | patientqueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientqueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patientqueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patientqueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patientqueues
    **/
    _count?: true | PatientqueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientqueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientqueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientqueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientqueueMaxAggregateInputType
  }

  export type GetPatientqueueAggregateType<T extends PatientqueueAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientqueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientqueue[P]>
      : GetScalarType<T[P], AggregatePatientqueue[P]>
  }




  export type patientqueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientqueueWhereInput
    orderBy?: patientqueueOrderByWithAggregationInput | patientqueueOrderByWithAggregationInput[]
    by: PatientqueueScalarFieldEnum[] | PatientqueueScalarFieldEnum
    having?: patientqueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientqueueCountAggregateInputType | true
    _avg?: PatientqueueAvgAggregateInputType
    _sum?: PatientqueueSumAggregateInputType
    _min?: PatientqueueMinAggregateInputType
    _max?: PatientqueueMaxAggregateInputType
  }

  export type PatientqueueGroupByOutputType = {
    patientqueue_id: number
    BillId: string
    medical_num: string
    firstname: string
    mailid: string
    phonenum: string
    refer_date: Date
    patient_unique_id: string
    physician_id: number | null
    phyfname: string | null
    referred_id: number
    ID: number
    billing_id: number
    laboratory_id: number
    ref_type: string
    lab_test_status: number
    billing_status: number
    is_sync: number
    created_on: Date
    _count: PatientqueueCountAggregateOutputType | null
    _avg: PatientqueueAvgAggregateOutputType | null
    _sum: PatientqueueSumAggregateOutputType | null
    _min: PatientqueueMinAggregateOutputType | null
    _max: PatientqueueMaxAggregateOutputType | null
  }

  type GetPatientqueueGroupByPayload<T extends patientqueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientqueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientqueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientqueueGroupByOutputType[P]>
            : GetScalarType<T[P], PatientqueueGroupByOutputType[P]>
        }
      >
    >


  export type patientqueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patientqueue_id?: boolean
    BillId?: boolean
    medical_num?: boolean
    firstname?: boolean
    mailid?: boolean
    phonenum?: boolean
    refer_date?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    phyfname?: boolean
    referred_id?: boolean
    ID?: boolean
    billing_id?: boolean
    laboratory_id?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
    billing_status?: boolean
    is_sync?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["patientqueue"]>


  export type patientqueueSelectScalar = {
    patientqueue_id?: boolean
    BillId?: boolean
    medical_num?: boolean
    firstname?: boolean
    mailid?: boolean
    phonenum?: boolean
    refer_date?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    phyfname?: boolean
    referred_id?: boolean
    ID?: boolean
    billing_id?: boolean
    laboratory_id?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
    billing_status?: boolean
    is_sync?: boolean
    created_on?: boolean
  }


  export type $patientqueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patientqueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      patientqueue_id: number
      BillId: string
      medical_num: string
      firstname: string
      mailid: string
      phonenum: string
      refer_date: Date
      patient_unique_id: string
      physician_id: number | null
      phyfname: string | null
      referred_id: number
      ID: number
      billing_id: number
      laboratory_id: number
      ref_type: string
      lab_test_status: number
      billing_status: number
      is_sync: number
      created_on: Date
    }, ExtArgs["result"]["patientqueue"]>
    composites: {}
  }

  type patientqueueGetPayload<S extends boolean | null | undefined | patientqueueDefaultArgs> = $Result.GetResult<Prisma.$patientqueuePayload, S>

  type patientqueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<patientqueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientqueueCountAggregateInputType | true
    }

  export interface patientqueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patientqueue'], meta: { name: 'patientqueue' } }
    /**
     * Find zero or one Patientqueue that matches the filter.
     * @param {patientqueueFindUniqueArgs} args - Arguments to find a Patientqueue
     * @example
     * // Get one Patientqueue
     * const patientqueue = await prisma.patientqueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientqueueFindUniqueArgs>(args: SelectSubset<T, patientqueueFindUniqueArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patientqueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {patientqueueFindUniqueOrThrowArgs} args - Arguments to find a Patientqueue
     * @example
     * // Get one Patientqueue
     * const patientqueue = await prisma.patientqueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientqueueFindUniqueOrThrowArgs>(args: SelectSubset<T, patientqueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patientqueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueFindFirstArgs} args - Arguments to find a Patientqueue
     * @example
     * // Get one Patientqueue
     * const patientqueue = await prisma.patientqueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientqueueFindFirstArgs>(args?: SelectSubset<T, patientqueueFindFirstArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patientqueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueFindFirstOrThrowArgs} args - Arguments to find a Patientqueue
     * @example
     * // Get one Patientqueue
     * const patientqueue = await prisma.patientqueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientqueueFindFirstOrThrowArgs>(args?: SelectSubset<T, patientqueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patientqueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patientqueues
     * const patientqueues = await prisma.patientqueue.findMany()
     * 
     * // Get first 10 Patientqueues
     * const patientqueues = await prisma.patientqueue.findMany({ take: 10 })
     * 
     * // Only select the `patientqueue_id`
     * const patientqueueWithPatientqueue_idOnly = await prisma.patientqueue.findMany({ select: { patientqueue_id: true } })
     * 
     */
    findMany<T extends patientqueueFindManyArgs>(args?: SelectSubset<T, patientqueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patientqueue.
     * @param {patientqueueCreateArgs} args - Arguments to create a Patientqueue.
     * @example
     * // Create one Patientqueue
     * const Patientqueue = await prisma.patientqueue.create({
     *   data: {
     *     // ... data to create a Patientqueue
     *   }
     * })
     * 
     */
    create<T extends patientqueueCreateArgs>(args: SelectSubset<T, patientqueueCreateArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patientqueues.
     * @param {patientqueueCreateManyArgs} args - Arguments to create many Patientqueues.
     * @example
     * // Create many Patientqueues
     * const patientqueue = await prisma.patientqueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientqueueCreateManyArgs>(args?: SelectSubset<T, patientqueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patientqueue.
     * @param {patientqueueDeleteArgs} args - Arguments to delete one Patientqueue.
     * @example
     * // Delete one Patientqueue
     * const Patientqueue = await prisma.patientqueue.delete({
     *   where: {
     *     // ... filter to delete one Patientqueue
     *   }
     * })
     * 
     */
    delete<T extends patientqueueDeleteArgs>(args: SelectSubset<T, patientqueueDeleteArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patientqueue.
     * @param {patientqueueUpdateArgs} args - Arguments to update one Patientqueue.
     * @example
     * // Update one Patientqueue
     * const patientqueue = await prisma.patientqueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientqueueUpdateArgs>(args: SelectSubset<T, patientqueueUpdateArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patientqueues.
     * @param {patientqueueDeleteManyArgs} args - Arguments to filter Patientqueues to delete.
     * @example
     * // Delete a few Patientqueues
     * const { count } = await prisma.patientqueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientqueueDeleteManyArgs>(args?: SelectSubset<T, patientqueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patientqueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patientqueues
     * const patientqueue = await prisma.patientqueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientqueueUpdateManyArgs>(args: SelectSubset<T, patientqueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patientqueue.
     * @param {patientqueueUpsertArgs} args - Arguments to update or create a Patientqueue.
     * @example
     * // Update or create a Patientqueue
     * const patientqueue = await prisma.patientqueue.upsert({
     *   create: {
     *     // ... data to create a Patientqueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patientqueue we want to update
     *   }
     * })
     */
    upsert<T extends patientqueueUpsertArgs>(args: SelectSubset<T, patientqueueUpsertArgs<ExtArgs>>): Prisma__patientqueueClient<$Result.GetResult<Prisma.$patientqueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patientqueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueCountArgs} args - Arguments to filter Patientqueues to count.
     * @example
     * // Count the number of Patientqueues
     * const count = await prisma.patientqueue.count({
     *   where: {
     *     // ... the filter for the Patientqueues we want to count
     *   }
     * })
    **/
    count<T extends patientqueueCountArgs>(
      args?: Subset<T, patientqueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientqueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patientqueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientqueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientqueueAggregateArgs>(args: Subset<T, PatientqueueAggregateArgs>): Prisma.PrismaPromise<GetPatientqueueAggregateType<T>>

    /**
     * Group by Patientqueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientqueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientqueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientqueueGroupByArgs['orderBy'] }
        : { orderBy?: patientqueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientqueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientqueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patientqueue model
   */
  readonly fields: patientqueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patientqueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientqueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patientqueue model
   */ 
  interface patientqueueFieldRefs {
    readonly patientqueue_id: FieldRef<"patientqueue", 'Int'>
    readonly BillId: FieldRef<"patientqueue", 'String'>
    readonly medical_num: FieldRef<"patientqueue", 'String'>
    readonly firstname: FieldRef<"patientqueue", 'String'>
    readonly mailid: FieldRef<"patientqueue", 'String'>
    readonly phonenum: FieldRef<"patientqueue", 'String'>
    readonly refer_date: FieldRef<"patientqueue", 'DateTime'>
    readonly patient_unique_id: FieldRef<"patientqueue", 'String'>
    readonly physician_id: FieldRef<"patientqueue", 'Int'>
    readonly phyfname: FieldRef<"patientqueue", 'String'>
    readonly referred_id: FieldRef<"patientqueue", 'Int'>
    readonly ID: FieldRef<"patientqueue", 'Int'>
    readonly billing_id: FieldRef<"patientqueue", 'Int'>
    readonly laboratory_id: FieldRef<"patientqueue", 'Int'>
    readonly ref_type: FieldRef<"patientqueue", 'String'>
    readonly lab_test_status: FieldRef<"patientqueue", 'Int'>
    readonly billing_status: FieldRef<"patientqueue", 'Int'>
    readonly is_sync: FieldRef<"patientqueue", 'Int'>
    readonly created_on: FieldRef<"patientqueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patientqueue findUnique
   */
  export type patientqueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter, which patientqueue to fetch.
     */
    where: patientqueueWhereUniqueInput
  }

  /**
   * patientqueue findUniqueOrThrow
   */
  export type patientqueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter, which patientqueue to fetch.
     */
    where: patientqueueWhereUniqueInput
  }

  /**
   * patientqueue findFirst
   */
  export type patientqueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter, which patientqueue to fetch.
     */
    where?: patientqueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patientqueues to fetch.
     */
    orderBy?: patientqueueOrderByWithRelationInput | patientqueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patientqueues.
     */
    cursor?: patientqueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patientqueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patientqueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patientqueues.
     */
    distinct?: PatientqueueScalarFieldEnum | PatientqueueScalarFieldEnum[]
  }

  /**
   * patientqueue findFirstOrThrow
   */
  export type patientqueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter, which patientqueue to fetch.
     */
    where?: patientqueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patientqueues to fetch.
     */
    orderBy?: patientqueueOrderByWithRelationInput | patientqueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patientqueues.
     */
    cursor?: patientqueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patientqueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patientqueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patientqueues.
     */
    distinct?: PatientqueueScalarFieldEnum | PatientqueueScalarFieldEnum[]
  }

  /**
   * patientqueue findMany
   */
  export type patientqueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter, which patientqueues to fetch.
     */
    where?: patientqueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patientqueues to fetch.
     */
    orderBy?: patientqueueOrderByWithRelationInput | patientqueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patientqueues.
     */
    cursor?: patientqueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patientqueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patientqueues.
     */
    skip?: number
    distinct?: PatientqueueScalarFieldEnum | PatientqueueScalarFieldEnum[]
  }

  /**
   * patientqueue create
   */
  export type patientqueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * The data needed to create a patientqueue.
     */
    data: XOR<patientqueueCreateInput, patientqueueUncheckedCreateInput>
  }

  /**
   * patientqueue createMany
   */
  export type patientqueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patientqueues.
     */
    data: patientqueueCreateManyInput | patientqueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patientqueue update
   */
  export type patientqueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * The data needed to update a patientqueue.
     */
    data: XOR<patientqueueUpdateInput, patientqueueUncheckedUpdateInput>
    /**
     * Choose, which patientqueue to update.
     */
    where: patientqueueWhereUniqueInput
  }

  /**
   * patientqueue updateMany
   */
  export type patientqueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patientqueues.
     */
    data: XOR<patientqueueUpdateManyMutationInput, patientqueueUncheckedUpdateManyInput>
    /**
     * Filter which patientqueues to update
     */
    where?: patientqueueWhereInput
  }

  /**
   * patientqueue upsert
   */
  export type patientqueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * The filter to search for the patientqueue to update in case it exists.
     */
    where: patientqueueWhereUniqueInput
    /**
     * In case the patientqueue found by the `where` argument doesn't exist, create a new patientqueue with this data.
     */
    create: XOR<patientqueueCreateInput, patientqueueUncheckedCreateInput>
    /**
     * In case the patientqueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientqueueUpdateInput, patientqueueUncheckedUpdateInput>
  }

  /**
   * patientqueue delete
   */
  export type patientqueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
    /**
     * Filter which patientqueue to delete.
     */
    where: patientqueueWhereUniqueInput
  }

  /**
   * patientqueue deleteMany
   */
  export type patientqueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patientqueues to delete
     */
    where?: patientqueueWhereInput
  }

  /**
   * patientqueue without action
   */
  export type patientqueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patientqueue
     */
    select?: patientqueueSelect<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    ID: number | null
    doctor_id: number | null
    referral_patient_id: number | null
    dependent_id: number | null
    Receipt_id: number | null
    con_price: number | null
    med_price: number | null
    inv_price: number | null
    admin_price: number | null
    total_price: number | null
    submitted: number | null
  }

  export type PaymentSumAggregateOutputType = {
    ID: number | null
    doctor_id: number | null
    referral_patient_id: number | null
    dependent_id: number | null
    Receipt_id: bigint | null
    con_price: number | null
    med_price: number | null
    inv_price: number | null
    admin_price: number | null
    total_price: number | null
    submitted: number | null
  }

  export type PaymentMinAggregateOutputType = {
    ID: number | null
    doctor_id: number | null
    referral_patient_id: number | null
    dependent_id: number | null
    Receipt_id: bigint | null
    prescription_num: string | null
    reg_fee: string | null
    con_price: number | null
    med_price: number | null
    inv_price: number | null
    admin_price: number | null
    total_price: number | null
    mode: string | null
    created_on: Date | null
    updated_on: Date | null
    submitted: number | null
  }

  export type PaymentMaxAggregateOutputType = {
    ID: number | null
    doctor_id: number | null
    referral_patient_id: number | null
    dependent_id: number | null
    Receipt_id: bigint | null
    prescription_num: string | null
    reg_fee: string | null
    con_price: number | null
    med_price: number | null
    inv_price: number | null
    admin_price: number | null
    total_price: number | null
    mode: string | null
    created_on: Date | null
    updated_on: Date | null
    submitted: number | null
  }

  export type PaymentCountAggregateOutputType = {
    ID: number
    doctor_id: number
    referral_patient_id: number
    dependent_id: number
    Receipt_id: number
    prescription_num: number
    reg_fee: number
    con_price: number
    med_price: number
    inv_price: number
    admin_price: number
    total_price: number
    mode: number
    created_on: number
    updated_on: number
    submitted: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    ID?: true
    doctor_id?: true
    referral_patient_id?: true
    dependent_id?: true
    Receipt_id?: true
    con_price?: true
    med_price?: true
    inv_price?: true
    admin_price?: true
    total_price?: true
    submitted?: true
  }

  export type PaymentSumAggregateInputType = {
    ID?: true
    doctor_id?: true
    referral_patient_id?: true
    dependent_id?: true
    Receipt_id?: true
    con_price?: true
    med_price?: true
    inv_price?: true
    admin_price?: true
    total_price?: true
    submitted?: true
  }

  export type PaymentMinAggregateInputType = {
    ID?: true
    doctor_id?: true
    referral_patient_id?: true
    dependent_id?: true
    Receipt_id?: true
    prescription_num?: true
    reg_fee?: true
    con_price?: true
    med_price?: true
    inv_price?: true
    admin_price?: true
    total_price?: true
    mode?: true
    created_on?: true
    updated_on?: true
    submitted?: true
  }

  export type PaymentMaxAggregateInputType = {
    ID?: true
    doctor_id?: true
    referral_patient_id?: true
    dependent_id?: true
    Receipt_id?: true
    prescription_num?: true
    reg_fee?: true
    con_price?: true
    med_price?: true
    inv_price?: true
    admin_price?: true
    total_price?: true
    mode?: true
    created_on?: true
    updated_on?: true
    submitted?: true
  }

  export type PaymentCountAggregateInputType = {
    ID?: true
    doctor_id?: true
    referral_patient_id?: true
    dependent_id?: true
    Receipt_id?: true
    prescription_num?: true
    reg_fee?: true
    con_price?: true
    med_price?: true
    inv_price?: true
    admin_price?: true
    total_price?: true
    mode?: true
    created_on?: true
    updated_on?: true
    submitted?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    ID: number
    doctor_id: number
    referral_patient_id: number
    dependent_id: number
    Receipt_id: bigint
    prescription_num: string
    reg_fee: string
    con_price: number
    med_price: number
    inv_price: number
    admin_price: number
    total_price: number
    mode: string
    created_on: Date
    updated_on: Date
    submitted: number | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    doctor_id?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    Receipt_id?: boolean
    prescription_num?: boolean
    reg_fee?: boolean
    con_price?: boolean
    med_price?: boolean
    inv_price?: boolean
    admin_price?: boolean
    total_price?: boolean
    mode?: boolean
    created_on?: boolean
    updated_on?: boolean
    submitted?: boolean
  }, ExtArgs["result"]["payment"]>


  export type paymentSelectScalar = {
    ID?: boolean
    doctor_id?: boolean
    referral_patient_id?: boolean
    dependent_id?: boolean
    Receipt_id?: boolean
    prescription_num?: boolean
    reg_fee?: boolean
    con_price?: boolean
    med_price?: boolean
    inv_price?: boolean
    admin_price?: boolean
    total_price?: boolean
    mode?: boolean
    created_on?: boolean
    updated_on?: boolean
    submitted?: boolean
  }


  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      doctor_id: number
      referral_patient_id: number
      dependent_id: number
      Receipt_id: bigint
      prescription_num: string
      reg_fee: string
      con_price: number
      med_price: number
      inv_price: number
      admin_price: number
      total_price: number
      mode: string
      created_on: Date
      updated_on: Date
      submitted: number | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const paymentWithIDOnly = await prisma.payment.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */ 
  interface paymentFieldRefs {
    readonly ID: FieldRef<"payment", 'Int'>
    readonly doctor_id: FieldRef<"payment", 'Int'>
    readonly referral_patient_id: FieldRef<"payment", 'Int'>
    readonly dependent_id: FieldRef<"payment", 'Int'>
    readonly Receipt_id: FieldRef<"payment", 'BigInt'>
    readonly prescription_num: FieldRef<"payment", 'String'>
    readonly reg_fee: FieldRef<"payment", 'String'>
    readonly con_price: FieldRef<"payment", 'Int'>
    readonly med_price: FieldRef<"payment", 'Int'>
    readonly inv_price: FieldRef<"payment", 'Int'>
    readonly admin_price: FieldRef<"payment", 'Int'>
    readonly total_price: FieldRef<"payment", 'Int'>
    readonly mode: FieldRef<"payment", 'String'>
    readonly created_on: FieldRef<"payment", 'DateTime'>
    readonly updated_on: FieldRef<"payment", 'DateTime'>
    readonly submitted: FieldRef<"payment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
  }


  /**
   * Model phy_admin
   */

  export type AggregatePhy_admin = {
    _count: Phy_adminCountAggregateOutputType | null
    _avg: Phy_adminAvgAggregateOutputType | null
    _sum: Phy_adminSumAggregateOutputType | null
    _min: Phy_adminMinAggregateOutputType | null
    _max: Phy_adminMaxAggregateOutputType | null
  }

  export type Phy_adminAvgAggregateOutputType = {
    phy_admin_id: number | null
    physician_id: number | null
    active: number | null
    is_visible: number | null
    role_id: number | null
  }

  export type Phy_adminSumAggregateOutputType = {
    phy_admin_id: number | null
    physician_id: number | null
    active: number | null
    is_visible: number | null
    role_id: number | null
  }

  export type Phy_adminMinAggregateOutputType = {
    phy_admin_id: number | null
    phy_admin_name: string | null
    phy_admin_phone: string | null
    phy_admin_mail_id: string | null
    phy_admin_password: string | null
    created_on: Date | null
    updated_on: Date | null
    created_by: string | null
    physician_id: number | null
    active: number | null
    is_visible: number | null
    role_id: number | null
  }

  export type Phy_adminMaxAggregateOutputType = {
    phy_admin_id: number | null
    phy_admin_name: string | null
    phy_admin_phone: string | null
    phy_admin_mail_id: string | null
    phy_admin_password: string | null
    created_on: Date | null
    updated_on: Date | null
    created_by: string | null
    physician_id: number | null
    active: number | null
    is_visible: number | null
    role_id: number | null
  }

  export type Phy_adminCountAggregateOutputType = {
    phy_admin_id: number
    phy_admin_name: number
    phy_admin_phone: number
    phy_admin_mail_id: number
    phy_admin_password: number
    created_on: number
    updated_on: number
    created_by: number
    physician_id: number
    active: number
    is_visible: number
    role_id: number
    _all: number
  }


  export type Phy_adminAvgAggregateInputType = {
    phy_admin_id?: true
    physician_id?: true
    active?: true
    is_visible?: true
    role_id?: true
  }

  export type Phy_adminSumAggregateInputType = {
    phy_admin_id?: true
    physician_id?: true
    active?: true
    is_visible?: true
    role_id?: true
  }

  export type Phy_adminMinAggregateInputType = {
    phy_admin_id?: true
    phy_admin_name?: true
    phy_admin_phone?: true
    phy_admin_mail_id?: true
    phy_admin_password?: true
    created_on?: true
    updated_on?: true
    created_by?: true
    physician_id?: true
    active?: true
    is_visible?: true
    role_id?: true
  }

  export type Phy_adminMaxAggregateInputType = {
    phy_admin_id?: true
    phy_admin_name?: true
    phy_admin_phone?: true
    phy_admin_mail_id?: true
    phy_admin_password?: true
    created_on?: true
    updated_on?: true
    created_by?: true
    physician_id?: true
    active?: true
    is_visible?: true
    role_id?: true
  }

  export type Phy_adminCountAggregateInputType = {
    phy_admin_id?: true
    phy_admin_name?: true
    phy_admin_phone?: true
    phy_admin_mail_id?: true
    phy_admin_password?: true
    created_on?: true
    updated_on?: true
    created_by?: true
    physician_id?: true
    active?: true
    is_visible?: true
    role_id?: true
    _all?: true
  }

  export type Phy_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which phy_admin to aggregate.
     */
    where?: phy_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of phy_admins to fetch.
     */
    orderBy?: phy_adminOrderByWithRelationInput | phy_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: phy_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phy_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phy_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned phy_admins
    **/
    _count?: true | Phy_adminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Phy_adminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Phy_adminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Phy_adminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Phy_adminMaxAggregateInputType
  }

  export type GetPhy_adminAggregateType<T extends Phy_adminAggregateArgs> = {
        [P in keyof T & keyof AggregatePhy_admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhy_admin[P]>
      : GetScalarType<T[P], AggregatePhy_admin[P]>
  }




  export type phy_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: phy_adminWhereInput
    orderBy?: phy_adminOrderByWithAggregationInput | phy_adminOrderByWithAggregationInput[]
    by: Phy_adminScalarFieldEnum[] | Phy_adminScalarFieldEnum
    having?: phy_adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Phy_adminCountAggregateInputType | true
    _avg?: Phy_adminAvgAggregateInputType
    _sum?: Phy_adminSumAggregateInputType
    _min?: Phy_adminMinAggregateInputType
    _max?: Phy_adminMaxAggregateInputType
  }

  export type Phy_adminGroupByOutputType = {
    phy_admin_id: number
    phy_admin_name: string | null
    phy_admin_phone: string | null
    phy_admin_mail_id: string
    phy_admin_password: string | null
    created_on: Date
    updated_on: Date | null
    created_by: string | null
    physician_id: number
    active: number
    is_visible: number
    role_id: number
    _count: Phy_adminCountAggregateOutputType | null
    _avg: Phy_adminAvgAggregateOutputType | null
    _sum: Phy_adminSumAggregateOutputType | null
    _min: Phy_adminMinAggregateOutputType | null
    _max: Phy_adminMaxAggregateOutputType | null
  }

  type GetPhy_adminGroupByPayload<T extends phy_adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Phy_adminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Phy_adminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Phy_adminGroupByOutputType[P]>
            : GetScalarType<T[P], Phy_adminGroupByOutputType[P]>
        }
      >
    >


  export type phy_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    phy_admin_id?: boolean
    phy_admin_name?: boolean
    phy_admin_phone?: boolean
    phy_admin_mail_id?: boolean
    phy_admin_password?: boolean
    created_on?: boolean
    updated_on?: boolean
    created_by?: boolean
    physician_id?: boolean
    active?: boolean
    is_visible?: boolean
    role_id?: boolean
    physician_appointment?: boolean | physician_appointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phy_admin"]>


  export type phy_adminSelectScalar = {
    phy_admin_id?: boolean
    phy_admin_name?: boolean
    phy_admin_phone?: boolean
    phy_admin_mail_id?: boolean
    phy_admin_password?: boolean
    created_on?: boolean
    updated_on?: boolean
    created_by?: boolean
    physician_id?: boolean
    active?: boolean
    is_visible?: boolean
    role_id?: boolean
  }

  export type phy_adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    physician_appointment?: boolean | physician_appointmentDefaultArgs<ExtArgs>
  }

  export type $phy_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "phy_admin"
    objects: {
      physician_appointment: Prisma.$physician_appointmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      phy_admin_id: number
      phy_admin_name: string | null
      phy_admin_phone: string | null
      phy_admin_mail_id: string
      phy_admin_password: string | null
      created_on: Date
      updated_on: Date | null
      created_by: string | null
      physician_id: number
      active: number
      is_visible: number
      role_id: number
    }, ExtArgs["result"]["phy_admin"]>
    composites: {}
  }

  type phy_adminGetPayload<S extends boolean | null | undefined | phy_adminDefaultArgs> = $Result.GetResult<Prisma.$phy_adminPayload, S>

  type phy_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<phy_adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Phy_adminCountAggregateInputType | true
    }

  export interface phy_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['phy_admin'], meta: { name: 'phy_admin' } }
    /**
     * Find zero or one Phy_admin that matches the filter.
     * @param {phy_adminFindUniqueArgs} args - Arguments to find a Phy_admin
     * @example
     * // Get one Phy_admin
     * const phy_admin = await prisma.phy_admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends phy_adminFindUniqueArgs>(args: SelectSubset<T, phy_adminFindUniqueArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Phy_admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {phy_adminFindUniqueOrThrowArgs} args - Arguments to find a Phy_admin
     * @example
     * // Get one Phy_admin
     * const phy_admin = await prisma.phy_admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends phy_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, phy_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Phy_admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminFindFirstArgs} args - Arguments to find a Phy_admin
     * @example
     * // Get one Phy_admin
     * const phy_admin = await prisma.phy_admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends phy_adminFindFirstArgs>(args?: SelectSubset<T, phy_adminFindFirstArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Phy_admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminFindFirstOrThrowArgs} args - Arguments to find a Phy_admin
     * @example
     * // Get one Phy_admin
     * const phy_admin = await prisma.phy_admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends phy_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, phy_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Phy_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phy_admins
     * const phy_admins = await prisma.phy_admin.findMany()
     * 
     * // Get first 10 Phy_admins
     * const phy_admins = await prisma.phy_admin.findMany({ take: 10 })
     * 
     * // Only select the `phy_admin_id`
     * const phy_adminWithPhy_admin_idOnly = await prisma.phy_admin.findMany({ select: { phy_admin_id: true } })
     * 
     */
    findMany<T extends phy_adminFindManyArgs>(args?: SelectSubset<T, phy_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Phy_admin.
     * @param {phy_adminCreateArgs} args - Arguments to create a Phy_admin.
     * @example
     * // Create one Phy_admin
     * const Phy_admin = await prisma.phy_admin.create({
     *   data: {
     *     // ... data to create a Phy_admin
     *   }
     * })
     * 
     */
    create<T extends phy_adminCreateArgs>(args: SelectSubset<T, phy_adminCreateArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Phy_admins.
     * @param {phy_adminCreateManyArgs} args - Arguments to create many Phy_admins.
     * @example
     * // Create many Phy_admins
     * const phy_admin = await prisma.phy_admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends phy_adminCreateManyArgs>(args?: SelectSubset<T, phy_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Phy_admin.
     * @param {phy_adminDeleteArgs} args - Arguments to delete one Phy_admin.
     * @example
     * // Delete one Phy_admin
     * const Phy_admin = await prisma.phy_admin.delete({
     *   where: {
     *     // ... filter to delete one Phy_admin
     *   }
     * })
     * 
     */
    delete<T extends phy_adminDeleteArgs>(args: SelectSubset<T, phy_adminDeleteArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Phy_admin.
     * @param {phy_adminUpdateArgs} args - Arguments to update one Phy_admin.
     * @example
     * // Update one Phy_admin
     * const phy_admin = await prisma.phy_admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends phy_adminUpdateArgs>(args: SelectSubset<T, phy_adminUpdateArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Phy_admins.
     * @param {phy_adminDeleteManyArgs} args - Arguments to filter Phy_admins to delete.
     * @example
     * // Delete a few Phy_admins
     * const { count } = await prisma.phy_admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends phy_adminDeleteManyArgs>(args?: SelectSubset<T, phy_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phy_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phy_admins
     * const phy_admin = await prisma.phy_admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends phy_adminUpdateManyArgs>(args: SelectSubset<T, phy_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Phy_admin.
     * @param {phy_adminUpsertArgs} args - Arguments to update or create a Phy_admin.
     * @example
     * // Update or create a Phy_admin
     * const phy_admin = await prisma.phy_admin.upsert({
     *   create: {
     *     // ... data to create a Phy_admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phy_admin we want to update
     *   }
     * })
     */
    upsert<T extends phy_adminUpsertArgs>(args: SelectSubset<T, phy_adminUpsertArgs<ExtArgs>>): Prisma__phy_adminClient<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Phy_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminCountArgs} args - Arguments to filter Phy_admins to count.
     * @example
     * // Count the number of Phy_admins
     * const count = await prisma.phy_admin.count({
     *   where: {
     *     // ... the filter for the Phy_admins we want to count
     *   }
     * })
    **/
    count<T extends phy_adminCountArgs>(
      args?: Subset<T, phy_adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Phy_adminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phy_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Phy_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Phy_adminAggregateArgs>(args: Subset<T, Phy_adminAggregateArgs>): Prisma.PrismaPromise<GetPhy_adminAggregateType<T>>

    /**
     * Group by Phy_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phy_adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends phy_adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: phy_adminGroupByArgs['orderBy'] }
        : { orderBy?: phy_adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, phy_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhy_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the phy_admin model
   */
  readonly fields: phy_adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for phy_admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__phy_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    physician_appointment<T extends physician_appointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, physician_appointmentDefaultArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the phy_admin model
   */ 
  interface phy_adminFieldRefs {
    readonly phy_admin_id: FieldRef<"phy_admin", 'Int'>
    readonly phy_admin_name: FieldRef<"phy_admin", 'String'>
    readonly phy_admin_phone: FieldRef<"phy_admin", 'String'>
    readonly phy_admin_mail_id: FieldRef<"phy_admin", 'String'>
    readonly phy_admin_password: FieldRef<"phy_admin", 'String'>
    readonly created_on: FieldRef<"phy_admin", 'DateTime'>
    readonly updated_on: FieldRef<"phy_admin", 'DateTime'>
    readonly created_by: FieldRef<"phy_admin", 'String'>
    readonly physician_id: FieldRef<"phy_admin", 'Int'>
    readonly active: FieldRef<"phy_admin", 'Int'>
    readonly is_visible: FieldRef<"phy_admin", 'Int'>
    readonly role_id: FieldRef<"phy_admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * phy_admin findUnique
   */
  export type phy_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter, which phy_admin to fetch.
     */
    where: phy_adminWhereUniqueInput
  }

  /**
   * phy_admin findUniqueOrThrow
   */
  export type phy_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter, which phy_admin to fetch.
     */
    where: phy_adminWhereUniqueInput
  }

  /**
   * phy_admin findFirst
   */
  export type phy_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter, which phy_admin to fetch.
     */
    where?: phy_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of phy_admins to fetch.
     */
    orderBy?: phy_adminOrderByWithRelationInput | phy_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for phy_admins.
     */
    cursor?: phy_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phy_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phy_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of phy_admins.
     */
    distinct?: Phy_adminScalarFieldEnum | Phy_adminScalarFieldEnum[]
  }

  /**
   * phy_admin findFirstOrThrow
   */
  export type phy_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter, which phy_admin to fetch.
     */
    where?: phy_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of phy_admins to fetch.
     */
    orderBy?: phy_adminOrderByWithRelationInput | phy_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for phy_admins.
     */
    cursor?: phy_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phy_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phy_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of phy_admins.
     */
    distinct?: Phy_adminScalarFieldEnum | Phy_adminScalarFieldEnum[]
  }

  /**
   * phy_admin findMany
   */
  export type phy_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter, which phy_admins to fetch.
     */
    where?: phy_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of phy_admins to fetch.
     */
    orderBy?: phy_adminOrderByWithRelationInput | phy_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing phy_admins.
     */
    cursor?: phy_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phy_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phy_admins.
     */
    skip?: number
    distinct?: Phy_adminScalarFieldEnum | Phy_adminScalarFieldEnum[]
  }

  /**
   * phy_admin create
   */
  export type phy_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * The data needed to create a phy_admin.
     */
    data: XOR<phy_adminCreateInput, phy_adminUncheckedCreateInput>
  }

  /**
   * phy_admin createMany
   */
  export type phy_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many phy_admins.
     */
    data: phy_adminCreateManyInput | phy_adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * phy_admin update
   */
  export type phy_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * The data needed to update a phy_admin.
     */
    data: XOR<phy_adminUpdateInput, phy_adminUncheckedUpdateInput>
    /**
     * Choose, which phy_admin to update.
     */
    where: phy_adminWhereUniqueInput
  }

  /**
   * phy_admin updateMany
   */
  export type phy_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update phy_admins.
     */
    data: XOR<phy_adminUpdateManyMutationInput, phy_adminUncheckedUpdateManyInput>
    /**
     * Filter which phy_admins to update
     */
    where?: phy_adminWhereInput
  }

  /**
   * phy_admin upsert
   */
  export type phy_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * The filter to search for the phy_admin to update in case it exists.
     */
    where: phy_adminWhereUniqueInput
    /**
     * In case the phy_admin found by the `where` argument doesn't exist, create a new phy_admin with this data.
     */
    create: XOR<phy_adminCreateInput, phy_adminUncheckedCreateInput>
    /**
     * In case the phy_admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<phy_adminUpdateInput, phy_adminUncheckedUpdateInput>
  }

  /**
   * phy_admin delete
   */
  export type phy_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    /**
     * Filter which phy_admin to delete.
     */
    where: phy_adminWhereUniqueInput
  }

  /**
   * phy_admin deleteMany
   */
  export type phy_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which phy_admins to delete
     */
    where?: phy_adminWhereInput
  }

  /**
   * phy_admin without action
   */
  export type phy_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
  }


  /**
   * Model physician_appointment
   */

  export type AggregatePhysician_appointment = {
    _count: Physician_appointmentCountAggregateOutputType | null
    _avg: Physician_appointmentAvgAggregateOutputType | null
    _sum: Physician_appointmentSumAggregateOutputType | null
    _min: Physician_appointmentMinAggregateOutputType | null
    _max: Physician_appointmentMaxAggregateOutputType | null
  }

  export type Physician_appointmentAvgAggregateOutputType = {
    physician_id: number | null
    pincode: number | null
    role_id: number | null
    qualification_id: number | null
    status: number | null
    created_by_id: number | null
    clinic_module_activated: number | null
  }

  export type Physician_appointmentSumAggregateOutputType = {
    physician_id: number | null
    pincode: number | null
    role_id: number | null
    qualification_id: number | null
    status: number | null
    created_by_id: number | null
    clinic_module_activated: number | null
  }

  export type Physician_appointmentMinAggregateOutputType = {
    physician_id: number | null
    firstname: string | null
    lastname: string | null
    phone_num: string | null
    alternate_phone_number: string | null
    mail_id: string | null
    pincode: number | null
    clinic_name: string | null
    clinic_phonenum: string | null
    clinic_alternate_phonenum: string | null
    clinic_manager: string | null
    specialization: string | null
    address: string | null
    consultation_fee_validity: string | null
    city: string | null
    state: string | null
    active: boolean | null
    created_by: string | null
    created_on: Date | null
    updated_on: Date | null
    password: string | null
    role_id: number | null
    profile_filename: string | null
    profile_fullpath: string | null
    qualification_id: number | null
    registration_number: string | null
    time_span: string | null
    status: number | null
    locality: string | null
    created_by_id: number | null
    clinic_module_activated: number | null
    Signature_image: string | null
  }

  export type Physician_appointmentMaxAggregateOutputType = {
    physician_id: number | null
    firstname: string | null
    lastname: string | null
    phone_num: string | null
    alternate_phone_number: string | null
    mail_id: string | null
    pincode: number | null
    clinic_name: string | null
    clinic_phonenum: string | null
    clinic_alternate_phonenum: string | null
    clinic_manager: string | null
    specialization: string | null
    address: string | null
    consultation_fee_validity: string | null
    city: string | null
    state: string | null
    active: boolean | null
    created_by: string | null
    created_on: Date | null
    updated_on: Date | null
    password: string | null
    role_id: number | null
    profile_filename: string | null
    profile_fullpath: string | null
    qualification_id: number | null
    registration_number: string | null
    time_span: string | null
    status: number | null
    locality: string | null
    created_by_id: number | null
    clinic_module_activated: number | null
    Signature_image: string | null
  }

  export type Physician_appointmentCountAggregateOutputType = {
    physician_id: number
    firstname: number
    lastname: number
    phone_num: number
    alternate_phone_number: number
    mail_id: number
    pincode: number
    clinic_name: number
    clinic_phonenum: number
    clinic_alternate_phonenum: number
    clinic_manager: number
    specialization: number
    address: number
    consultation_fee_validity: number
    city: number
    state: number
    active: number
    created_by: number
    created_on: number
    updated_on: number
    password: number
    role_id: number
    profile_filename: number
    profile_fullpath: number
    qualification_id: number
    registration_number: number
    time_span: number
    status: number
    locality: number
    created_by_id: number
    clinic_module_activated: number
    Signature_image: number
    _all: number
  }


  export type Physician_appointmentAvgAggregateInputType = {
    physician_id?: true
    pincode?: true
    role_id?: true
    qualification_id?: true
    status?: true
    created_by_id?: true
    clinic_module_activated?: true
  }

  export type Physician_appointmentSumAggregateInputType = {
    physician_id?: true
    pincode?: true
    role_id?: true
    qualification_id?: true
    status?: true
    created_by_id?: true
    clinic_module_activated?: true
  }

  export type Physician_appointmentMinAggregateInputType = {
    physician_id?: true
    firstname?: true
    lastname?: true
    phone_num?: true
    alternate_phone_number?: true
    mail_id?: true
    pincode?: true
    clinic_name?: true
    clinic_phonenum?: true
    clinic_alternate_phonenum?: true
    clinic_manager?: true
    specialization?: true
    address?: true
    consultation_fee_validity?: true
    city?: true
    state?: true
    active?: true
    created_by?: true
    created_on?: true
    updated_on?: true
    password?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
    qualification_id?: true
    registration_number?: true
    time_span?: true
    status?: true
    locality?: true
    created_by_id?: true
    clinic_module_activated?: true
    Signature_image?: true
  }

  export type Physician_appointmentMaxAggregateInputType = {
    physician_id?: true
    firstname?: true
    lastname?: true
    phone_num?: true
    alternate_phone_number?: true
    mail_id?: true
    pincode?: true
    clinic_name?: true
    clinic_phonenum?: true
    clinic_alternate_phonenum?: true
    clinic_manager?: true
    specialization?: true
    address?: true
    consultation_fee_validity?: true
    city?: true
    state?: true
    active?: true
    created_by?: true
    created_on?: true
    updated_on?: true
    password?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
    qualification_id?: true
    registration_number?: true
    time_span?: true
    status?: true
    locality?: true
    created_by_id?: true
    clinic_module_activated?: true
    Signature_image?: true
  }

  export type Physician_appointmentCountAggregateInputType = {
    physician_id?: true
    firstname?: true
    lastname?: true
    phone_num?: true
    alternate_phone_number?: true
    mail_id?: true
    pincode?: true
    clinic_name?: true
    clinic_phonenum?: true
    clinic_alternate_phonenum?: true
    clinic_manager?: true
    specialization?: true
    address?: true
    consultation_fee_validity?: true
    city?: true
    state?: true
    active?: true
    created_by?: true
    created_on?: true
    updated_on?: true
    password?: true
    role_id?: true
    profile_filename?: true
    profile_fullpath?: true
    qualification_id?: true
    registration_number?: true
    time_span?: true
    status?: true
    locality?: true
    created_by_id?: true
    clinic_module_activated?: true
    Signature_image?: true
    _all?: true
  }

  export type Physician_appointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_appointment to aggregate.
     */
    where?: physician_appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_appointments to fetch.
     */
    orderBy?: physician_appointmentOrderByWithRelationInput | physician_appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: physician_appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned physician_appointments
    **/
    _count?: true | Physician_appointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Physician_appointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Physician_appointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Physician_appointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Physician_appointmentMaxAggregateInputType
  }

  export type GetPhysician_appointmentAggregateType<T extends Physician_appointmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician_appointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician_appointment[P]>
      : GetScalarType<T[P], AggregatePhysician_appointment[P]>
  }




  export type physician_appointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: physician_appointmentWhereInput
    orderBy?: physician_appointmentOrderByWithAggregationInput | physician_appointmentOrderByWithAggregationInput[]
    by: Physician_appointmentScalarFieldEnum[] | Physician_appointmentScalarFieldEnum
    having?: physician_appointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Physician_appointmentCountAggregateInputType | true
    _avg?: Physician_appointmentAvgAggregateInputType
    _sum?: Physician_appointmentSumAggregateInputType
    _min?: Physician_appointmentMinAggregateInputType
    _max?: Physician_appointmentMaxAggregateInputType
  }

  export type Physician_appointmentGroupByOutputType = {
    physician_id: number
    firstname: string | null
    lastname: string | null
    phone_num: string
    alternate_phone_number: string
    mail_id: string
    pincode: number | null
    clinic_name: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization: string | null
    address: string | null
    consultation_fee_validity: string
    city: string | null
    state: string | null
    active: boolean
    created_by: string | null
    created_on: Date | null
    updated_on: Date | null
    password: string | null
    role_id: number
    profile_filename: string | null
    profile_fullpath: string | null
    qualification_id: number | null
    registration_number: string | null
    time_span: string | null
    status: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
    _count: Physician_appointmentCountAggregateOutputType | null
    _avg: Physician_appointmentAvgAggregateOutputType | null
    _sum: Physician_appointmentSumAggregateOutputType | null
    _min: Physician_appointmentMinAggregateOutputType | null
    _max: Physician_appointmentMaxAggregateOutputType | null
  }

  type GetPhysician_appointmentGroupByPayload<T extends physician_appointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Physician_appointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Physician_appointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Physician_appointmentGroupByOutputType[P]>
            : GetScalarType<T[P], Physician_appointmentGroupByOutputType[P]>
        }
      >
    >


  export type physician_appointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    physician_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phone_num?: boolean
    alternate_phone_number?: boolean
    mail_id?: boolean
    pincode?: boolean
    clinic_name?: boolean
    clinic_phonenum?: boolean
    clinic_alternate_phonenum?: boolean
    clinic_manager?: boolean
    specialization?: boolean
    address?: boolean
    consultation_fee_validity?: boolean
    city?: boolean
    state?: boolean
    active?: boolean
    created_by?: boolean
    created_on?: boolean
    updated_on?: boolean
    password?: boolean
    role_id?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
    qualification_id?: boolean
    registration_number?: boolean
    time_span?: boolean
    status?: boolean
    locality?: boolean
    created_by_id?: boolean
    clinic_module_activated?: boolean
    Signature_image?: boolean
    phy_admin?: boolean | physician_appointment$phy_adminArgs<ExtArgs>
    _count?: boolean | Physician_appointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physician_appointment"]>


  export type physician_appointmentSelectScalar = {
    physician_id?: boolean
    firstname?: boolean
    lastname?: boolean
    phone_num?: boolean
    alternate_phone_number?: boolean
    mail_id?: boolean
    pincode?: boolean
    clinic_name?: boolean
    clinic_phonenum?: boolean
    clinic_alternate_phonenum?: boolean
    clinic_manager?: boolean
    specialization?: boolean
    address?: boolean
    consultation_fee_validity?: boolean
    city?: boolean
    state?: boolean
    active?: boolean
    created_by?: boolean
    created_on?: boolean
    updated_on?: boolean
    password?: boolean
    role_id?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
    qualification_id?: boolean
    registration_number?: boolean
    time_span?: boolean
    status?: boolean
    locality?: boolean
    created_by_id?: boolean
    clinic_module_activated?: boolean
    Signature_image?: boolean
  }

  export type physician_appointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phy_admin?: boolean | physician_appointment$phy_adminArgs<ExtArgs>
    _count?: boolean | Physician_appointmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $physician_appointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "physician_appointment"
    objects: {
      phy_admin: Prisma.$phy_adminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      physician_id: number
      firstname: string | null
      lastname: string | null
      phone_num: string
      alternate_phone_number: string
      mail_id: string
      pincode: number | null
      clinic_name: string | null
      clinic_phonenum: string
      clinic_alternate_phonenum: string
      clinic_manager: string
      specialization: string | null
      address: string | null
      consultation_fee_validity: string
      city: string | null
      state: string | null
      active: boolean
      created_by: string | null
      created_on: Date | null
      updated_on: Date | null
      password: string | null
      role_id: number
      profile_filename: string | null
      profile_fullpath: string | null
      qualification_id: number | null
      registration_number: string | null
      time_span: string | null
      status: number | null
      locality: string
      created_by_id: number
      clinic_module_activated: number
      Signature_image: string
    }, ExtArgs["result"]["physician_appointment"]>
    composites: {}
  }

  type physician_appointmentGetPayload<S extends boolean | null | undefined | physician_appointmentDefaultArgs> = $Result.GetResult<Prisma.$physician_appointmentPayload, S>

  type physician_appointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<physician_appointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Physician_appointmentCountAggregateInputType | true
    }

  export interface physician_appointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['physician_appointment'], meta: { name: 'physician_appointment' } }
    /**
     * Find zero or one Physician_appointment that matches the filter.
     * @param {physician_appointmentFindUniqueArgs} args - Arguments to find a Physician_appointment
     * @example
     * // Get one Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends physician_appointmentFindUniqueArgs>(args: SelectSubset<T, physician_appointmentFindUniqueArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Physician_appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {physician_appointmentFindUniqueOrThrowArgs} args - Arguments to find a Physician_appointment
     * @example
     * // Get one Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends physician_appointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, physician_appointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Physician_appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentFindFirstArgs} args - Arguments to find a Physician_appointment
     * @example
     * // Get one Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends physician_appointmentFindFirstArgs>(args?: SelectSubset<T, physician_appointmentFindFirstArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Physician_appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentFindFirstOrThrowArgs} args - Arguments to find a Physician_appointment
     * @example
     * // Get one Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends physician_appointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, physician_appointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Physician_appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physician_appointments
     * const physician_appointments = await prisma.physician_appointment.findMany()
     * 
     * // Get first 10 Physician_appointments
     * const physician_appointments = await prisma.physician_appointment.findMany({ take: 10 })
     * 
     * // Only select the `physician_id`
     * const physician_appointmentWithPhysician_idOnly = await prisma.physician_appointment.findMany({ select: { physician_id: true } })
     * 
     */
    findMany<T extends physician_appointmentFindManyArgs>(args?: SelectSubset<T, physician_appointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Physician_appointment.
     * @param {physician_appointmentCreateArgs} args - Arguments to create a Physician_appointment.
     * @example
     * // Create one Physician_appointment
     * const Physician_appointment = await prisma.physician_appointment.create({
     *   data: {
     *     // ... data to create a Physician_appointment
     *   }
     * })
     * 
     */
    create<T extends physician_appointmentCreateArgs>(args: SelectSubset<T, physician_appointmentCreateArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Physician_appointments.
     * @param {physician_appointmentCreateManyArgs} args - Arguments to create many Physician_appointments.
     * @example
     * // Create many Physician_appointments
     * const physician_appointment = await prisma.physician_appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends physician_appointmentCreateManyArgs>(args?: SelectSubset<T, physician_appointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Physician_appointment.
     * @param {physician_appointmentDeleteArgs} args - Arguments to delete one Physician_appointment.
     * @example
     * // Delete one Physician_appointment
     * const Physician_appointment = await prisma.physician_appointment.delete({
     *   where: {
     *     // ... filter to delete one Physician_appointment
     *   }
     * })
     * 
     */
    delete<T extends physician_appointmentDeleteArgs>(args: SelectSubset<T, physician_appointmentDeleteArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Physician_appointment.
     * @param {physician_appointmentUpdateArgs} args - Arguments to update one Physician_appointment.
     * @example
     * // Update one Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends physician_appointmentUpdateArgs>(args: SelectSubset<T, physician_appointmentUpdateArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Physician_appointments.
     * @param {physician_appointmentDeleteManyArgs} args - Arguments to filter Physician_appointments to delete.
     * @example
     * // Delete a few Physician_appointments
     * const { count } = await prisma.physician_appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends physician_appointmentDeleteManyArgs>(args?: SelectSubset<T, physician_appointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physician_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physician_appointments
     * const physician_appointment = await prisma.physician_appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends physician_appointmentUpdateManyArgs>(args: SelectSubset<T, physician_appointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician_appointment.
     * @param {physician_appointmentUpsertArgs} args - Arguments to update or create a Physician_appointment.
     * @example
     * // Update or create a Physician_appointment
     * const physician_appointment = await prisma.physician_appointment.upsert({
     *   create: {
     *     // ... data to create a Physician_appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician_appointment we want to update
     *   }
     * })
     */
    upsert<T extends physician_appointmentUpsertArgs>(args: SelectSubset<T, physician_appointmentUpsertArgs<ExtArgs>>): Prisma__physician_appointmentClient<$Result.GetResult<Prisma.$physician_appointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Physician_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentCountArgs} args - Arguments to filter Physician_appointments to count.
     * @example
     * // Count the number of Physician_appointments
     * const count = await prisma.physician_appointment.count({
     *   where: {
     *     // ... the filter for the Physician_appointments we want to count
     *   }
     * })
    **/
    count<T extends physician_appointmentCountArgs>(
      args?: Subset<T, physician_appointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Physician_appointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician_appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Physician_appointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Physician_appointmentAggregateArgs>(args: Subset<T, Physician_appointmentAggregateArgs>): Prisma.PrismaPromise<GetPhysician_appointmentAggregateType<T>>

    /**
     * Group by Physician_appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_appointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends physician_appointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: physician_appointmentGroupByArgs['orderBy'] }
        : { orderBy?: physician_appointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, physician_appointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysician_appointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the physician_appointment model
   */
  readonly fields: physician_appointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for physician_appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__physician_appointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phy_admin<T extends physician_appointment$phy_adminArgs<ExtArgs> = {}>(args?: Subset<T, physician_appointment$phy_adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$phy_adminPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the physician_appointment model
   */ 
  interface physician_appointmentFieldRefs {
    readonly physician_id: FieldRef<"physician_appointment", 'Int'>
    readonly firstname: FieldRef<"physician_appointment", 'String'>
    readonly lastname: FieldRef<"physician_appointment", 'String'>
    readonly phone_num: FieldRef<"physician_appointment", 'String'>
    readonly alternate_phone_number: FieldRef<"physician_appointment", 'String'>
    readonly mail_id: FieldRef<"physician_appointment", 'String'>
    readonly pincode: FieldRef<"physician_appointment", 'Int'>
    readonly clinic_name: FieldRef<"physician_appointment", 'String'>
    readonly clinic_phonenum: FieldRef<"physician_appointment", 'String'>
    readonly clinic_alternate_phonenum: FieldRef<"physician_appointment", 'String'>
    readonly clinic_manager: FieldRef<"physician_appointment", 'String'>
    readonly specialization: FieldRef<"physician_appointment", 'String'>
    readonly address: FieldRef<"physician_appointment", 'String'>
    readonly consultation_fee_validity: FieldRef<"physician_appointment", 'String'>
    readonly city: FieldRef<"physician_appointment", 'String'>
    readonly state: FieldRef<"physician_appointment", 'String'>
    readonly active: FieldRef<"physician_appointment", 'Boolean'>
    readonly created_by: FieldRef<"physician_appointment", 'String'>
    readonly created_on: FieldRef<"physician_appointment", 'DateTime'>
    readonly updated_on: FieldRef<"physician_appointment", 'DateTime'>
    readonly password: FieldRef<"physician_appointment", 'String'>
    readonly role_id: FieldRef<"physician_appointment", 'Int'>
    readonly profile_filename: FieldRef<"physician_appointment", 'String'>
    readonly profile_fullpath: FieldRef<"physician_appointment", 'String'>
    readonly qualification_id: FieldRef<"physician_appointment", 'Int'>
    readonly registration_number: FieldRef<"physician_appointment", 'String'>
    readonly time_span: FieldRef<"physician_appointment", 'String'>
    readonly status: FieldRef<"physician_appointment", 'Int'>
    readonly locality: FieldRef<"physician_appointment", 'String'>
    readonly created_by_id: FieldRef<"physician_appointment", 'Int'>
    readonly clinic_module_activated: FieldRef<"physician_appointment", 'Int'>
    readonly Signature_image: FieldRef<"physician_appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * physician_appointment findUnique
   */
  export type physician_appointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter, which physician_appointment to fetch.
     */
    where: physician_appointmentWhereUniqueInput
  }

  /**
   * physician_appointment findUniqueOrThrow
   */
  export type physician_appointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter, which physician_appointment to fetch.
     */
    where: physician_appointmentWhereUniqueInput
  }

  /**
   * physician_appointment findFirst
   */
  export type physician_appointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter, which physician_appointment to fetch.
     */
    where?: physician_appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_appointments to fetch.
     */
    orderBy?: physician_appointmentOrderByWithRelationInput | physician_appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_appointments.
     */
    cursor?: physician_appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_appointments.
     */
    distinct?: Physician_appointmentScalarFieldEnum | Physician_appointmentScalarFieldEnum[]
  }

  /**
   * physician_appointment findFirstOrThrow
   */
  export type physician_appointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter, which physician_appointment to fetch.
     */
    where?: physician_appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_appointments to fetch.
     */
    orderBy?: physician_appointmentOrderByWithRelationInput | physician_appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_appointments.
     */
    cursor?: physician_appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_appointments.
     */
    distinct?: Physician_appointmentScalarFieldEnum | Physician_appointmentScalarFieldEnum[]
  }

  /**
   * physician_appointment findMany
   */
  export type physician_appointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter, which physician_appointments to fetch.
     */
    where?: physician_appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_appointments to fetch.
     */
    orderBy?: physician_appointmentOrderByWithRelationInput | physician_appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing physician_appointments.
     */
    cursor?: physician_appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_appointments.
     */
    skip?: number
    distinct?: Physician_appointmentScalarFieldEnum | Physician_appointmentScalarFieldEnum[]
  }

  /**
   * physician_appointment create
   */
  export type physician_appointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a physician_appointment.
     */
    data: XOR<physician_appointmentCreateInput, physician_appointmentUncheckedCreateInput>
  }

  /**
   * physician_appointment createMany
   */
  export type physician_appointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many physician_appointments.
     */
    data: physician_appointmentCreateManyInput | physician_appointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * physician_appointment update
   */
  export type physician_appointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a physician_appointment.
     */
    data: XOR<physician_appointmentUpdateInput, physician_appointmentUncheckedUpdateInput>
    /**
     * Choose, which physician_appointment to update.
     */
    where: physician_appointmentWhereUniqueInput
  }

  /**
   * physician_appointment updateMany
   */
  export type physician_appointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update physician_appointments.
     */
    data: XOR<physician_appointmentUpdateManyMutationInput, physician_appointmentUncheckedUpdateManyInput>
    /**
     * Filter which physician_appointments to update
     */
    where?: physician_appointmentWhereInput
  }

  /**
   * physician_appointment upsert
   */
  export type physician_appointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the physician_appointment to update in case it exists.
     */
    where: physician_appointmentWhereUniqueInput
    /**
     * In case the physician_appointment found by the `where` argument doesn't exist, create a new physician_appointment with this data.
     */
    create: XOR<physician_appointmentCreateInput, physician_appointmentUncheckedCreateInput>
    /**
     * In case the physician_appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<physician_appointmentUpdateInput, physician_appointmentUncheckedUpdateInput>
  }

  /**
   * physician_appointment delete
   */
  export type physician_appointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
    /**
     * Filter which physician_appointment to delete.
     */
    where: physician_appointmentWhereUniqueInput
  }

  /**
   * physician_appointment deleteMany
   */
  export type physician_appointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_appointments to delete
     */
    where?: physician_appointmentWhereInput
  }

  /**
   * physician_appointment.phy_admin
   */
  export type physician_appointment$phy_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the phy_admin
     */
    select?: phy_adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phy_adminInclude<ExtArgs> | null
    where?: phy_adminWhereInput
    orderBy?: phy_adminOrderByWithRelationInput | phy_adminOrderByWithRelationInput[]
    cursor?: phy_adminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Phy_adminScalarFieldEnum | Phy_adminScalarFieldEnum[]
  }

  /**
   * physician_appointment without action
   */
  export type physician_appointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_appointment
     */
    select?: physician_appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: physician_appointmentInclude<ExtArgs> | null
  }


  /**
   * Model physician_clinic_timings
   */

  export type AggregatePhysician_clinic_timings = {
    _count: Physician_clinic_timingsCountAggregateOutputType | null
    _avg: Physician_clinic_timingsAvgAggregateOutputType | null
    _sum: Physician_clinic_timingsSumAggregateOutputType | null
    _min: Physician_clinic_timingsMinAggregateOutputType | null
    _max: Physician_clinic_timingsMaxAggregateOutputType | null
  }

  export type Physician_clinic_timingsAvgAggregateOutputType = {
    id: number | null
    physician_id: number | null
  }

  export type Physician_clinic_timingsSumAggregateOutputType = {
    id: number | null
    physician_id: number | null
  }

  export type Physician_clinic_timingsMinAggregateOutputType = {
    id: number | null
    physician_id: number | null
    theday: string | null
    work_type: $Enums.physician_clinic_timings_work_type | null
    clinic: string | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Physician_clinic_timingsMaxAggregateOutputType = {
    id: number | null
    physician_id: number | null
    theday: string | null
    work_type: $Enums.physician_clinic_timings_work_type | null
    clinic: string | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Physician_clinic_timingsCountAggregateOutputType = {
    id: number
    physician_id: number
    theday: number
    work_type: number
    clinic: number
    start_time: number
    end_time: number
    created_time: number
    updated_time: number
    _all: number
  }


  export type Physician_clinic_timingsAvgAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_clinic_timingsSumAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_clinic_timingsMinAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    clinic?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Physician_clinic_timingsMaxAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    clinic?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Physician_clinic_timingsCountAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    clinic?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
    _all?: true
  }

  export type Physician_clinic_timingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_clinic_timings to aggregate.
     */
    where?: physician_clinic_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_clinic_timings to fetch.
     */
    orderBy?: physician_clinic_timingsOrderByWithRelationInput | physician_clinic_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: physician_clinic_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_clinic_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_clinic_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned physician_clinic_timings
    **/
    _count?: true | Physician_clinic_timingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Physician_clinic_timingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Physician_clinic_timingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Physician_clinic_timingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Physician_clinic_timingsMaxAggregateInputType
  }

  export type GetPhysician_clinic_timingsAggregateType<T extends Physician_clinic_timingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician_clinic_timings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician_clinic_timings[P]>
      : GetScalarType<T[P], AggregatePhysician_clinic_timings[P]>
  }




  export type physician_clinic_timingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: physician_clinic_timingsWhereInput
    orderBy?: physician_clinic_timingsOrderByWithAggregationInput | physician_clinic_timingsOrderByWithAggregationInput[]
    by: Physician_clinic_timingsScalarFieldEnum[] | Physician_clinic_timingsScalarFieldEnum
    having?: physician_clinic_timingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Physician_clinic_timingsCountAggregateInputType | true
    _avg?: Physician_clinic_timingsAvgAggregateInputType
    _sum?: Physician_clinic_timingsSumAggregateInputType
    _min?: Physician_clinic_timingsMinAggregateInputType
    _max?: Physician_clinic_timingsMaxAggregateInputType
  }

  export type Physician_clinic_timingsGroupByOutputType = {
    id: number
    physician_id: number
    theday: string
    work_type: $Enums.physician_clinic_timings_work_type
    clinic: string | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
    _count: Physician_clinic_timingsCountAggregateOutputType | null
    _avg: Physician_clinic_timingsAvgAggregateOutputType | null
    _sum: Physician_clinic_timingsSumAggregateOutputType | null
    _min: Physician_clinic_timingsMinAggregateOutputType | null
    _max: Physician_clinic_timingsMaxAggregateOutputType | null
  }

  type GetPhysician_clinic_timingsGroupByPayload<T extends physician_clinic_timingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Physician_clinic_timingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Physician_clinic_timingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Physician_clinic_timingsGroupByOutputType[P]>
            : GetScalarType<T[P], Physician_clinic_timingsGroupByOutputType[P]>
        }
      >
    >


  export type physician_clinic_timingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    physician_id?: boolean
    theday?: boolean
    work_type?: boolean
    clinic?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }, ExtArgs["result"]["physician_clinic_timings"]>


  export type physician_clinic_timingsSelectScalar = {
    id?: boolean
    physician_id?: boolean
    theday?: boolean
    work_type?: boolean
    clinic?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }


  export type $physician_clinic_timingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "physician_clinic_timings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      physician_id: number
      theday: string
      work_type: $Enums.physician_clinic_timings_work_type
      clinic: string | null
      start_time: string | null
      end_time: string | null
      created_time: string | null
      updated_time: string | null
    }, ExtArgs["result"]["physician_clinic_timings"]>
    composites: {}
  }

  type physician_clinic_timingsGetPayload<S extends boolean | null | undefined | physician_clinic_timingsDefaultArgs> = $Result.GetResult<Prisma.$physician_clinic_timingsPayload, S>

  type physician_clinic_timingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<physician_clinic_timingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Physician_clinic_timingsCountAggregateInputType | true
    }

  export interface physician_clinic_timingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['physician_clinic_timings'], meta: { name: 'physician_clinic_timings' } }
    /**
     * Find zero or one Physician_clinic_timings that matches the filter.
     * @param {physician_clinic_timingsFindUniqueArgs} args - Arguments to find a Physician_clinic_timings
     * @example
     * // Get one Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends physician_clinic_timingsFindUniqueArgs>(args: SelectSubset<T, physician_clinic_timingsFindUniqueArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Physician_clinic_timings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {physician_clinic_timingsFindUniqueOrThrowArgs} args - Arguments to find a Physician_clinic_timings
     * @example
     * // Get one Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends physician_clinic_timingsFindUniqueOrThrowArgs>(args: SelectSubset<T, physician_clinic_timingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Physician_clinic_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsFindFirstArgs} args - Arguments to find a Physician_clinic_timings
     * @example
     * // Get one Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends physician_clinic_timingsFindFirstArgs>(args?: SelectSubset<T, physician_clinic_timingsFindFirstArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Physician_clinic_timings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsFindFirstOrThrowArgs} args - Arguments to find a Physician_clinic_timings
     * @example
     * // Get one Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends physician_clinic_timingsFindFirstOrThrowArgs>(args?: SelectSubset<T, physician_clinic_timingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Physician_clinic_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findMany()
     * 
     * // Get first 10 Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physician_clinic_timingsWithIdOnly = await prisma.physician_clinic_timings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends physician_clinic_timingsFindManyArgs>(args?: SelectSubset<T, physician_clinic_timingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Physician_clinic_timings.
     * @param {physician_clinic_timingsCreateArgs} args - Arguments to create a Physician_clinic_timings.
     * @example
     * // Create one Physician_clinic_timings
     * const Physician_clinic_timings = await prisma.physician_clinic_timings.create({
     *   data: {
     *     // ... data to create a Physician_clinic_timings
     *   }
     * })
     * 
     */
    create<T extends physician_clinic_timingsCreateArgs>(args: SelectSubset<T, physician_clinic_timingsCreateArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Physician_clinic_timings.
     * @param {physician_clinic_timingsCreateManyArgs} args - Arguments to create many Physician_clinic_timings.
     * @example
     * // Create many Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends physician_clinic_timingsCreateManyArgs>(args?: SelectSubset<T, physician_clinic_timingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Physician_clinic_timings.
     * @param {physician_clinic_timingsDeleteArgs} args - Arguments to delete one Physician_clinic_timings.
     * @example
     * // Delete one Physician_clinic_timings
     * const Physician_clinic_timings = await prisma.physician_clinic_timings.delete({
     *   where: {
     *     // ... filter to delete one Physician_clinic_timings
     *   }
     * })
     * 
     */
    delete<T extends physician_clinic_timingsDeleteArgs>(args: SelectSubset<T, physician_clinic_timingsDeleteArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Physician_clinic_timings.
     * @param {physician_clinic_timingsUpdateArgs} args - Arguments to update one Physician_clinic_timings.
     * @example
     * // Update one Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends physician_clinic_timingsUpdateArgs>(args: SelectSubset<T, physician_clinic_timingsUpdateArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Physician_clinic_timings.
     * @param {physician_clinic_timingsDeleteManyArgs} args - Arguments to filter Physician_clinic_timings to delete.
     * @example
     * // Delete a few Physician_clinic_timings
     * const { count } = await prisma.physician_clinic_timings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends physician_clinic_timingsDeleteManyArgs>(args?: SelectSubset<T, physician_clinic_timingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physician_clinic_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends physician_clinic_timingsUpdateManyArgs>(args: SelectSubset<T, physician_clinic_timingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician_clinic_timings.
     * @param {physician_clinic_timingsUpsertArgs} args - Arguments to update or create a Physician_clinic_timings.
     * @example
     * // Update or create a Physician_clinic_timings
     * const physician_clinic_timings = await prisma.physician_clinic_timings.upsert({
     *   create: {
     *     // ... data to create a Physician_clinic_timings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician_clinic_timings we want to update
     *   }
     * })
     */
    upsert<T extends physician_clinic_timingsUpsertArgs>(args: SelectSubset<T, physician_clinic_timingsUpsertArgs<ExtArgs>>): Prisma__physician_clinic_timingsClient<$Result.GetResult<Prisma.$physician_clinic_timingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Physician_clinic_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsCountArgs} args - Arguments to filter Physician_clinic_timings to count.
     * @example
     * // Count the number of Physician_clinic_timings
     * const count = await prisma.physician_clinic_timings.count({
     *   where: {
     *     // ... the filter for the Physician_clinic_timings we want to count
     *   }
     * })
    **/
    count<T extends physician_clinic_timingsCountArgs>(
      args?: Subset<T, physician_clinic_timingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Physician_clinic_timingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician_clinic_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Physician_clinic_timingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Physician_clinic_timingsAggregateArgs>(args: Subset<T, Physician_clinic_timingsAggregateArgs>): Prisma.PrismaPromise<GetPhysician_clinic_timingsAggregateType<T>>

    /**
     * Group by Physician_clinic_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_clinic_timingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends physician_clinic_timingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: physician_clinic_timingsGroupByArgs['orderBy'] }
        : { orderBy?: physician_clinic_timingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, physician_clinic_timingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysician_clinic_timingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the physician_clinic_timings model
   */
  readonly fields: physician_clinic_timingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for physician_clinic_timings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__physician_clinic_timingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the physician_clinic_timings model
   */ 
  interface physician_clinic_timingsFieldRefs {
    readonly id: FieldRef<"physician_clinic_timings", 'Int'>
    readonly physician_id: FieldRef<"physician_clinic_timings", 'Int'>
    readonly theday: FieldRef<"physician_clinic_timings", 'String'>
    readonly work_type: FieldRef<"physician_clinic_timings", 'physician_clinic_timings_work_type'>
    readonly clinic: FieldRef<"physician_clinic_timings", 'String'>
    readonly start_time: FieldRef<"physician_clinic_timings", 'String'>
    readonly end_time: FieldRef<"physician_clinic_timings", 'String'>
    readonly created_time: FieldRef<"physician_clinic_timings", 'String'>
    readonly updated_time: FieldRef<"physician_clinic_timings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * physician_clinic_timings findUnique
   */
  export type physician_clinic_timingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_clinic_timings to fetch.
     */
    where: physician_clinic_timingsWhereUniqueInput
  }

  /**
   * physician_clinic_timings findUniqueOrThrow
   */
  export type physician_clinic_timingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_clinic_timings to fetch.
     */
    where: physician_clinic_timingsWhereUniqueInput
  }

  /**
   * physician_clinic_timings findFirst
   */
  export type physician_clinic_timingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_clinic_timings to fetch.
     */
    where?: physician_clinic_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_clinic_timings to fetch.
     */
    orderBy?: physician_clinic_timingsOrderByWithRelationInput | physician_clinic_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_clinic_timings.
     */
    cursor?: physician_clinic_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_clinic_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_clinic_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_clinic_timings.
     */
    distinct?: Physician_clinic_timingsScalarFieldEnum | Physician_clinic_timingsScalarFieldEnum[]
  }

  /**
   * physician_clinic_timings findFirstOrThrow
   */
  export type physician_clinic_timingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_clinic_timings to fetch.
     */
    where?: physician_clinic_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_clinic_timings to fetch.
     */
    orderBy?: physician_clinic_timingsOrderByWithRelationInput | physician_clinic_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_clinic_timings.
     */
    cursor?: physician_clinic_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_clinic_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_clinic_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_clinic_timings.
     */
    distinct?: Physician_clinic_timingsScalarFieldEnum | Physician_clinic_timingsScalarFieldEnum[]
  }

  /**
   * physician_clinic_timings findMany
   */
  export type physician_clinic_timingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_clinic_timings to fetch.
     */
    where?: physician_clinic_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_clinic_timings to fetch.
     */
    orderBy?: physician_clinic_timingsOrderByWithRelationInput | physician_clinic_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing physician_clinic_timings.
     */
    cursor?: physician_clinic_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_clinic_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_clinic_timings.
     */
    skip?: number
    distinct?: Physician_clinic_timingsScalarFieldEnum | Physician_clinic_timingsScalarFieldEnum[]
  }

  /**
   * physician_clinic_timings create
   */
  export type physician_clinic_timingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * The data needed to create a physician_clinic_timings.
     */
    data: XOR<physician_clinic_timingsCreateInput, physician_clinic_timingsUncheckedCreateInput>
  }

  /**
   * physician_clinic_timings createMany
   */
  export type physician_clinic_timingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many physician_clinic_timings.
     */
    data: physician_clinic_timingsCreateManyInput | physician_clinic_timingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * physician_clinic_timings update
   */
  export type physician_clinic_timingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * The data needed to update a physician_clinic_timings.
     */
    data: XOR<physician_clinic_timingsUpdateInput, physician_clinic_timingsUncheckedUpdateInput>
    /**
     * Choose, which physician_clinic_timings to update.
     */
    where: physician_clinic_timingsWhereUniqueInput
  }

  /**
   * physician_clinic_timings updateMany
   */
  export type physician_clinic_timingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update physician_clinic_timings.
     */
    data: XOR<physician_clinic_timingsUpdateManyMutationInput, physician_clinic_timingsUncheckedUpdateManyInput>
    /**
     * Filter which physician_clinic_timings to update
     */
    where?: physician_clinic_timingsWhereInput
  }

  /**
   * physician_clinic_timings upsert
   */
  export type physician_clinic_timingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * The filter to search for the physician_clinic_timings to update in case it exists.
     */
    where: physician_clinic_timingsWhereUniqueInput
    /**
     * In case the physician_clinic_timings found by the `where` argument doesn't exist, create a new physician_clinic_timings with this data.
     */
    create: XOR<physician_clinic_timingsCreateInput, physician_clinic_timingsUncheckedCreateInput>
    /**
     * In case the physician_clinic_timings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<physician_clinic_timingsUpdateInput, physician_clinic_timingsUncheckedUpdateInput>
  }

  /**
   * physician_clinic_timings delete
   */
  export type physician_clinic_timingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
    /**
     * Filter which physician_clinic_timings to delete.
     */
    where: physician_clinic_timingsWhereUniqueInput
  }

  /**
   * physician_clinic_timings deleteMany
   */
  export type physician_clinic_timingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_clinic_timings to delete
     */
    where?: physician_clinic_timingsWhereInput
  }

  /**
   * physician_clinic_timings without action
   */
  export type physician_clinic_timingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_clinic_timings
     */
    select?: physician_clinic_timingsSelect<ExtArgs> | null
  }


  /**
   * Model physician_leaves
   */

  export type AggregatePhysician_leaves = {
    _count: Physician_leavesCountAggregateOutputType | null
    _avg: Physician_leavesAvgAggregateOutputType | null
    _sum: Physician_leavesSumAggregateOutputType | null
    _min: Physician_leavesMinAggregateOutputType | null
    _max: Physician_leavesMaxAggregateOutputType | null
  }

  export type Physician_leavesAvgAggregateOutputType = {
    id: number | null
    physician_id: number | null
  }

  export type Physician_leavesSumAggregateOutputType = {
    id: number | null
    physician_id: bigint | null
  }

  export type Physician_leavesMinAggregateOutputType = {
    id: number | null
    physician_id: bigint | null
    dates: string | null
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string | null
  }

  export type Physician_leavesMaxAggregateOutputType = {
    id: number | null
    physician_id: bigint | null
    dates: string | null
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string | null
  }

  export type Physician_leavesCountAggregateOutputType = {
    id: number
    physician_id: number
    dates: number
    start_time: number
    end_time: number
    reason: number
    created_time: number
    _all: number
  }


  export type Physician_leavesAvgAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_leavesSumAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_leavesMinAggregateInputType = {
    id?: true
    physician_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
  }

  export type Physician_leavesMaxAggregateInputType = {
    id?: true
    physician_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
  }

  export type Physician_leavesCountAggregateInputType = {
    id?: true
    physician_id?: true
    dates?: true
    start_time?: true
    end_time?: true
    reason?: true
    created_time?: true
    _all?: true
  }

  export type Physician_leavesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_leaves to aggregate.
     */
    where?: physician_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_leaves to fetch.
     */
    orderBy?: physician_leavesOrderByWithRelationInput | physician_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: physician_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned physician_leaves
    **/
    _count?: true | Physician_leavesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Physician_leavesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Physician_leavesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Physician_leavesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Physician_leavesMaxAggregateInputType
  }

  export type GetPhysician_leavesAggregateType<T extends Physician_leavesAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician_leaves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician_leaves[P]>
      : GetScalarType<T[P], AggregatePhysician_leaves[P]>
  }




  export type physician_leavesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: physician_leavesWhereInput
    orderBy?: physician_leavesOrderByWithAggregationInput | physician_leavesOrderByWithAggregationInput[]
    by: Physician_leavesScalarFieldEnum[] | Physician_leavesScalarFieldEnum
    having?: physician_leavesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Physician_leavesCountAggregateInputType | true
    _avg?: Physician_leavesAvgAggregateInputType
    _sum?: Physician_leavesSumAggregateInputType
    _min?: Physician_leavesMinAggregateInputType
    _max?: Physician_leavesMaxAggregateInputType
  }

  export type Physician_leavesGroupByOutputType = {
    id: number
    physician_id: bigint
    dates: string
    start_time: string | null
    end_time: string | null
    reason: string | null
    created_time: string
    _count: Physician_leavesCountAggregateOutputType | null
    _avg: Physician_leavesAvgAggregateOutputType | null
    _sum: Physician_leavesSumAggregateOutputType | null
    _min: Physician_leavesMinAggregateOutputType | null
    _max: Physician_leavesMaxAggregateOutputType | null
  }

  type GetPhysician_leavesGroupByPayload<T extends physician_leavesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Physician_leavesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Physician_leavesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Physician_leavesGroupByOutputType[P]>
            : GetScalarType<T[P], Physician_leavesGroupByOutputType[P]>
        }
      >
    >


  export type physician_leavesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    physician_id?: boolean
    dates?: boolean
    start_time?: boolean
    end_time?: boolean
    reason?: boolean
    created_time?: boolean
  }, ExtArgs["result"]["physician_leaves"]>


  export type physician_leavesSelectScalar = {
    id?: boolean
    physician_id?: boolean
    dates?: boolean
    start_time?: boolean
    end_time?: boolean
    reason?: boolean
    created_time?: boolean
  }


  export type $physician_leavesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "physician_leaves"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      physician_id: bigint
      dates: string
      start_time: string | null
      end_time: string | null
      reason: string | null
      created_time: string
    }, ExtArgs["result"]["physician_leaves"]>
    composites: {}
  }

  type physician_leavesGetPayload<S extends boolean | null | undefined | physician_leavesDefaultArgs> = $Result.GetResult<Prisma.$physician_leavesPayload, S>

  type physician_leavesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<physician_leavesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Physician_leavesCountAggregateInputType | true
    }

  export interface physician_leavesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['physician_leaves'], meta: { name: 'physician_leaves' } }
    /**
     * Find zero or one Physician_leaves that matches the filter.
     * @param {physician_leavesFindUniqueArgs} args - Arguments to find a Physician_leaves
     * @example
     * // Get one Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends physician_leavesFindUniqueArgs>(args: SelectSubset<T, physician_leavesFindUniqueArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Physician_leaves that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {physician_leavesFindUniqueOrThrowArgs} args - Arguments to find a Physician_leaves
     * @example
     * // Get one Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends physician_leavesFindUniqueOrThrowArgs>(args: SelectSubset<T, physician_leavesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Physician_leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesFindFirstArgs} args - Arguments to find a Physician_leaves
     * @example
     * // Get one Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends physician_leavesFindFirstArgs>(args?: SelectSubset<T, physician_leavesFindFirstArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Physician_leaves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesFindFirstOrThrowArgs} args - Arguments to find a Physician_leaves
     * @example
     * // Get one Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends physician_leavesFindFirstOrThrowArgs>(args?: SelectSubset<T, physician_leavesFindFirstOrThrowArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Physician_leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findMany()
     * 
     * // Get first 10 Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physician_leavesWithIdOnly = await prisma.physician_leaves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends physician_leavesFindManyArgs>(args?: SelectSubset<T, physician_leavesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Physician_leaves.
     * @param {physician_leavesCreateArgs} args - Arguments to create a Physician_leaves.
     * @example
     * // Create one Physician_leaves
     * const Physician_leaves = await prisma.physician_leaves.create({
     *   data: {
     *     // ... data to create a Physician_leaves
     *   }
     * })
     * 
     */
    create<T extends physician_leavesCreateArgs>(args: SelectSubset<T, physician_leavesCreateArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Physician_leaves.
     * @param {physician_leavesCreateManyArgs} args - Arguments to create many Physician_leaves.
     * @example
     * // Create many Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends physician_leavesCreateManyArgs>(args?: SelectSubset<T, physician_leavesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Physician_leaves.
     * @param {physician_leavesDeleteArgs} args - Arguments to delete one Physician_leaves.
     * @example
     * // Delete one Physician_leaves
     * const Physician_leaves = await prisma.physician_leaves.delete({
     *   where: {
     *     // ... filter to delete one Physician_leaves
     *   }
     * })
     * 
     */
    delete<T extends physician_leavesDeleteArgs>(args: SelectSubset<T, physician_leavesDeleteArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Physician_leaves.
     * @param {physician_leavesUpdateArgs} args - Arguments to update one Physician_leaves.
     * @example
     * // Update one Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends physician_leavesUpdateArgs>(args: SelectSubset<T, physician_leavesUpdateArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Physician_leaves.
     * @param {physician_leavesDeleteManyArgs} args - Arguments to filter Physician_leaves to delete.
     * @example
     * // Delete a few Physician_leaves
     * const { count } = await prisma.physician_leaves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends physician_leavesDeleteManyArgs>(args?: SelectSubset<T, physician_leavesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physician_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends physician_leavesUpdateManyArgs>(args: SelectSubset<T, physician_leavesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician_leaves.
     * @param {physician_leavesUpsertArgs} args - Arguments to update or create a Physician_leaves.
     * @example
     * // Update or create a Physician_leaves
     * const physician_leaves = await prisma.physician_leaves.upsert({
     *   create: {
     *     // ... data to create a Physician_leaves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician_leaves we want to update
     *   }
     * })
     */
    upsert<T extends physician_leavesUpsertArgs>(args: SelectSubset<T, physician_leavesUpsertArgs<ExtArgs>>): Prisma__physician_leavesClient<$Result.GetResult<Prisma.$physician_leavesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Physician_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesCountArgs} args - Arguments to filter Physician_leaves to count.
     * @example
     * // Count the number of Physician_leaves
     * const count = await prisma.physician_leaves.count({
     *   where: {
     *     // ... the filter for the Physician_leaves we want to count
     *   }
     * })
    **/
    count<T extends physician_leavesCountArgs>(
      args?: Subset<T, physician_leavesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Physician_leavesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Physician_leavesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Physician_leavesAggregateArgs>(args: Subset<T, Physician_leavesAggregateArgs>): Prisma.PrismaPromise<GetPhysician_leavesAggregateType<T>>

    /**
     * Group by Physician_leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_leavesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends physician_leavesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: physician_leavesGroupByArgs['orderBy'] }
        : { orderBy?: physician_leavesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, physician_leavesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysician_leavesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the physician_leaves model
   */
  readonly fields: physician_leavesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for physician_leaves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__physician_leavesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the physician_leaves model
   */ 
  interface physician_leavesFieldRefs {
    readonly id: FieldRef<"physician_leaves", 'Int'>
    readonly physician_id: FieldRef<"physician_leaves", 'BigInt'>
    readonly dates: FieldRef<"physician_leaves", 'String'>
    readonly start_time: FieldRef<"physician_leaves", 'String'>
    readonly end_time: FieldRef<"physician_leaves", 'String'>
    readonly reason: FieldRef<"physician_leaves", 'String'>
    readonly created_time: FieldRef<"physician_leaves", 'String'>
  }
    

  // Custom InputTypes
  /**
   * physician_leaves findUnique
   */
  export type physician_leavesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter, which physician_leaves to fetch.
     */
    where: physician_leavesWhereUniqueInput
  }

  /**
   * physician_leaves findUniqueOrThrow
   */
  export type physician_leavesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter, which physician_leaves to fetch.
     */
    where: physician_leavesWhereUniqueInput
  }

  /**
   * physician_leaves findFirst
   */
  export type physician_leavesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter, which physician_leaves to fetch.
     */
    where?: physician_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_leaves to fetch.
     */
    orderBy?: physician_leavesOrderByWithRelationInput | physician_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_leaves.
     */
    cursor?: physician_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_leaves.
     */
    distinct?: Physician_leavesScalarFieldEnum | Physician_leavesScalarFieldEnum[]
  }

  /**
   * physician_leaves findFirstOrThrow
   */
  export type physician_leavesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter, which physician_leaves to fetch.
     */
    where?: physician_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_leaves to fetch.
     */
    orderBy?: physician_leavesOrderByWithRelationInput | physician_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_leaves.
     */
    cursor?: physician_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_leaves.
     */
    distinct?: Physician_leavesScalarFieldEnum | Physician_leavesScalarFieldEnum[]
  }

  /**
   * physician_leaves findMany
   */
  export type physician_leavesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter, which physician_leaves to fetch.
     */
    where?: physician_leavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_leaves to fetch.
     */
    orderBy?: physician_leavesOrderByWithRelationInput | physician_leavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing physician_leaves.
     */
    cursor?: physician_leavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_leaves.
     */
    skip?: number
    distinct?: Physician_leavesScalarFieldEnum | Physician_leavesScalarFieldEnum[]
  }

  /**
   * physician_leaves create
   */
  export type physician_leavesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * The data needed to create a physician_leaves.
     */
    data: XOR<physician_leavesCreateInput, physician_leavesUncheckedCreateInput>
  }

  /**
   * physician_leaves createMany
   */
  export type physician_leavesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many physician_leaves.
     */
    data: physician_leavesCreateManyInput | physician_leavesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * physician_leaves update
   */
  export type physician_leavesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * The data needed to update a physician_leaves.
     */
    data: XOR<physician_leavesUpdateInput, physician_leavesUncheckedUpdateInput>
    /**
     * Choose, which physician_leaves to update.
     */
    where: physician_leavesWhereUniqueInput
  }

  /**
   * physician_leaves updateMany
   */
  export type physician_leavesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update physician_leaves.
     */
    data: XOR<physician_leavesUpdateManyMutationInput, physician_leavesUncheckedUpdateManyInput>
    /**
     * Filter which physician_leaves to update
     */
    where?: physician_leavesWhereInput
  }

  /**
   * physician_leaves upsert
   */
  export type physician_leavesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * The filter to search for the physician_leaves to update in case it exists.
     */
    where: physician_leavesWhereUniqueInput
    /**
     * In case the physician_leaves found by the `where` argument doesn't exist, create a new physician_leaves with this data.
     */
    create: XOR<physician_leavesCreateInput, physician_leavesUncheckedCreateInput>
    /**
     * In case the physician_leaves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<physician_leavesUpdateInput, physician_leavesUncheckedUpdateInput>
  }

  /**
   * physician_leaves delete
   */
  export type physician_leavesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
    /**
     * Filter which physician_leaves to delete.
     */
    where: physician_leavesWhereUniqueInput
  }

  /**
   * physician_leaves deleteMany
   */
  export type physician_leavesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_leaves to delete
     */
    where?: physician_leavesWhereInput
  }

  /**
   * physician_leaves without action
   */
  export type physician_leavesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_leaves
     */
    select?: physician_leavesSelect<ExtArgs> | null
  }


  /**
   * Model physician_timings
   */

  export type AggregatePhysician_timings = {
    _count: Physician_timingsCountAggregateOutputType | null
    _avg: Physician_timingsAvgAggregateOutputType | null
    _sum: Physician_timingsSumAggregateOutputType | null
    _min: Physician_timingsMinAggregateOutputType | null
    _max: Physician_timingsMaxAggregateOutputType | null
  }

  export type Physician_timingsAvgAggregateOutputType = {
    id: number | null
    physician_id: number | null
  }

  export type Physician_timingsSumAggregateOutputType = {
    id: number | null
    physician_id: number | null
  }

  export type Physician_timingsMinAggregateOutputType = {
    id: number | null
    physician_id: number | null
    theday: string | null
    work_type: $Enums.physician_timings_work_type | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Physician_timingsMaxAggregateOutputType = {
    id: number | null
    physician_id: number | null
    theday: string | null
    work_type: $Enums.physician_timings_work_type | null
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
  }

  export type Physician_timingsCountAggregateOutputType = {
    id: number
    physician_id: number
    theday: number
    work_type: number
    start_time: number
    end_time: number
    created_time: number
    updated_time: number
    _all: number
  }


  export type Physician_timingsAvgAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_timingsSumAggregateInputType = {
    id?: true
    physician_id?: true
  }

  export type Physician_timingsMinAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Physician_timingsMaxAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
  }

  export type Physician_timingsCountAggregateInputType = {
    id?: true
    physician_id?: true
    theday?: true
    work_type?: true
    start_time?: true
    end_time?: true
    created_time?: true
    updated_time?: true
    _all?: true
  }

  export type Physician_timingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_timings to aggregate.
     */
    where?: physician_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_timings to fetch.
     */
    orderBy?: physician_timingsOrderByWithRelationInput | physician_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: physician_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned physician_timings
    **/
    _count?: true | Physician_timingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Physician_timingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Physician_timingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Physician_timingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Physician_timingsMaxAggregateInputType
  }

  export type GetPhysician_timingsAggregateType<T extends Physician_timingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician_timings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician_timings[P]>
      : GetScalarType<T[P], AggregatePhysician_timings[P]>
  }




  export type physician_timingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: physician_timingsWhereInput
    orderBy?: physician_timingsOrderByWithAggregationInput | physician_timingsOrderByWithAggregationInput[]
    by: Physician_timingsScalarFieldEnum[] | Physician_timingsScalarFieldEnum
    having?: physician_timingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Physician_timingsCountAggregateInputType | true
    _avg?: Physician_timingsAvgAggregateInputType
    _sum?: Physician_timingsSumAggregateInputType
    _min?: Physician_timingsMinAggregateInputType
    _max?: Physician_timingsMaxAggregateInputType
  }

  export type Physician_timingsGroupByOutputType = {
    id: number
    physician_id: number
    theday: string
    work_type: $Enums.physician_timings_work_type
    start_time: string | null
    end_time: string | null
    created_time: string | null
    updated_time: string | null
    _count: Physician_timingsCountAggregateOutputType | null
    _avg: Physician_timingsAvgAggregateOutputType | null
    _sum: Physician_timingsSumAggregateOutputType | null
    _min: Physician_timingsMinAggregateOutputType | null
    _max: Physician_timingsMaxAggregateOutputType | null
  }

  type GetPhysician_timingsGroupByPayload<T extends physician_timingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Physician_timingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Physician_timingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Physician_timingsGroupByOutputType[P]>
            : GetScalarType<T[P], Physician_timingsGroupByOutputType[P]>
        }
      >
    >


  export type physician_timingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    physician_id?: boolean
    theday?: boolean
    work_type?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }, ExtArgs["result"]["physician_timings"]>


  export type physician_timingsSelectScalar = {
    id?: boolean
    physician_id?: boolean
    theday?: boolean
    work_type?: boolean
    start_time?: boolean
    end_time?: boolean
    created_time?: boolean
    updated_time?: boolean
  }


  export type $physician_timingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "physician_timings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      physician_id: number
      theday: string
      work_type: $Enums.physician_timings_work_type
      start_time: string | null
      end_time: string | null
      created_time: string | null
      updated_time: string | null
    }, ExtArgs["result"]["physician_timings"]>
    composites: {}
  }

  type physician_timingsGetPayload<S extends boolean | null | undefined | physician_timingsDefaultArgs> = $Result.GetResult<Prisma.$physician_timingsPayload, S>

  type physician_timingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<physician_timingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Physician_timingsCountAggregateInputType | true
    }

  export interface physician_timingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['physician_timings'], meta: { name: 'physician_timings' } }
    /**
     * Find zero or one Physician_timings that matches the filter.
     * @param {physician_timingsFindUniqueArgs} args - Arguments to find a Physician_timings
     * @example
     * // Get one Physician_timings
     * const physician_timings = await prisma.physician_timings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends physician_timingsFindUniqueArgs>(args: SelectSubset<T, physician_timingsFindUniqueArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Physician_timings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {physician_timingsFindUniqueOrThrowArgs} args - Arguments to find a Physician_timings
     * @example
     * // Get one Physician_timings
     * const physician_timings = await prisma.physician_timings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends physician_timingsFindUniqueOrThrowArgs>(args: SelectSubset<T, physician_timingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Physician_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsFindFirstArgs} args - Arguments to find a Physician_timings
     * @example
     * // Get one Physician_timings
     * const physician_timings = await prisma.physician_timings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends physician_timingsFindFirstArgs>(args?: SelectSubset<T, physician_timingsFindFirstArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Physician_timings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsFindFirstOrThrowArgs} args - Arguments to find a Physician_timings
     * @example
     * // Get one Physician_timings
     * const physician_timings = await prisma.physician_timings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends physician_timingsFindFirstOrThrowArgs>(args?: SelectSubset<T, physician_timingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Physician_timings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physician_timings
     * const physician_timings = await prisma.physician_timings.findMany()
     * 
     * // Get first 10 Physician_timings
     * const physician_timings = await prisma.physician_timings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physician_timingsWithIdOnly = await prisma.physician_timings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends physician_timingsFindManyArgs>(args?: SelectSubset<T, physician_timingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Physician_timings.
     * @param {physician_timingsCreateArgs} args - Arguments to create a Physician_timings.
     * @example
     * // Create one Physician_timings
     * const Physician_timings = await prisma.physician_timings.create({
     *   data: {
     *     // ... data to create a Physician_timings
     *   }
     * })
     * 
     */
    create<T extends physician_timingsCreateArgs>(args: SelectSubset<T, physician_timingsCreateArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Physician_timings.
     * @param {physician_timingsCreateManyArgs} args - Arguments to create many Physician_timings.
     * @example
     * // Create many Physician_timings
     * const physician_timings = await prisma.physician_timings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends physician_timingsCreateManyArgs>(args?: SelectSubset<T, physician_timingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Physician_timings.
     * @param {physician_timingsDeleteArgs} args - Arguments to delete one Physician_timings.
     * @example
     * // Delete one Physician_timings
     * const Physician_timings = await prisma.physician_timings.delete({
     *   where: {
     *     // ... filter to delete one Physician_timings
     *   }
     * })
     * 
     */
    delete<T extends physician_timingsDeleteArgs>(args: SelectSubset<T, physician_timingsDeleteArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Physician_timings.
     * @param {physician_timingsUpdateArgs} args - Arguments to update one Physician_timings.
     * @example
     * // Update one Physician_timings
     * const physician_timings = await prisma.physician_timings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends physician_timingsUpdateArgs>(args: SelectSubset<T, physician_timingsUpdateArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Physician_timings.
     * @param {physician_timingsDeleteManyArgs} args - Arguments to filter Physician_timings to delete.
     * @example
     * // Delete a few Physician_timings
     * const { count } = await prisma.physician_timings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends physician_timingsDeleteManyArgs>(args?: SelectSubset<T, physician_timingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physician_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physician_timings
     * const physician_timings = await prisma.physician_timings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends physician_timingsUpdateManyArgs>(args: SelectSubset<T, physician_timingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician_timings.
     * @param {physician_timingsUpsertArgs} args - Arguments to update or create a Physician_timings.
     * @example
     * // Update or create a Physician_timings
     * const physician_timings = await prisma.physician_timings.upsert({
     *   create: {
     *     // ... data to create a Physician_timings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician_timings we want to update
     *   }
     * })
     */
    upsert<T extends physician_timingsUpsertArgs>(args: SelectSubset<T, physician_timingsUpsertArgs<ExtArgs>>): Prisma__physician_timingsClient<$Result.GetResult<Prisma.$physician_timingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Physician_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsCountArgs} args - Arguments to filter Physician_timings to count.
     * @example
     * // Count the number of Physician_timings
     * const count = await prisma.physician_timings.count({
     *   where: {
     *     // ... the filter for the Physician_timings we want to count
     *   }
     * })
    **/
    count<T extends physician_timingsCountArgs>(
      args?: Subset<T, physician_timingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Physician_timingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Physician_timingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Physician_timingsAggregateArgs>(args: Subset<T, Physician_timingsAggregateArgs>): Prisma.PrismaPromise<GetPhysician_timingsAggregateType<T>>

    /**
     * Group by Physician_timings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {physician_timingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends physician_timingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: physician_timingsGroupByArgs['orderBy'] }
        : { orderBy?: physician_timingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, physician_timingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysician_timingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the physician_timings model
   */
  readonly fields: physician_timingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for physician_timings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__physician_timingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the physician_timings model
   */ 
  interface physician_timingsFieldRefs {
    readonly id: FieldRef<"physician_timings", 'Int'>
    readonly physician_id: FieldRef<"physician_timings", 'Int'>
    readonly theday: FieldRef<"physician_timings", 'String'>
    readonly work_type: FieldRef<"physician_timings", 'physician_timings_work_type'>
    readonly start_time: FieldRef<"physician_timings", 'String'>
    readonly end_time: FieldRef<"physician_timings", 'String'>
    readonly created_time: FieldRef<"physician_timings", 'String'>
    readonly updated_time: FieldRef<"physician_timings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * physician_timings findUnique
   */
  export type physician_timingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_timings to fetch.
     */
    where: physician_timingsWhereUniqueInput
  }

  /**
   * physician_timings findUniqueOrThrow
   */
  export type physician_timingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_timings to fetch.
     */
    where: physician_timingsWhereUniqueInput
  }

  /**
   * physician_timings findFirst
   */
  export type physician_timingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_timings to fetch.
     */
    where?: physician_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_timings to fetch.
     */
    orderBy?: physician_timingsOrderByWithRelationInput | physician_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_timings.
     */
    cursor?: physician_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_timings.
     */
    distinct?: Physician_timingsScalarFieldEnum | Physician_timingsScalarFieldEnum[]
  }

  /**
   * physician_timings findFirstOrThrow
   */
  export type physician_timingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_timings to fetch.
     */
    where?: physician_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_timings to fetch.
     */
    orderBy?: physician_timingsOrderByWithRelationInput | physician_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for physician_timings.
     */
    cursor?: physician_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_timings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of physician_timings.
     */
    distinct?: Physician_timingsScalarFieldEnum | Physician_timingsScalarFieldEnum[]
  }

  /**
   * physician_timings findMany
   */
  export type physician_timingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter, which physician_timings to fetch.
     */
    where?: physician_timingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of physician_timings to fetch.
     */
    orderBy?: physician_timingsOrderByWithRelationInput | physician_timingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing physician_timings.
     */
    cursor?: physician_timingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` physician_timings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` physician_timings.
     */
    skip?: number
    distinct?: Physician_timingsScalarFieldEnum | Physician_timingsScalarFieldEnum[]
  }

  /**
   * physician_timings create
   */
  export type physician_timingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * The data needed to create a physician_timings.
     */
    data: XOR<physician_timingsCreateInput, physician_timingsUncheckedCreateInput>
  }

  /**
   * physician_timings createMany
   */
  export type physician_timingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many physician_timings.
     */
    data: physician_timingsCreateManyInput | physician_timingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * physician_timings update
   */
  export type physician_timingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * The data needed to update a physician_timings.
     */
    data: XOR<physician_timingsUpdateInput, physician_timingsUncheckedUpdateInput>
    /**
     * Choose, which physician_timings to update.
     */
    where: physician_timingsWhereUniqueInput
  }

  /**
   * physician_timings updateMany
   */
  export type physician_timingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update physician_timings.
     */
    data: XOR<physician_timingsUpdateManyMutationInput, physician_timingsUncheckedUpdateManyInput>
    /**
     * Filter which physician_timings to update
     */
    where?: physician_timingsWhereInput
  }

  /**
   * physician_timings upsert
   */
  export type physician_timingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * The filter to search for the physician_timings to update in case it exists.
     */
    where: physician_timingsWhereUniqueInput
    /**
     * In case the physician_timings found by the `where` argument doesn't exist, create a new physician_timings with this data.
     */
    create: XOR<physician_timingsCreateInput, physician_timingsUncheckedCreateInput>
    /**
     * In case the physician_timings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<physician_timingsUpdateInput, physician_timingsUncheckedUpdateInput>
  }

  /**
   * physician_timings delete
   */
  export type physician_timingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
    /**
     * Filter which physician_timings to delete.
     */
    where: physician_timingsWhereUniqueInput
  }

  /**
   * physician_timings deleteMany
   */
  export type physician_timingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which physician_timings to delete
     */
    where?: physician_timingsWhereInput
  }

  /**
   * physician_timings without action
   */
  export type physician_timingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the physician_timings
     */
    select?: physician_timingsSelect<ExtArgs> | null
  }


  /**
   * Model preferredlabs
   */

  export type AggregatePreferredlabs = {
    _count: PreferredlabsCountAggregateOutputType | null
    _avg: PreferredlabsAvgAggregateOutputType | null
    _sum: PreferredlabsSumAggregateOutputType | null
    _min: PreferredlabsMinAggregateOutputType | null
    _max: PreferredlabsMaxAggregateOutputType | null
  }

  export type PreferredlabsAvgAggregateOutputType = {
    preferredlabs_id: number | null
    laboratory_id: number | null
    physician_id: number | null
    is_active: number | null
  }

  export type PreferredlabsSumAggregateOutputType = {
    preferredlabs_id: number | null
    laboratory_id: number | null
    physician_id: number | null
    is_active: number | null
  }

  export type PreferredlabsMinAggregateOutputType = {
    preferredlabs_id: number | null
    laboratory_id: number | null
    physician_id: number | null
    is_active: number | null
  }

  export type PreferredlabsMaxAggregateOutputType = {
    preferredlabs_id: number | null
    laboratory_id: number | null
    physician_id: number | null
    is_active: number | null
  }

  export type PreferredlabsCountAggregateOutputType = {
    preferredlabs_id: number
    laboratory_id: number
    physician_id: number
    is_active: number
    _all: number
  }


  export type PreferredlabsAvgAggregateInputType = {
    preferredlabs_id?: true
    laboratory_id?: true
    physician_id?: true
    is_active?: true
  }

  export type PreferredlabsSumAggregateInputType = {
    preferredlabs_id?: true
    laboratory_id?: true
    physician_id?: true
    is_active?: true
  }

  export type PreferredlabsMinAggregateInputType = {
    preferredlabs_id?: true
    laboratory_id?: true
    physician_id?: true
    is_active?: true
  }

  export type PreferredlabsMaxAggregateInputType = {
    preferredlabs_id?: true
    laboratory_id?: true
    physician_id?: true
    is_active?: true
  }

  export type PreferredlabsCountAggregateInputType = {
    preferredlabs_id?: true
    laboratory_id?: true
    physician_id?: true
    is_active?: true
    _all?: true
  }

  export type PreferredlabsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preferredlabs to aggregate.
     */
    where?: preferredlabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferredlabs to fetch.
     */
    orderBy?: preferredlabsOrderByWithRelationInput | preferredlabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preferredlabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferredlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferredlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preferredlabs
    **/
    _count?: true | PreferredlabsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferredlabsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferredlabsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferredlabsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferredlabsMaxAggregateInputType
  }

  export type GetPreferredlabsAggregateType<T extends PreferredlabsAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferredlabs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferredlabs[P]>
      : GetScalarType<T[P], AggregatePreferredlabs[P]>
  }




  export type preferredlabsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preferredlabsWhereInput
    orderBy?: preferredlabsOrderByWithAggregationInput | preferredlabsOrderByWithAggregationInput[]
    by: PreferredlabsScalarFieldEnum[] | PreferredlabsScalarFieldEnum
    having?: preferredlabsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferredlabsCountAggregateInputType | true
    _avg?: PreferredlabsAvgAggregateInputType
    _sum?: PreferredlabsSumAggregateInputType
    _min?: PreferredlabsMinAggregateInputType
    _max?: PreferredlabsMaxAggregateInputType
  }

  export type PreferredlabsGroupByOutputType = {
    preferredlabs_id: number
    laboratory_id: number
    physician_id: number
    is_active: number
    _count: PreferredlabsCountAggregateOutputType | null
    _avg: PreferredlabsAvgAggregateOutputType | null
    _sum: PreferredlabsSumAggregateOutputType | null
    _min: PreferredlabsMinAggregateOutputType | null
    _max: PreferredlabsMaxAggregateOutputType | null
  }

  type GetPreferredlabsGroupByPayload<T extends preferredlabsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferredlabsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferredlabsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferredlabsGroupByOutputType[P]>
            : GetScalarType<T[P], PreferredlabsGroupByOutputType[P]>
        }
      >
    >


  export type preferredlabsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    preferredlabs_id?: boolean
    laboratory_id?: boolean
    physician_id?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["preferredlabs"]>


  export type preferredlabsSelectScalar = {
    preferredlabs_id?: boolean
    laboratory_id?: boolean
    physician_id?: boolean
    is_active?: boolean
  }


  export type $preferredlabsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preferredlabs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      preferredlabs_id: number
      laboratory_id: number
      physician_id: number
      is_active: number
    }, ExtArgs["result"]["preferredlabs"]>
    composites: {}
  }

  type preferredlabsGetPayload<S extends boolean | null | undefined | preferredlabsDefaultArgs> = $Result.GetResult<Prisma.$preferredlabsPayload, S>

  type preferredlabsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<preferredlabsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreferredlabsCountAggregateInputType | true
    }

  export interface preferredlabsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preferredlabs'], meta: { name: 'preferredlabs' } }
    /**
     * Find zero or one Preferredlabs that matches the filter.
     * @param {preferredlabsFindUniqueArgs} args - Arguments to find a Preferredlabs
     * @example
     * // Get one Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preferredlabsFindUniqueArgs>(args: SelectSubset<T, preferredlabsFindUniqueArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Preferredlabs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {preferredlabsFindUniqueOrThrowArgs} args - Arguments to find a Preferredlabs
     * @example
     * // Get one Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preferredlabsFindUniqueOrThrowArgs>(args: SelectSubset<T, preferredlabsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Preferredlabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsFindFirstArgs} args - Arguments to find a Preferredlabs
     * @example
     * // Get one Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preferredlabsFindFirstArgs>(args?: SelectSubset<T, preferredlabsFindFirstArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Preferredlabs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsFindFirstOrThrowArgs} args - Arguments to find a Preferredlabs
     * @example
     * // Get one Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preferredlabsFindFirstOrThrowArgs>(args?: SelectSubset<T, preferredlabsFindFirstOrThrowArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Preferredlabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findMany()
     * 
     * // Get first 10 Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.findMany({ take: 10 })
     * 
     * // Only select the `preferredlabs_id`
     * const preferredlabsWithPreferredlabs_idOnly = await prisma.preferredlabs.findMany({ select: { preferredlabs_id: true } })
     * 
     */
    findMany<T extends preferredlabsFindManyArgs>(args?: SelectSubset<T, preferredlabsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Preferredlabs.
     * @param {preferredlabsCreateArgs} args - Arguments to create a Preferredlabs.
     * @example
     * // Create one Preferredlabs
     * const Preferredlabs = await prisma.preferredlabs.create({
     *   data: {
     *     // ... data to create a Preferredlabs
     *   }
     * })
     * 
     */
    create<T extends preferredlabsCreateArgs>(args: SelectSubset<T, preferredlabsCreateArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Preferredlabs.
     * @param {preferredlabsCreateManyArgs} args - Arguments to create many Preferredlabs.
     * @example
     * // Create many Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preferredlabsCreateManyArgs>(args?: SelectSubset<T, preferredlabsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Preferredlabs.
     * @param {preferredlabsDeleteArgs} args - Arguments to delete one Preferredlabs.
     * @example
     * // Delete one Preferredlabs
     * const Preferredlabs = await prisma.preferredlabs.delete({
     *   where: {
     *     // ... filter to delete one Preferredlabs
     *   }
     * })
     * 
     */
    delete<T extends preferredlabsDeleteArgs>(args: SelectSubset<T, preferredlabsDeleteArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Preferredlabs.
     * @param {preferredlabsUpdateArgs} args - Arguments to update one Preferredlabs.
     * @example
     * // Update one Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preferredlabsUpdateArgs>(args: SelectSubset<T, preferredlabsUpdateArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Preferredlabs.
     * @param {preferredlabsDeleteManyArgs} args - Arguments to filter Preferredlabs to delete.
     * @example
     * // Delete a few Preferredlabs
     * const { count } = await prisma.preferredlabs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preferredlabsDeleteManyArgs>(args?: SelectSubset<T, preferredlabsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferredlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preferredlabsUpdateManyArgs>(args: SelectSubset<T, preferredlabsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Preferredlabs.
     * @param {preferredlabsUpsertArgs} args - Arguments to update or create a Preferredlabs.
     * @example
     * // Update or create a Preferredlabs
     * const preferredlabs = await prisma.preferredlabs.upsert({
     *   create: {
     *     // ... data to create a Preferredlabs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferredlabs we want to update
     *   }
     * })
     */
    upsert<T extends preferredlabsUpsertArgs>(args: SelectSubset<T, preferredlabsUpsertArgs<ExtArgs>>): Prisma__preferredlabsClient<$Result.GetResult<Prisma.$preferredlabsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Preferredlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsCountArgs} args - Arguments to filter Preferredlabs to count.
     * @example
     * // Count the number of Preferredlabs
     * const count = await prisma.preferredlabs.count({
     *   where: {
     *     // ... the filter for the Preferredlabs we want to count
     *   }
     * })
    **/
    count<T extends preferredlabsCountArgs>(
      args?: Subset<T, preferredlabsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferredlabsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preferredlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredlabsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferredlabsAggregateArgs>(args: Subset<T, PreferredlabsAggregateArgs>): Prisma.PrismaPromise<GetPreferredlabsAggregateType<T>>

    /**
     * Group by Preferredlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferredlabsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preferredlabsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preferredlabsGroupByArgs['orderBy'] }
        : { orderBy?: preferredlabsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preferredlabsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferredlabsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preferredlabs model
   */
  readonly fields: preferredlabsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preferredlabs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preferredlabsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preferredlabs model
   */ 
  interface preferredlabsFieldRefs {
    readonly preferredlabs_id: FieldRef<"preferredlabs", 'Int'>
    readonly laboratory_id: FieldRef<"preferredlabs", 'Int'>
    readonly physician_id: FieldRef<"preferredlabs", 'Int'>
    readonly is_active: FieldRef<"preferredlabs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * preferredlabs findUnique
   */
  export type preferredlabsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter, which preferredlabs to fetch.
     */
    where: preferredlabsWhereUniqueInput
  }

  /**
   * preferredlabs findUniqueOrThrow
   */
  export type preferredlabsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter, which preferredlabs to fetch.
     */
    where: preferredlabsWhereUniqueInput
  }

  /**
   * preferredlabs findFirst
   */
  export type preferredlabsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter, which preferredlabs to fetch.
     */
    where?: preferredlabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferredlabs to fetch.
     */
    orderBy?: preferredlabsOrderByWithRelationInput | preferredlabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preferredlabs.
     */
    cursor?: preferredlabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferredlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferredlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preferredlabs.
     */
    distinct?: PreferredlabsScalarFieldEnum | PreferredlabsScalarFieldEnum[]
  }

  /**
   * preferredlabs findFirstOrThrow
   */
  export type preferredlabsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter, which preferredlabs to fetch.
     */
    where?: preferredlabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferredlabs to fetch.
     */
    orderBy?: preferredlabsOrderByWithRelationInput | preferredlabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preferredlabs.
     */
    cursor?: preferredlabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferredlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferredlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preferredlabs.
     */
    distinct?: PreferredlabsScalarFieldEnum | PreferredlabsScalarFieldEnum[]
  }

  /**
   * preferredlabs findMany
   */
  export type preferredlabsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter, which preferredlabs to fetch.
     */
    where?: preferredlabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferredlabs to fetch.
     */
    orderBy?: preferredlabsOrderByWithRelationInput | preferredlabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preferredlabs.
     */
    cursor?: preferredlabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferredlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferredlabs.
     */
    skip?: number
    distinct?: PreferredlabsScalarFieldEnum | PreferredlabsScalarFieldEnum[]
  }

  /**
   * preferredlabs create
   */
  export type preferredlabsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * The data needed to create a preferredlabs.
     */
    data: XOR<preferredlabsCreateInput, preferredlabsUncheckedCreateInput>
  }

  /**
   * preferredlabs createMany
   */
  export type preferredlabsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preferredlabs.
     */
    data: preferredlabsCreateManyInput | preferredlabsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preferredlabs update
   */
  export type preferredlabsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * The data needed to update a preferredlabs.
     */
    data: XOR<preferredlabsUpdateInput, preferredlabsUncheckedUpdateInput>
    /**
     * Choose, which preferredlabs to update.
     */
    where: preferredlabsWhereUniqueInput
  }

  /**
   * preferredlabs updateMany
   */
  export type preferredlabsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preferredlabs.
     */
    data: XOR<preferredlabsUpdateManyMutationInput, preferredlabsUncheckedUpdateManyInput>
    /**
     * Filter which preferredlabs to update
     */
    where?: preferredlabsWhereInput
  }

  /**
   * preferredlabs upsert
   */
  export type preferredlabsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * The filter to search for the preferredlabs to update in case it exists.
     */
    where: preferredlabsWhereUniqueInput
    /**
     * In case the preferredlabs found by the `where` argument doesn't exist, create a new preferredlabs with this data.
     */
    create: XOR<preferredlabsCreateInput, preferredlabsUncheckedCreateInput>
    /**
     * In case the preferredlabs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preferredlabsUpdateInput, preferredlabsUncheckedUpdateInput>
  }

  /**
   * preferredlabs delete
   */
  export type preferredlabsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
    /**
     * Filter which preferredlabs to delete.
     */
    where: preferredlabsWhereUniqueInput
  }

  /**
   * preferredlabs deleteMany
   */
  export type preferredlabsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preferredlabs to delete
     */
    where?: preferredlabsWhereInput
  }

  /**
   * preferredlabs without action
   */
  export type preferredlabsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferredlabs
     */
    select?: preferredlabsSelect<ExtArgs> | null
  }


  /**
   * Model prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    prescription_id: number | null
    patient_id: number | null
    dependent_id: number | null
    doctor_id: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    prescription_id: number | null
    patient_id: number | null
    dependent_id: number | null
    doctor_id: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    prescription_id: number | null
    prescription_num: string | null
    patient_id: number | null
    dependent_id: number | null
    doctor_id: number | null
    symptoms: string | null
    type: string | null
    med_name: string | null
    mg: string | null
    dose: string | null
    num_days: string | null
    instruction: string | null
    advice: string | null
    created_on: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    prescription_id: number | null
    prescription_num: string | null
    patient_id: number | null
    dependent_id: number | null
    doctor_id: number | null
    symptoms: string | null
    type: string | null
    med_name: string | null
    mg: string | null
    dose: string | null
    num_days: string | null
    instruction: string | null
    advice: string | null
    created_on: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    prescription_id: number
    prescription_num: number
    patient_id: number
    dependent_id: number
    doctor_id: number
    symptoms: number
    type: number
    med_name: number
    mg: number
    dose: number
    num_days: number
    instruction: number
    advice: number
    created_on: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    prescription_id?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
  }

  export type PrescriptionSumAggregateInputType = {
    prescription_id?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
  }

  export type PrescriptionMinAggregateInputType = {
    prescription_id?: true
    prescription_num?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    symptoms?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    created_on?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    prescription_id?: true
    prescription_num?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    symptoms?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    created_on?: true
  }

  export type PrescriptionCountAggregateInputType = {
    prescription_id?: true
    prescription_num?: true
    patient_id?: true
    dependent_id?: true
    doctor_id?: true
    symptoms?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    created_on?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescription to aggregate.
     */
    where?: prescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionOrderByWithRelationInput | prescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type prescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prescriptionWhereInput
    orderBy?: prescriptionOrderByWithAggregationInput | prescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: prescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    prescription_id: number
    prescription_num: string
    patient_id: number
    dependent_id: number
    doctor_id: number | null
    symptoms: string | null
    type: string | null
    med_name: string | null
    mg: string | null
    dose: string | null
    num_days: string | null
    instruction: string
    advice: string | null
    created_on: Date | null
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends prescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type prescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prescription_id?: boolean
    prescription_num?: boolean
    patient_id?: boolean
    dependent_id?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    type?: boolean
    med_name?: boolean
    mg?: boolean
    dose?: boolean
    num_days?: boolean
    instruction?: boolean
    advice?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["prescription"]>


  export type prescriptionSelectScalar = {
    prescription_id?: boolean
    prescription_num?: boolean
    patient_id?: boolean
    dependent_id?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    type?: boolean
    med_name?: boolean
    mg?: boolean
    dose?: boolean
    num_days?: boolean
    instruction?: boolean
    advice?: boolean
    created_on?: boolean
  }


  export type $prescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prescription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      prescription_id: number
      prescription_num: string
      patient_id: number
      dependent_id: number
      doctor_id: number | null
      symptoms: string | null
      type: string | null
      med_name: string | null
      mg: string | null
      dose: string | null
      num_days: string | null
      instruction: string
      advice: string | null
      created_on: Date | null
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type prescriptionGetPayload<S extends boolean | null | undefined | prescriptionDefaultArgs> = $Result.GetResult<Prisma.$prescriptionPayload, S>

  type prescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prescriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface prescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prescription'], meta: { name: 'prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {prescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prescriptionFindUniqueArgs>(args: SelectSubset<T, prescriptionFindUniqueArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, prescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prescriptionFindFirstArgs>(args?: SelectSubset<T, prescriptionFindFirstArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, prescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `prescription_id`
     * const prescriptionWithPrescription_idOnly = await prisma.prescription.findMany({ select: { prescription_id: true } })
     * 
     */
    findMany<T extends prescriptionFindManyArgs>(args?: SelectSubset<T, prescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prescription.
     * @param {prescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends prescriptionCreateArgs>(args: SelectSubset<T, prescriptionCreateArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prescriptions.
     * @param {prescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prescriptionCreateManyArgs>(args?: SelectSubset<T, prescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prescription.
     * @param {prescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends prescriptionDeleteArgs>(args: SelectSubset<T, prescriptionDeleteArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {prescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prescriptionUpdateArgs>(args: SelectSubset<T, prescriptionUpdateArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {prescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prescriptionDeleteManyArgs>(args?: SelectSubset<T, prescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prescriptionUpdateManyArgs>(args: SelectSubset<T, prescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {prescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends prescriptionUpsertArgs>(args: SelectSubset<T, prescriptionUpsertArgs<ExtArgs>>): Prisma__prescriptionClient<$Result.GetResult<Prisma.$prescriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends prescriptionCountArgs>(
      args?: Subset<T, prescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prescriptionGroupByArgs['orderBy'] }
        : { orderBy?: prescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prescription model
   */
  readonly fields: prescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prescription model
   */ 
  interface prescriptionFieldRefs {
    readonly prescription_id: FieldRef<"prescription", 'Int'>
    readonly prescription_num: FieldRef<"prescription", 'String'>
    readonly patient_id: FieldRef<"prescription", 'Int'>
    readonly dependent_id: FieldRef<"prescription", 'Int'>
    readonly doctor_id: FieldRef<"prescription", 'Int'>
    readonly symptoms: FieldRef<"prescription", 'String'>
    readonly type: FieldRef<"prescription", 'String'>
    readonly med_name: FieldRef<"prescription", 'String'>
    readonly mg: FieldRef<"prescription", 'String'>
    readonly dose: FieldRef<"prescription", 'String'>
    readonly num_days: FieldRef<"prescription", 'String'>
    readonly instruction: FieldRef<"prescription", 'String'>
    readonly advice: FieldRef<"prescription", 'String'>
    readonly created_on: FieldRef<"prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prescription findUnique
   */
  export type prescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter, which prescription to fetch.
     */
    where: prescriptionWhereUniqueInput
  }

  /**
   * prescription findUniqueOrThrow
   */
  export type prescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter, which prescription to fetch.
     */
    where: prescriptionWhereUniqueInput
  }

  /**
   * prescription findFirst
   */
  export type prescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter, which prescription to fetch.
     */
    where?: prescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionOrderByWithRelationInput | prescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescriptions.
     */
    cursor?: prescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * prescription findFirstOrThrow
   */
  export type prescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter, which prescription to fetch.
     */
    where?: prescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionOrderByWithRelationInput | prescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescriptions.
     */
    cursor?: prescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * prescription findMany
   */
  export type prescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where?: prescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionOrderByWithRelationInput | prescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prescriptions.
     */
    cursor?: prescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * prescription create
   */
  export type prescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * The data needed to create a prescription.
     */
    data: XOR<prescriptionCreateInput, prescriptionUncheckedCreateInput>
  }

  /**
   * prescription createMany
   */
  export type prescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prescriptions.
     */
    data: prescriptionCreateManyInput | prescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prescription update
   */
  export type prescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * The data needed to update a prescription.
     */
    data: XOR<prescriptionUpdateInput, prescriptionUncheckedUpdateInput>
    /**
     * Choose, which prescription to update.
     */
    where: prescriptionWhereUniqueInput
  }

  /**
   * prescription updateMany
   */
  export type prescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prescriptions.
     */
    data: XOR<prescriptionUpdateManyMutationInput, prescriptionUncheckedUpdateManyInput>
    /**
     * Filter which prescriptions to update
     */
    where?: prescriptionWhereInput
  }

  /**
   * prescription upsert
   */
  export type prescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * The filter to search for the prescription to update in case it exists.
     */
    where: prescriptionWhereUniqueInput
    /**
     * In case the prescription found by the `where` argument doesn't exist, create a new prescription with this data.
     */
    create: XOR<prescriptionCreateInput, prescriptionUncheckedCreateInput>
    /**
     * In case the prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prescriptionUpdateInput, prescriptionUncheckedUpdateInput>
  }

  /**
   * prescription delete
   */
  export type prescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
    /**
     * Filter which prescription to delete.
     */
    where: prescriptionWhereUniqueInput
  }

  /**
   * prescription deleteMany
   */
  export type prescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescriptions to delete
     */
    where?: prescriptionWhereInput
  }

  /**
   * prescription without action
   */
  export type prescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription
     */
    select?: prescriptionSelect<ExtArgs> | null
  }


  /**
   * Model prescription_medicine
   */

  export type AggregatePrescription_medicine = {
    _count: Prescription_medicineCountAggregateOutputType | null
    _avg: Prescription_medicineAvgAggregateOutputType | null
    _sum: Prescription_medicineSumAggregateOutputType | null
    _min: Prescription_medicineMinAggregateOutputType | null
    _max: Prescription_medicineMaxAggregateOutputType | null
  }

  export type Prescription_medicineAvgAggregateOutputType = {
    medicine_id: number | null
    prescription_id: number | null
  }

  export type Prescription_medicineSumAggregateOutputType = {
    medicine_id: number | null
    prescription_id: number | null
  }

  export type Prescription_medicineMinAggregateOutputType = {
    medicine_id: number | null
    type: string | null
    med_name: string | null
    mg: string | null
    dose: string | null
    num_days: string | null
    instruction: string | null
    advice: string | null
    prescription_id: number | null
  }

  export type Prescription_medicineMaxAggregateOutputType = {
    medicine_id: number | null
    type: string | null
    med_name: string | null
    mg: string | null
    dose: string | null
    num_days: string | null
    instruction: string | null
    advice: string | null
    prescription_id: number | null
  }

  export type Prescription_medicineCountAggregateOutputType = {
    medicine_id: number
    type: number
    med_name: number
    mg: number
    dose: number
    num_days: number
    instruction: number
    advice: number
    prescription_id: number
    _all: number
  }


  export type Prescription_medicineAvgAggregateInputType = {
    medicine_id?: true
    prescription_id?: true
  }

  export type Prescription_medicineSumAggregateInputType = {
    medicine_id?: true
    prescription_id?: true
  }

  export type Prescription_medicineMinAggregateInputType = {
    medicine_id?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    prescription_id?: true
  }

  export type Prescription_medicineMaxAggregateInputType = {
    medicine_id?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    prescription_id?: true
  }

  export type Prescription_medicineCountAggregateInputType = {
    medicine_id?: true
    type?: true
    med_name?: true
    mg?: true
    dose?: true
    num_days?: true
    instruction?: true
    advice?: true
    prescription_id?: true
    _all?: true
  }

  export type Prescription_medicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescription_medicine to aggregate.
     */
    where?: prescription_medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescription_medicines to fetch.
     */
    orderBy?: prescription_medicineOrderByWithRelationInput | prescription_medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prescription_medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescription_medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescription_medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prescription_medicines
    **/
    _count?: true | Prescription_medicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prescription_medicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prescription_medicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prescription_medicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prescription_medicineMaxAggregateInputType
  }

  export type GetPrescription_medicineAggregateType<T extends Prescription_medicineAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription_medicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription_medicine[P]>
      : GetScalarType<T[P], AggregatePrescription_medicine[P]>
  }




  export type prescription_medicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prescription_medicineWhereInput
    orderBy?: prescription_medicineOrderByWithAggregationInput | prescription_medicineOrderByWithAggregationInput[]
    by: Prescription_medicineScalarFieldEnum[] | Prescription_medicineScalarFieldEnum
    having?: prescription_medicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prescription_medicineCountAggregateInputType | true
    _avg?: Prescription_medicineAvgAggregateInputType
    _sum?: Prescription_medicineSumAggregateInputType
    _min?: Prescription_medicineMinAggregateInputType
    _max?: Prescription_medicineMaxAggregateInputType
  }

  export type Prescription_medicineGroupByOutputType = {
    medicine_id: number
    type: string | null
    med_name: string | null
    mg: string
    dose: string
    num_days: string
    instruction: string
    advice: string
    prescription_id: number | null
    _count: Prescription_medicineCountAggregateOutputType | null
    _avg: Prescription_medicineAvgAggregateOutputType | null
    _sum: Prescription_medicineSumAggregateOutputType | null
    _min: Prescription_medicineMinAggregateOutputType | null
    _max: Prescription_medicineMaxAggregateOutputType | null
  }

  type GetPrescription_medicineGroupByPayload<T extends prescription_medicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prescription_medicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prescription_medicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prescription_medicineGroupByOutputType[P]>
            : GetScalarType<T[P], Prescription_medicineGroupByOutputType[P]>
        }
      >
    >


  export type prescription_medicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    medicine_id?: boolean
    type?: boolean
    med_name?: boolean
    mg?: boolean
    dose?: boolean
    num_days?: boolean
    instruction?: boolean
    advice?: boolean
    prescription_id?: boolean
  }, ExtArgs["result"]["prescription_medicine"]>


  export type prescription_medicineSelectScalar = {
    medicine_id?: boolean
    type?: boolean
    med_name?: boolean
    mg?: boolean
    dose?: boolean
    num_days?: boolean
    instruction?: boolean
    advice?: boolean
    prescription_id?: boolean
  }


  export type $prescription_medicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prescription_medicine"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      medicine_id: number
      type: string | null
      med_name: string | null
      mg: string
      dose: string
      num_days: string
      instruction: string
      advice: string
      prescription_id: number | null
    }, ExtArgs["result"]["prescription_medicine"]>
    composites: {}
  }

  type prescription_medicineGetPayload<S extends boolean | null | undefined | prescription_medicineDefaultArgs> = $Result.GetResult<Prisma.$prescription_medicinePayload, S>

  type prescription_medicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prescription_medicineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Prescription_medicineCountAggregateInputType | true
    }

  export interface prescription_medicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prescription_medicine'], meta: { name: 'prescription_medicine' } }
    /**
     * Find zero or one Prescription_medicine that matches the filter.
     * @param {prescription_medicineFindUniqueArgs} args - Arguments to find a Prescription_medicine
     * @example
     * // Get one Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prescription_medicineFindUniqueArgs>(args: SelectSubset<T, prescription_medicineFindUniqueArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prescription_medicine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prescription_medicineFindUniqueOrThrowArgs} args - Arguments to find a Prescription_medicine
     * @example
     * // Get one Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prescription_medicineFindUniqueOrThrowArgs>(args: SelectSubset<T, prescription_medicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prescription_medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineFindFirstArgs} args - Arguments to find a Prescription_medicine
     * @example
     * // Get one Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prescription_medicineFindFirstArgs>(args?: SelectSubset<T, prescription_medicineFindFirstArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prescription_medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineFindFirstOrThrowArgs} args - Arguments to find a Prescription_medicine
     * @example
     * // Get one Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prescription_medicineFindFirstOrThrowArgs>(args?: SelectSubset<T, prescription_medicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prescription_medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescription_medicines
     * const prescription_medicines = await prisma.prescription_medicine.findMany()
     * 
     * // Get first 10 Prescription_medicines
     * const prescription_medicines = await prisma.prescription_medicine.findMany({ take: 10 })
     * 
     * // Only select the `medicine_id`
     * const prescription_medicineWithMedicine_idOnly = await prisma.prescription_medicine.findMany({ select: { medicine_id: true } })
     * 
     */
    findMany<T extends prescription_medicineFindManyArgs>(args?: SelectSubset<T, prescription_medicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prescription_medicine.
     * @param {prescription_medicineCreateArgs} args - Arguments to create a Prescription_medicine.
     * @example
     * // Create one Prescription_medicine
     * const Prescription_medicine = await prisma.prescription_medicine.create({
     *   data: {
     *     // ... data to create a Prescription_medicine
     *   }
     * })
     * 
     */
    create<T extends prescription_medicineCreateArgs>(args: SelectSubset<T, prescription_medicineCreateArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prescription_medicines.
     * @param {prescription_medicineCreateManyArgs} args - Arguments to create many Prescription_medicines.
     * @example
     * // Create many Prescription_medicines
     * const prescription_medicine = await prisma.prescription_medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prescription_medicineCreateManyArgs>(args?: SelectSubset<T, prescription_medicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prescription_medicine.
     * @param {prescription_medicineDeleteArgs} args - Arguments to delete one Prescription_medicine.
     * @example
     * // Delete one Prescription_medicine
     * const Prescription_medicine = await prisma.prescription_medicine.delete({
     *   where: {
     *     // ... filter to delete one Prescription_medicine
     *   }
     * })
     * 
     */
    delete<T extends prescription_medicineDeleteArgs>(args: SelectSubset<T, prescription_medicineDeleteArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prescription_medicine.
     * @param {prescription_medicineUpdateArgs} args - Arguments to update one Prescription_medicine.
     * @example
     * // Update one Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prescription_medicineUpdateArgs>(args: SelectSubset<T, prescription_medicineUpdateArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prescription_medicines.
     * @param {prescription_medicineDeleteManyArgs} args - Arguments to filter Prescription_medicines to delete.
     * @example
     * // Delete a few Prescription_medicines
     * const { count } = await prisma.prescription_medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prescription_medicineDeleteManyArgs>(args?: SelectSubset<T, prescription_medicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescription_medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescription_medicines
     * const prescription_medicine = await prisma.prescription_medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prescription_medicineUpdateManyArgs>(args: SelectSubset<T, prescription_medicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription_medicine.
     * @param {prescription_medicineUpsertArgs} args - Arguments to update or create a Prescription_medicine.
     * @example
     * // Update or create a Prescription_medicine
     * const prescription_medicine = await prisma.prescription_medicine.upsert({
     *   create: {
     *     // ... data to create a Prescription_medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription_medicine we want to update
     *   }
     * })
     */
    upsert<T extends prescription_medicineUpsertArgs>(args: SelectSubset<T, prescription_medicineUpsertArgs<ExtArgs>>): Prisma__prescription_medicineClient<$Result.GetResult<Prisma.$prescription_medicinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prescription_medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineCountArgs} args - Arguments to filter Prescription_medicines to count.
     * @example
     * // Count the number of Prescription_medicines
     * const count = await prisma.prescription_medicine.count({
     *   where: {
     *     // ... the filter for the Prescription_medicines we want to count
     *   }
     * })
    **/
    count<T extends prescription_medicineCountArgs>(
      args?: Subset<T, prescription_medicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prescription_medicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription_medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prescription_medicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prescription_medicineAggregateArgs>(args: Subset<T, Prescription_medicineAggregateArgs>): Prisma.PrismaPromise<GetPrescription_medicineAggregateType<T>>

    /**
     * Group by Prescription_medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescription_medicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prescription_medicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prescription_medicineGroupByArgs['orderBy'] }
        : { orderBy?: prescription_medicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prescription_medicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescription_medicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prescription_medicine model
   */
  readonly fields: prescription_medicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prescription_medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prescription_medicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prescription_medicine model
   */ 
  interface prescription_medicineFieldRefs {
    readonly medicine_id: FieldRef<"prescription_medicine", 'Int'>
    readonly type: FieldRef<"prescription_medicine", 'String'>
    readonly med_name: FieldRef<"prescription_medicine", 'String'>
    readonly mg: FieldRef<"prescription_medicine", 'String'>
    readonly dose: FieldRef<"prescription_medicine", 'String'>
    readonly num_days: FieldRef<"prescription_medicine", 'String'>
    readonly instruction: FieldRef<"prescription_medicine", 'String'>
    readonly advice: FieldRef<"prescription_medicine", 'String'>
    readonly prescription_id: FieldRef<"prescription_medicine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * prescription_medicine findUnique
   */
  export type prescription_medicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter, which prescription_medicine to fetch.
     */
    where: prescription_medicineWhereUniqueInput
  }

  /**
   * prescription_medicine findUniqueOrThrow
   */
  export type prescription_medicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter, which prescription_medicine to fetch.
     */
    where: prescription_medicineWhereUniqueInput
  }

  /**
   * prescription_medicine findFirst
   */
  export type prescription_medicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter, which prescription_medicine to fetch.
     */
    where?: prescription_medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescription_medicines to fetch.
     */
    orderBy?: prescription_medicineOrderByWithRelationInput | prescription_medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescription_medicines.
     */
    cursor?: prescription_medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescription_medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescription_medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescription_medicines.
     */
    distinct?: Prescription_medicineScalarFieldEnum | Prescription_medicineScalarFieldEnum[]
  }

  /**
   * prescription_medicine findFirstOrThrow
   */
  export type prescription_medicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter, which prescription_medicine to fetch.
     */
    where?: prescription_medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescription_medicines to fetch.
     */
    orderBy?: prescription_medicineOrderByWithRelationInput | prescription_medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescription_medicines.
     */
    cursor?: prescription_medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescription_medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescription_medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescription_medicines.
     */
    distinct?: Prescription_medicineScalarFieldEnum | Prescription_medicineScalarFieldEnum[]
  }

  /**
   * prescription_medicine findMany
   */
  export type prescription_medicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter, which prescription_medicines to fetch.
     */
    where?: prescription_medicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescription_medicines to fetch.
     */
    orderBy?: prescription_medicineOrderByWithRelationInput | prescription_medicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prescription_medicines.
     */
    cursor?: prescription_medicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescription_medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescription_medicines.
     */
    skip?: number
    distinct?: Prescription_medicineScalarFieldEnum | Prescription_medicineScalarFieldEnum[]
  }

  /**
   * prescription_medicine create
   */
  export type prescription_medicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * The data needed to create a prescription_medicine.
     */
    data: XOR<prescription_medicineCreateInput, prescription_medicineUncheckedCreateInput>
  }

  /**
   * prescription_medicine createMany
   */
  export type prescription_medicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prescription_medicines.
     */
    data: prescription_medicineCreateManyInput | prescription_medicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prescription_medicine update
   */
  export type prescription_medicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * The data needed to update a prescription_medicine.
     */
    data: XOR<prescription_medicineUpdateInput, prescription_medicineUncheckedUpdateInput>
    /**
     * Choose, which prescription_medicine to update.
     */
    where: prescription_medicineWhereUniqueInput
  }

  /**
   * prescription_medicine updateMany
   */
  export type prescription_medicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prescription_medicines.
     */
    data: XOR<prescription_medicineUpdateManyMutationInput, prescription_medicineUncheckedUpdateManyInput>
    /**
     * Filter which prescription_medicines to update
     */
    where?: prescription_medicineWhereInput
  }

  /**
   * prescription_medicine upsert
   */
  export type prescription_medicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * The filter to search for the prescription_medicine to update in case it exists.
     */
    where: prescription_medicineWhereUniqueInput
    /**
     * In case the prescription_medicine found by the `where` argument doesn't exist, create a new prescription_medicine with this data.
     */
    create: XOR<prescription_medicineCreateInput, prescription_medicineUncheckedCreateInput>
    /**
     * In case the prescription_medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prescription_medicineUpdateInput, prescription_medicineUncheckedUpdateInput>
  }

  /**
   * prescription_medicine delete
   */
  export type prescription_medicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
    /**
     * Filter which prescription_medicine to delete.
     */
    where: prescription_medicineWhereUniqueInput
  }

  /**
   * prescription_medicine deleteMany
   */
  export type prescription_medicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescription_medicines to delete
     */
    where?: prescription_medicineWhereInput
  }

  /**
   * prescription_medicine without action
   */
  export type prescription_medicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescription_medicine
     */
    select?: prescription_medicineSelect<ExtArgs> | null
  }


  /**
   * Model qualification
   */

  export type AggregateQualification = {
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  export type QualificationAvgAggregateOutputType = {
    qualification_id: number | null
    is_active: number | null
  }

  export type QualificationSumAggregateOutputType = {
    qualification_id: number | null
    is_active: number | null
  }

  export type QualificationMinAggregateOutputType = {
    qualification_id: number | null
    qualification_name: string | null
    is_active: number | null
  }

  export type QualificationMaxAggregateOutputType = {
    qualification_id: number | null
    qualification_name: string | null
    is_active: number | null
  }

  export type QualificationCountAggregateOutputType = {
    qualification_id: number
    qualification_name: number
    is_active: number
    _all: number
  }


  export type QualificationAvgAggregateInputType = {
    qualification_id?: true
    is_active?: true
  }

  export type QualificationSumAggregateInputType = {
    qualification_id?: true
    is_active?: true
  }

  export type QualificationMinAggregateInputType = {
    qualification_id?: true
    qualification_name?: true
    is_active?: true
  }

  export type QualificationMaxAggregateInputType = {
    qualification_id?: true
    qualification_name?: true
    is_active?: true
  }

  export type QualificationCountAggregateInputType = {
    qualification_id?: true
    qualification_name?: true
    is_active?: true
    _all?: true
  }

  export type QualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualification to aggregate.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: qualificationOrderByWithRelationInput | qualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qualifications
    **/
    _count?: true | QualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualificationMaxAggregateInputType
  }

  export type GetQualificationAggregateType<T extends QualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualification[P]>
      : GetScalarType<T[P], AggregateQualification[P]>
  }




  export type qualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qualificationWhereInput
    orderBy?: qualificationOrderByWithAggregationInput | qualificationOrderByWithAggregationInput[]
    by: QualificationScalarFieldEnum[] | QualificationScalarFieldEnum
    having?: qualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualificationCountAggregateInputType | true
    _avg?: QualificationAvgAggregateInputType
    _sum?: QualificationSumAggregateInputType
    _min?: QualificationMinAggregateInputType
    _max?: QualificationMaxAggregateInputType
  }

  export type QualificationGroupByOutputType = {
    qualification_id: number
    qualification_name: string
    is_active: number
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  type GetQualificationGroupByPayload<T extends qualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualificationGroupByOutputType[P]>
            : GetScalarType<T[P], QualificationGroupByOutputType[P]>
        }
      >
    >


  export type qualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    qualification_id?: boolean
    qualification_name?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["qualification"]>


  export type qualificationSelectScalar = {
    qualification_id?: boolean
    qualification_name?: boolean
    is_active?: boolean
  }


  export type $qualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qualification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      qualification_id: number
      qualification_name: string
      is_active: number
    }, ExtArgs["result"]["qualification"]>
    composites: {}
  }

  type qualificationGetPayload<S extends boolean | null | undefined | qualificationDefaultArgs> = $Result.GetResult<Prisma.$qualificationPayload, S>

  type qualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<qualificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QualificationCountAggregateInputType | true
    }

  export interface qualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qualification'], meta: { name: 'qualification' } }
    /**
     * Find zero or one Qualification that matches the filter.
     * @param {qualificationFindUniqueArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qualificationFindUniqueArgs>(args: SelectSubset<T, qualificationFindUniqueArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Qualification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {qualificationFindUniqueOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, qualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Qualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindFirstArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qualificationFindFirstArgs>(args?: SelectSubset<T, qualificationFindFirstArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Qualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindFirstOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, qualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Qualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualifications
     * const qualifications = await prisma.qualification.findMany()
     * 
     * // Get first 10 Qualifications
     * const qualifications = await prisma.qualification.findMany({ take: 10 })
     * 
     * // Only select the `qualification_id`
     * const qualificationWithQualification_idOnly = await prisma.qualification.findMany({ select: { qualification_id: true } })
     * 
     */
    findMany<T extends qualificationFindManyArgs>(args?: SelectSubset<T, qualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Qualification.
     * @param {qualificationCreateArgs} args - Arguments to create a Qualification.
     * @example
     * // Create one Qualification
     * const Qualification = await prisma.qualification.create({
     *   data: {
     *     // ... data to create a Qualification
     *   }
     * })
     * 
     */
    create<T extends qualificationCreateArgs>(args: SelectSubset<T, qualificationCreateArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Qualifications.
     * @param {qualificationCreateManyArgs} args - Arguments to create many Qualifications.
     * @example
     * // Create many Qualifications
     * const qualification = await prisma.qualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qualificationCreateManyArgs>(args?: SelectSubset<T, qualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qualification.
     * @param {qualificationDeleteArgs} args - Arguments to delete one Qualification.
     * @example
     * // Delete one Qualification
     * const Qualification = await prisma.qualification.delete({
     *   where: {
     *     // ... filter to delete one Qualification
     *   }
     * })
     * 
     */
    delete<T extends qualificationDeleteArgs>(args: SelectSubset<T, qualificationDeleteArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Qualification.
     * @param {qualificationUpdateArgs} args - Arguments to update one Qualification.
     * @example
     * // Update one Qualification
     * const qualification = await prisma.qualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qualificationUpdateArgs>(args: SelectSubset<T, qualificationUpdateArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Qualifications.
     * @param {qualificationDeleteManyArgs} args - Arguments to filter Qualifications to delete.
     * @example
     * // Delete a few Qualifications
     * const { count } = await prisma.qualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qualificationDeleteManyArgs>(args?: SelectSubset<T, qualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualifications
     * const qualification = await prisma.qualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qualificationUpdateManyArgs>(args: SelectSubset<T, qualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qualification.
     * @param {qualificationUpsertArgs} args - Arguments to update or create a Qualification.
     * @example
     * // Update or create a Qualification
     * const qualification = await prisma.qualification.upsert({
     *   create: {
     *     // ... data to create a Qualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualification we want to update
     *   }
     * })
     */
    upsert<T extends qualificationUpsertArgs>(args: SelectSubset<T, qualificationUpsertArgs<ExtArgs>>): Prisma__qualificationClient<$Result.GetResult<Prisma.$qualificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationCountArgs} args - Arguments to filter Qualifications to count.
     * @example
     * // Count the number of Qualifications
     * const count = await prisma.qualification.count({
     *   where: {
     *     // ... the filter for the Qualifications we want to count
     *   }
     * })
    **/
    count<T extends qualificationCountArgs>(
      args?: Subset<T, qualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualificationAggregateArgs>(args: Subset<T, QualificationAggregateArgs>): Prisma.PrismaPromise<GetQualificationAggregateType<T>>

    /**
     * Group by Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qualificationGroupByArgs['orderBy'] }
        : { orderBy?: qualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qualification model
   */
  readonly fields: qualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qualification model
   */ 
  interface qualificationFieldRefs {
    readonly qualification_id: FieldRef<"qualification", 'Int'>
    readonly qualification_name: FieldRef<"qualification", 'String'>
    readonly is_active: FieldRef<"qualification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * qualification findUnique
   */
  export type qualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter, which qualification to fetch.
     */
    where: qualificationWhereUniqueInput
  }

  /**
   * qualification findUniqueOrThrow
   */
  export type qualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter, which qualification to fetch.
     */
    where: qualificationWhereUniqueInput
  }

  /**
   * qualification findFirst
   */
  export type qualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter, which qualification to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: qualificationOrderByWithRelationInput | qualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualifications.
     */
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * qualification findFirstOrThrow
   */
  export type qualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter, which qualification to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: qualificationOrderByWithRelationInput | qualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualifications.
     */
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * qualification findMany
   */
  export type qualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter, which qualifications to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: qualificationOrderByWithRelationInput | qualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * qualification create
   */
  export type qualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * The data needed to create a qualification.
     */
    data: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
  }

  /**
   * qualification createMany
   */
  export type qualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qualifications.
     */
    data: qualificationCreateManyInput | qualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qualification update
   */
  export type qualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * The data needed to update a qualification.
     */
    data: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
    /**
     * Choose, which qualification to update.
     */
    where: qualificationWhereUniqueInput
  }

  /**
   * qualification updateMany
   */
  export type qualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qualifications.
     */
    data: XOR<qualificationUpdateManyMutationInput, qualificationUncheckedUpdateManyInput>
    /**
     * Filter which qualifications to update
     */
    where?: qualificationWhereInput
  }

  /**
   * qualification upsert
   */
  export type qualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * The filter to search for the qualification to update in case it exists.
     */
    where: qualificationWhereUniqueInput
    /**
     * In case the qualification found by the `where` argument doesn't exist, create a new qualification with this data.
     */
    create: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
    /**
     * In case the qualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
  }

  /**
   * qualification delete
   */
  export type qualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
    /**
     * Filter which qualification to delete.
     */
    where: qualificationWhereUniqueInput
  }

  /**
   * qualification deleteMany
   */
  export type qualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualifications to delete
     */
    where?: qualificationWhereInput
  }

  /**
   * qualification without action
   */
  export type qualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect<ExtArgs> | null
  }


  /**
   * Model qualification_mapping
   */

  export type AggregateQualification_mapping = {
    _count: Qualification_mappingCountAggregateOutputType | null
    _avg: Qualification_mappingAvgAggregateOutputType | null
    _sum: Qualification_mappingSumAggregateOutputType | null
    _min: Qualification_mappingMinAggregateOutputType | null
    _max: Qualification_mappingMaxAggregateOutputType | null
  }

  export type Qualification_mappingAvgAggregateOutputType = {
    qualification_mapping_id: number | null
    qualification_id: number | null
    physician_id: number | null
  }

  export type Qualification_mappingSumAggregateOutputType = {
    qualification_mapping_id: number | null
    qualification_id: number | null
    physician_id: number | null
  }

  export type Qualification_mappingMinAggregateOutputType = {
    qualification_mapping_id: number | null
    qualification_id: number | null
    physician_id: number | null
  }

  export type Qualification_mappingMaxAggregateOutputType = {
    qualification_mapping_id: number | null
    qualification_id: number | null
    physician_id: number | null
  }

  export type Qualification_mappingCountAggregateOutputType = {
    qualification_mapping_id: number
    qualification_id: number
    physician_id: number
    _all: number
  }


  export type Qualification_mappingAvgAggregateInputType = {
    qualification_mapping_id?: true
    qualification_id?: true
    physician_id?: true
  }

  export type Qualification_mappingSumAggregateInputType = {
    qualification_mapping_id?: true
    qualification_id?: true
    physician_id?: true
  }

  export type Qualification_mappingMinAggregateInputType = {
    qualification_mapping_id?: true
    qualification_id?: true
    physician_id?: true
  }

  export type Qualification_mappingMaxAggregateInputType = {
    qualification_mapping_id?: true
    qualification_id?: true
    physician_id?: true
  }

  export type Qualification_mappingCountAggregateInputType = {
    qualification_mapping_id?: true
    qualification_id?: true
    physician_id?: true
    _all?: true
  }

  export type Qualification_mappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualification_mapping to aggregate.
     */
    where?: qualification_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualification_mappings to fetch.
     */
    orderBy?: qualification_mappingOrderByWithRelationInput | qualification_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qualification_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualification_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualification_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qualification_mappings
    **/
    _count?: true | Qualification_mappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qualification_mappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qualification_mappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qualification_mappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qualification_mappingMaxAggregateInputType
  }

  export type GetQualification_mappingAggregateType<T extends Qualification_mappingAggregateArgs> = {
        [P in keyof T & keyof AggregateQualification_mapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualification_mapping[P]>
      : GetScalarType<T[P], AggregateQualification_mapping[P]>
  }




  export type qualification_mappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qualification_mappingWhereInput
    orderBy?: qualification_mappingOrderByWithAggregationInput | qualification_mappingOrderByWithAggregationInput[]
    by: Qualification_mappingScalarFieldEnum[] | Qualification_mappingScalarFieldEnum
    having?: qualification_mappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qualification_mappingCountAggregateInputType | true
    _avg?: Qualification_mappingAvgAggregateInputType
    _sum?: Qualification_mappingSumAggregateInputType
    _min?: Qualification_mappingMinAggregateInputType
    _max?: Qualification_mappingMaxAggregateInputType
  }

  export type Qualification_mappingGroupByOutputType = {
    qualification_mapping_id: number
    qualification_id: number
    physician_id: number
    _count: Qualification_mappingCountAggregateOutputType | null
    _avg: Qualification_mappingAvgAggregateOutputType | null
    _sum: Qualification_mappingSumAggregateOutputType | null
    _min: Qualification_mappingMinAggregateOutputType | null
    _max: Qualification_mappingMaxAggregateOutputType | null
  }

  type GetQualification_mappingGroupByPayload<T extends qualification_mappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qualification_mappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qualification_mappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qualification_mappingGroupByOutputType[P]>
            : GetScalarType<T[P], Qualification_mappingGroupByOutputType[P]>
        }
      >
    >


  export type qualification_mappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    qualification_mapping_id?: boolean
    qualification_id?: boolean
    physician_id?: boolean
  }, ExtArgs["result"]["qualification_mapping"]>


  export type qualification_mappingSelectScalar = {
    qualification_mapping_id?: boolean
    qualification_id?: boolean
    physician_id?: boolean
  }


  export type $qualification_mappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qualification_mapping"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      qualification_mapping_id: number
      qualification_id: number
      physician_id: number
    }, ExtArgs["result"]["qualification_mapping"]>
    composites: {}
  }

  type qualification_mappingGetPayload<S extends boolean | null | undefined | qualification_mappingDefaultArgs> = $Result.GetResult<Prisma.$qualification_mappingPayload, S>

  type qualification_mappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<qualification_mappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Qualification_mappingCountAggregateInputType | true
    }

  export interface qualification_mappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qualification_mapping'], meta: { name: 'qualification_mapping' } }
    /**
     * Find zero or one Qualification_mapping that matches the filter.
     * @param {qualification_mappingFindUniqueArgs} args - Arguments to find a Qualification_mapping
     * @example
     * // Get one Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qualification_mappingFindUniqueArgs>(args: SelectSubset<T, qualification_mappingFindUniqueArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Qualification_mapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {qualification_mappingFindUniqueOrThrowArgs} args - Arguments to find a Qualification_mapping
     * @example
     * // Get one Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qualification_mappingFindUniqueOrThrowArgs>(args: SelectSubset<T, qualification_mappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Qualification_mapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingFindFirstArgs} args - Arguments to find a Qualification_mapping
     * @example
     * // Get one Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qualification_mappingFindFirstArgs>(args?: SelectSubset<T, qualification_mappingFindFirstArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Qualification_mapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingFindFirstOrThrowArgs} args - Arguments to find a Qualification_mapping
     * @example
     * // Get one Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qualification_mappingFindFirstOrThrowArgs>(args?: SelectSubset<T, qualification_mappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Qualification_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualification_mappings
     * const qualification_mappings = await prisma.qualification_mapping.findMany()
     * 
     * // Get first 10 Qualification_mappings
     * const qualification_mappings = await prisma.qualification_mapping.findMany({ take: 10 })
     * 
     * // Only select the `qualification_mapping_id`
     * const qualification_mappingWithQualification_mapping_idOnly = await prisma.qualification_mapping.findMany({ select: { qualification_mapping_id: true } })
     * 
     */
    findMany<T extends qualification_mappingFindManyArgs>(args?: SelectSubset<T, qualification_mappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Qualification_mapping.
     * @param {qualification_mappingCreateArgs} args - Arguments to create a Qualification_mapping.
     * @example
     * // Create one Qualification_mapping
     * const Qualification_mapping = await prisma.qualification_mapping.create({
     *   data: {
     *     // ... data to create a Qualification_mapping
     *   }
     * })
     * 
     */
    create<T extends qualification_mappingCreateArgs>(args: SelectSubset<T, qualification_mappingCreateArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Qualification_mappings.
     * @param {qualification_mappingCreateManyArgs} args - Arguments to create many Qualification_mappings.
     * @example
     * // Create many Qualification_mappings
     * const qualification_mapping = await prisma.qualification_mapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qualification_mappingCreateManyArgs>(args?: SelectSubset<T, qualification_mappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qualification_mapping.
     * @param {qualification_mappingDeleteArgs} args - Arguments to delete one Qualification_mapping.
     * @example
     * // Delete one Qualification_mapping
     * const Qualification_mapping = await prisma.qualification_mapping.delete({
     *   where: {
     *     // ... filter to delete one Qualification_mapping
     *   }
     * })
     * 
     */
    delete<T extends qualification_mappingDeleteArgs>(args: SelectSubset<T, qualification_mappingDeleteArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Qualification_mapping.
     * @param {qualification_mappingUpdateArgs} args - Arguments to update one Qualification_mapping.
     * @example
     * // Update one Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qualification_mappingUpdateArgs>(args: SelectSubset<T, qualification_mappingUpdateArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Qualification_mappings.
     * @param {qualification_mappingDeleteManyArgs} args - Arguments to filter Qualification_mappings to delete.
     * @example
     * // Delete a few Qualification_mappings
     * const { count } = await prisma.qualification_mapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qualification_mappingDeleteManyArgs>(args?: SelectSubset<T, qualification_mappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualification_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualification_mappings
     * const qualification_mapping = await prisma.qualification_mapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qualification_mappingUpdateManyArgs>(args: SelectSubset<T, qualification_mappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qualification_mapping.
     * @param {qualification_mappingUpsertArgs} args - Arguments to update or create a Qualification_mapping.
     * @example
     * // Update or create a Qualification_mapping
     * const qualification_mapping = await prisma.qualification_mapping.upsert({
     *   create: {
     *     // ... data to create a Qualification_mapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualification_mapping we want to update
     *   }
     * })
     */
    upsert<T extends qualification_mappingUpsertArgs>(args: SelectSubset<T, qualification_mappingUpsertArgs<ExtArgs>>): Prisma__qualification_mappingClient<$Result.GetResult<Prisma.$qualification_mappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Qualification_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingCountArgs} args - Arguments to filter Qualification_mappings to count.
     * @example
     * // Count the number of Qualification_mappings
     * const count = await prisma.qualification_mapping.count({
     *   where: {
     *     // ... the filter for the Qualification_mappings we want to count
     *   }
     * })
    **/
    count<T extends qualification_mappingCountArgs>(
      args?: Subset<T, qualification_mappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qualification_mappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualification_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qualification_mappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qualification_mappingAggregateArgs>(args: Subset<T, Qualification_mappingAggregateArgs>): Prisma.PrismaPromise<GetQualification_mappingAggregateType<T>>

    /**
     * Group by Qualification_mapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualification_mappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qualification_mappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qualification_mappingGroupByArgs['orderBy'] }
        : { orderBy?: qualification_mappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qualification_mappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualification_mappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qualification_mapping model
   */
  readonly fields: qualification_mappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qualification_mapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qualification_mappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qualification_mapping model
   */ 
  interface qualification_mappingFieldRefs {
    readonly qualification_mapping_id: FieldRef<"qualification_mapping", 'Int'>
    readonly qualification_id: FieldRef<"qualification_mapping", 'Int'>
    readonly physician_id: FieldRef<"qualification_mapping", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * qualification_mapping findUnique
   */
  export type qualification_mappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter, which qualification_mapping to fetch.
     */
    where: qualification_mappingWhereUniqueInput
  }

  /**
   * qualification_mapping findUniqueOrThrow
   */
  export type qualification_mappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter, which qualification_mapping to fetch.
     */
    where: qualification_mappingWhereUniqueInput
  }

  /**
   * qualification_mapping findFirst
   */
  export type qualification_mappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter, which qualification_mapping to fetch.
     */
    where?: qualification_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualification_mappings to fetch.
     */
    orderBy?: qualification_mappingOrderByWithRelationInput | qualification_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualification_mappings.
     */
    cursor?: qualification_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualification_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualification_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualification_mappings.
     */
    distinct?: Qualification_mappingScalarFieldEnum | Qualification_mappingScalarFieldEnum[]
  }

  /**
   * qualification_mapping findFirstOrThrow
   */
  export type qualification_mappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter, which qualification_mapping to fetch.
     */
    where?: qualification_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualification_mappings to fetch.
     */
    orderBy?: qualification_mappingOrderByWithRelationInput | qualification_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualification_mappings.
     */
    cursor?: qualification_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualification_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualification_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualification_mappings.
     */
    distinct?: Qualification_mappingScalarFieldEnum | Qualification_mappingScalarFieldEnum[]
  }

  /**
   * qualification_mapping findMany
   */
  export type qualification_mappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter, which qualification_mappings to fetch.
     */
    where?: qualification_mappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualification_mappings to fetch.
     */
    orderBy?: qualification_mappingOrderByWithRelationInput | qualification_mappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qualification_mappings.
     */
    cursor?: qualification_mappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualification_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualification_mappings.
     */
    skip?: number
    distinct?: Qualification_mappingScalarFieldEnum | Qualification_mappingScalarFieldEnum[]
  }

  /**
   * qualification_mapping create
   */
  export type qualification_mappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * The data needed to create a qualification_mapping.
     */
    data: XOR<qualification_mappingCreateInput, qualification_mappingUncheckedCreateInput>
  }

  /**
   * qualification_mapping createMany
   */
  export type qualification_mappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qualification_mappings.
     */
    data: qualification_mappingCreateManyInput | qualification_mappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qualification_mapping update
   */
  export type qualification_mappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * The data needed to update a qualification_mapping.
     */
    data: XOR<qualification_mappingUpdateInput, qualification_mappingUncheckedUpdateInput>
    /**
     * Choose, which qualification_mapping to update.
     */
    where: qualification_mappingWhereUniqueInput
  }

  /**
   * qualification_mapping updateMany
   */
  export type qualification_mappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qualification_mappings.
     */
    data: XOR<qualification_mappingUpdateManyMutationInput, qualification_mappingUncheckedUpdateManyInput>
    /**
     * Filter which qualification_mappings to update
     */
    where?: qualification_mappingWhereInput
  }

  /**
   * qualification_mapping upsert
   */
  export type qualification_mappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * The filter to search for the qualification_mapping to update in case it exists.
     */
    where: qualification_mappingWhereUniqueInput
    /**
     * In case the qualification_mapping found by the `where` argument doesn't exist, create a new qualification_mapping with this data.
     */
    create: XOR<qualification_mappingCreateInput, qualification_mappingUncheckedCreateInput>
    /**
     * In case the qualification_mapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qualification_mappingUpdateInput, qualification_mappingUncheckedUpdateInput>
  }

  /**
   * qualification_mapping delete
   */
  export type qualification_mappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
    /**
     * Filter which qualification_mapping to delete.
     */
    where: qualification_mappingWhereUniqueInput
  }

  /**
   * qualification_mapping deleteMany
   */
  export type qualification_mappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualification_mappings to delete
     */
    where?: qualification_mappingWhereInput
  }

  /**
   * qualification_mapping without action
   */
  export type qualification_mappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualification_mapping
     */
    select?: qualification_mappingSelect<ExtArgs> | null
  }


  /**
   * Model referral_confirmation_details
   */

  export type AggregateReferral_confirmation_details = {
    _count: Referral_confirmation_detailsCountAggregateOutputType | null
    _avg: Referral_confirmation_detailsAvgAggregateOutputType | null
    _sum: Referral_confirmation_detailsSumAggregateOutputType | null
    _min: Referral_confirmation_detailsMinAggregateOutputType | null
    _max: Referral_confirmation_detailsMaxAggregateOutputType | null
  }

  export type Referral_confirmation_detailsAvgAggregateOutputType = {
    referred_id: number | null
    referral_pat_id: number | null
    attempts: number | null
    login_id: number | null
    lab_test_status: number | null
    billing_status: number | null
  }

  export type Referral_confirmation_detailsSumAggregateOutputType = {
    referred_id: number | null
    referral_pat_id: number | null
    attempts: number | null
    login_id: number | null
    lab_test_status: number | null
    billing_status: number | null
  }

  export type Referral_confirmation_detailsMinAggregateOutputType = {
    referred_id: number | null
    medical_num: string | null
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number | null
    created_on: Date | null
    ref_type: $Enums.referral_confirmation_details_ref_type | null
    lab_test_status: number | null
    billing_status: number | null
  }

  export type Referral_confirmation_detailsMaxAggregateOutputType = {
    referred_id: number | null
    medical_num: string | null
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number | null
    created_on: Date | null
    ref_type: $Enums.referral_confirmation_details_ref_type | null
    lab_test_status: number | null
    billing_status: number | null
  }

  export type Referral_confirmation_detailsCountAggregateOutputType = {
    referred_id: number
    medical_num: number
    relationship: number
    referral_pat_id: number
    password: number
    patient_unique_id: number
    attempts: number
    brief_history: number
    phy_advice: number
    refer_date: number
    created_by: number
    login_id: number
    created_on: number
    ref_type: number
    lab_test_status: number
    billing_status: number
    _all: number
  }


  export type Referral_confirmation_detailsAvgAggregateInputType = {
    referred_id?: true
    referral_pat_id?: true
    attempts?: true
    login_id?: true
    lab_test_status?: true
    billing_status?: true
  }

  export type Referral_confirmation_detailsSumAggregateInputType = {
    referred_id?: true
    referral_pat_id?: true
    attempts?: true
    login_id?: true
    lab_test_status?: true
    billing_status?: true
  }

  export type Referral_confirmation_detailsMinAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
  }

  export type Referral_confirmation_detailsMaxAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
  }

  export type Referral_confirmation_detailsCountAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
    billing_status?: true
    _all?: true
  }

  export type Referral_confirmation_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_confirmation_details to aggregate.
     */
    where?: referral_confirmation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details to fetch.
     */
    orderBy?: referral_confirmation_detailsOrderByWithRelationInput | referral_confirmation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_confirmation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_confirmation_details
    **/
    _count?: true | Referral_confirmation_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_confirmation_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_confirmation_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_confirmation_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_confirmation_detailsMaxAggregateInputType
  }

  export type GetReferral_confirmation_detailsAggregateType<T extends Referral_confirmation_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_confirmation_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_confirmation_details[P]>
      : GetScalarType<T[P], AggregateReferral_confirmation_details[P]>
  }




  export type referral_confirmation_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_confirmation_detailsWhereInput
    orderBy?: referral_confirmation_detailsOrderByWithAggregationInput | referral_confirmation_detailsOrderByWithAggregationInput[]
    by: Referral_confirmation_detailsScalarFieldEnum[] | Referral_confirmation_detailsScalarFieldEnum
    having?: referral_confirmation_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_confirmation_detailsCountAggregateInputType | true
    _avg?: Referral_confirmation_detailsAvgAggregateInputType
    _sum?: Referral_confirmation_detailsSumAggregateInputType
    _min?: Referral_confirmation_detailsMinAggregateInputType
    _max?: Referral_confirmation_detailsMaxAggregateInputType
  }

  export type Referral_confirmation_detailsGroupByOutputType = {
    referred_id: number
    medical_num: string
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number
    created_on: Date
    ref_type: $Enums.referral_confirmation_details_ref_type
    lab_test_status: number
    billing_status: number
    _count: Referral_confirmation_detailsCountAggregateOutputType | null
    _avg: Referral_confirmation_detailsAvgAggregateOutputType | null
    _sum: Referral_confirmation_detailsSumAggregateOutputType | null
    _min: Referral_confirmation_detailsMinAggregateOutputType | null
    _max: Referral_confirmation_detailsMaxAggregateOutputType | null
  }

  type GetReferral_confirmation_detailsGroupByPayload<T extends referral_confirmation_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_confirmation_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_confirmation_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_confirmation_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_confirmation_detailsGroupByOutputType[P]>
        }
      >
    >


  export type referral_confirmation_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referred_id?: boolean
    medical_num?: boolean
    relationship?: boolean
    referral_pat_id?: boolean
    password?: boolean
    patient_unique_id?: boolean
    attempts?: boolean
    brief_history?: boolean
    phy_advice?: boolean
    refer_date?: boolean
    created_by?: boolean
    login_id?: boolean
    created_on?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
    billing_status?: boolean
  }, ExtArgs["result"]["referral_confirmation_details"]>


  export type referral_confirmation_detailsSelectScalar = {
    referred_id?: boolean
    medical_num?: boolean
    relationship?: boolean
    referral_pat_id?: boolean
    password?: boolean
    patient_unique_id?: boolean
    attempts?: boolean
    brief_history?: boolean
    phy_advice?: boolean
    refer_date?: boolean
    created_by?: boolean
    login_id?: boolean
    created_on?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
    billing_status?: boolean
  }


  export type $referral_confirmation_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_confirmation_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      referred_id: number
      medical_num: string
      relationship: string | null
      referral_pat_id: number | null
      password: string | null
      patient_unique_id: string | null
      attempts: number | null
      brief_history: string | null
      phy_advice: string | null
      refer_date: Date | null
      created_by: string | null
      login_id: number
      created_on: Date
      ref_type: $Enums.referral_confirmation_details_ref_type
      lab_test_status: number
      billing_status: number
    }, ExtArgs["result"]["referral_confirmation_details"]>
    composites: {}
  }

  type referral_confirmation_detailsGetPayload<S extends boolean | null | undefined | referral_confirmation_detailsDefaultArgs> = $Result.GetResult<Prisma.$referral_confirmation_detailsPayload, S>

  type referral_confirmation_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<referral_confirmation_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Referral_confirmation_detailsCountAggregateInputType | true
    }

  export interface referral_confirmation_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_confirmation_details'], meta: { name: 'referral_confirmation_details' } }
    /**
     * Find zero or one Referral_confirmation_details that matches the filter.
     * @param {referral_confirmation_detailsFindUniqueArgs} args - Arguments to find a Referral_confirmation_details
     * @example
     * // Get one Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_confirmation_detailsFindUniqueArgs>(args: SelectSubset<T, referral_confirmation_detailsFindUniqueArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral_confirmation_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {referral_confirmation_detailsFindUniqueOrThrowArgs} args - Arguments to find a Referral_confirmation_details
     * @example
     * // Get one Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_confirmation_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, referral_confirmation_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral_confirmation_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsFindFirstArgs} args - Arguments to find a Referral_confirmation_details
     * @example
     * // Get one Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_confirmation_detailsFindFirstArgs>(args?: SelectSubset<T, referral_confirmation_detailsFindFirstArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral_confirmation_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsFindFirstOrThrowArgs} args - Arguments to find a Referral_confirmation_details
     * @example
     * // Get one Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_confirmation_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, referral_confirmation_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referral_confirmation_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findMany()
     * 
     * // Get first 10 Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.findMany({ take: 10 })
     * 
     * // Only select the `referred_id`
     * const referral_confirmation_detailsWithReferred_idOnly = await prisma.referral_confirmation_details.findMany({ select: { referred_id: true } })
     * 
     */
    findMany<T extends referral_confirmation_detailsFindManyArgs>(args?: SelectSubset<T, referral_confirmation_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral_confirmation_details.
     * @param {referral_confirmation_detailsCreateArgs} args - Arguments to create a Referral_confirmation_details.
     * @example
     * // Create one Referral_confirmation_details
     * const Referral_confirmation_details = await prisma.referral_confirmation_details.create({
     *   data: {
     *     // ... data to create a Referral_confirmation_details
     *   }
     * })
     * 
     */
    create<T extends referral_confirmation_detailsCreateArgs>(args: SelectSubset<T, referral_confirmation_detailsCreateArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referral_confirmation_details.
     * @param {referral_confirmation_detailsCreateManyArgs} args - Arguments to create many Referral_confirmation_details.
     * @example
     * // Create many Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_confirmation_detailsCreateManyArgs>(args?: SelectSubset<T, referral_confirmation_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_confirmation_details.
     * @param {referral_confirmation_detailsDeleteArgs} args - Arguments to delete one Referral_confirmation_details.
     * @example
     * // Delete one Referral_confirmation_details
     * const Referral_confirmation_details = await prisma.referral_confirmation_details.delete({
     *   where: {
     *     // ... filter to delete one Referral_confirmation_details
     *   }
     * })
     * 
     */
    delete<T extends referral_confirmation_detailsDeleteArgs>(args: SelectSubset<T, referral_confirmation_detailsDeleteArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral_confirmation_details.
     * @param {referral_confirmation_detailsUpdateArgs} args - Arguments to update one Referral_confirmation_details.
     * @example
     * // Update one Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_confirmation_detailsUpdateArgs>(args: SelectSubset<T, referral_confirmation_detailsUpdateArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referral_confirmation_details.
     * @param {referral_confirmation_detailsDeleteManyArgs} args - Arguments to filter Referral_confirmation_details to delete.
     * @example
     * // Delete a few Referral_confirmation_details
     * const { count } = await prisma.referral_confirmation_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_confirmation_detailsDeleteManyArgs>(args?: SelectSubset<T, referral_confirmation_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_confirmation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_confirmation_detailsUpdateManyArgs>(args: SelectSubset<T, referral_confirmation_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_confirmation_details.
     * @param {referral_confirmation_detailsUpsertArgs} args - Arguments to update or create a Referral_confirmation_details.
     * @example
     * // Update or create a Referral_confirmation_details
     * const referral_confirmation_details = await prisma.referral_confirmation_details.upsert({
     *   create: {
     *     // ... data to create a Referral_confirmation_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_confirmation_details we want to update
     *   }
     * })
     */
    upsert<T extends referral_confirmation_detailsUpsertArgs>(args: SelectSubset<T, referral_confirmation_detailsUpsertArgs<ExtArgs>>): Prisma__referral_confirmation_detailsClient<$Result.GetResult<Prisma.$referral_confirmation_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referral_confirmation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsCountArgs} args - Arguments to filter Referral_confirmation_details to count.
     * @example
     * // Count the number of Referral_confirmation_details
     * const count = await prisma.referral_confirmation_details.count({
     *   where: {
     *     // ... the filter for the Referral_confirmation_details we want to count
     *   }
     * })
    **/
    count<T extends referral_confirmation_detailsCountArgs>(
      args?: Subset<T, referral_confirmation_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_confirmation_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_confirmation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_confirmation_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_confirmation_detailsAggregateArgs>(args: Subset<T, Referral_confirmation_detailsAggregateArgs>): Prisma.PrismaPromise<GetReferral_confirmation_detailsAggregateType<T>>

    /**
     * Group by Referral_confirmation_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_confirmation_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_confirmation_detailsGroupByArgs['orderBy'] }
        : { orderBy?: referral_confirmation_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_confirmation_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_confirmation_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_confirmation_details model
   */
  readonly fields: referral_confirmation_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_confirmation_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_confirmation_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_confirmation_details model
   */ 
  interface referral_confirmation_detailsFieldRefs {
    readonly referred_id: FieldRef<"referral_confirmation_details", 'Int'>
    readonly medical_num: FieldRef<"referral_confirmation_details", 'String'>
    readonly relationship: FieldRef<"referral_confirmation_details", 'String'>
    readonly referral_pat_id: FieldRef<"referral_confirmation_details", 'Int'>
    readonly password: FieldRef<"referral_confirmation_details", 'String'>
    readonly patient_unique_id: FieldRef<"referral_confirmation_details", 'String'>
    readonly attempts: FieldRef<"referral_confirmation_details", 'Int'>
    readonly brief_history: FieldRef<"referral_confirmation_details", 'String'>
    readonly phy_advice: FieldRef<"referral_confirmation_details", 'String'>
    readonly refer_date: FieldRef<"referral_confirmation_details", 'DateTime'>
    readonly created_by: FieldRef<"referral_confirmation_details", 'String'>
    readonly login_id: FieldRef<"referral_confirmation_details", 'Int'>
    readonly created_on: FieldRef<"referral_confirmation_details", 'DateTime'>
    readonly ref_type: FieldRef<"referral_confirmation_details", 'referral_confirmation_details_ref_type'>
    readonly lab_test_status: FieldRef<"referral_confirmation_details", 'Int'>
    readonly billing_status: FieldRef<"referral_confirmation_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * referral_confirmation_details findUnique
   */
  export type referral_confirmation_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details to fetch.
     */
    where: referral_confirmation_detailsWhereUniqueInput
  }

  /**
   * referral_confirmation_details findUniqueOrThrow
   */
  export type referral_confirmation_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details to fetch.
     */
    where: referral_confirmation_detailsWhereUniqueInput
  }

  /**
   * referral_confirmation_details findFirst
   */
  export type referral_confirmation_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details to fetch.
     */
    where?: referral_confirmation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details to fetch.
     */
    orderBy?: referral_confirmation_detailsOrderByWithRelationInput | referral_confirmation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_confirmation_details.
     */
    cursor?: referral_confirmation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_confirmation_details.
     */
    distinct?: Referral_confirmation_detailsScalarFieldEnum | Referral_confirmation_detailsScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details findFirstOrThrow
   */
  export type referral_confirmation_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details to fetch.
     */
    where?: referral_confirmation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details to fetch.
     */
    orderBy?: referral_confirmation_detailsOrderByWithRelationInput | referral_confirmation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_confirmation_details.
     */
    cursor?: referral_confirmation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_confirmation_details.
     */
    distinct?: Referral_confirmation_detailsScalarFieldEnum | Referral_confirmation_detailsScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details findMany
   */
  export type referral_confirmation_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details to fetch.
     */
    where?: referral_confirmation_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details to fetch.
     */
    orderBy?: referral_confirmation_detailsOrderByWithRelationInput | referral_confirmation_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_confirmation_details.
     */
    cursor?: referral_confirmation_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details.
     */
    skip?: number
    distinct?: Referral_confirmation_detailsScalarFieldEnum | Referral_confirmation_detailsScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details create
   */
  export type referral_confirmation_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a referral_confirmation_details.
     */
    data: XOR<referral_confirmation_detailsCreateInput, referral_confirmation_detailsUncheckedCreateInput>
  }

  /**
   * referral_confirmation_details createMany
   */
  export type referral_confirmation_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_confirmation_details.
     */
    data: referral_confirmation_detailsCreateManyInput | referral_confirmation_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_confirmation_details update
   */
  export type referral_confirmation_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a referral_confirmation_details.
     */
    data: XOR<referral_confirmation_detailsUpdateInput, referral_confirmation_detailsUncheckedUpdateInput>
    /**
     * Choose, which referral_confirmation_details to update.
     */
    where: referral_confirmation_detailsWhereUniqueInput
  }

  /**
   * referral_confirmation_details updateMany
   */
  export type referral_confirmation_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_confirmation_details.
     */
    data: XOR<referral_confirmation_detailsUpdateManyMutationInput, referral_confirmation_detailsUncheckedUpdateManyInput>
    /**
     * Filter which referral_confirmation_details to update
     */
    where?: referral_confirmation_detailsWhereInput
  }

  /**
   * referral_confirmation_details upsert
   */
  export type referral_confirmation_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the referral_confirmation_details to update in case it exists.
     */
    where: referral_confirmation_detailsWhereUniqueInput
    /**
     * In case the referral_confirmation_details found by the `where` argument doesn't exist, create a new referral_confirmation_details with this data.
     */
    create: XOR<referral_confirmation_detailsCreateInput, referral_confirmation_detailsUncheckedCreateInput>
    /**
     * In case the referral_confirmation_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_confirmation_detailsUpdateInput, referral_confirmation_detailsUncheckedUpdateInput>
  }

  /**
   * referral_confirmation_details delete
   */
  export type referral_confirmation_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
    /**
     * Filter which referral_confirmation_details to delete.
     */
    where: referral_confirmation_detailsWhereUniqueInput
  }

  /**
   * referral_confirmation_details deleteMany
   */
  export type referral_confirmation_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_confirmation_details to delete
     */
    where?: referral_confirmation_detailsWhereInput
  }

  /**
   * referral_confirmation_details without action
   */
  export type referral_confirmation_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details
     */
    select?: referral_confirmation_detailsSelect<ExtArgs> | null
  }


  /**
   * Model referral_confirmation_details1
   */

  export type AggregateReferral_confirmation_details1 = {
    _count: Referral_confirmation_details1CountAggregateOutputType | null
    _avg: Referral_confirmation_details1AvgAggregateOutputType | null
    _sum: Referral_confirmation_details1SumAggregateOutputType | null
    _min: Referral_confirmation_details1MinAggregateOutputType | null
    _max: Referral_confirmation_details1MaxAggregateOutputType | null
  }

  export type Referral_confirmation_details1AvgAggregateOutputType = {
    referred_id: number | null
    referral_pat_id: number | null
    attempts: number | null
    login_id: number | null
    lab_test_status: number | null
  }

  export type Referral_confirmation_details1SumAggregateOutputType = {
    referred_id: number | null
    referral_pat_id: number | null
    attempts: number | null
    login_id: number | null
    lab_test_status: number | null
  }

  export type Referral_confirmation_details1MinAggregateOutputType = {
    referred_id: number | null
    medical_num: string | null
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number | null
    created_on: Date | null
    ref_type: $Enums.referral_confirmation_details1_ref_type | null
    lab_test_status: number | null
  }

  export type Referral_confirmation_details1MaxAggregateOutputType = {
    referred_id: number | null
    medical_num: string | null
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number | null
    created_on: Date | null
    ref_type: $Enums.referral_confirmation_details1_ref_type | null
    lab_test_status: number | null
  }

  export type Referral_confirmation_details1CountAggregateOutputType = {
    referred_id: number
    medical_num: number
    relationship: number
    referral_pat_id: number
    password: number
    patient_unique_id: number
    attempts: number
    brief_history: number
    phy_advice: number
    refer_date: number
    created_by: number
    login_id: number
    created_on: number
    ref_type: number
    lab_test_status: number
    _all: number
  }


  export type Referral_confirmation_details1AvgAggregateInputType = {
    referred_id?: true
    referral_pat_id?: true
    attempts?: true
    login_id?: true
    lab_test_status?: true
  }

  export type Referral_confirmation_details1SumAggregateInputType = {
    referred_id?: true
    referral_pat_id?: true
    attempts?: true
    login_id?: true
    lab_test_status?: true
  }

  export type Referral_confirmation_details1MinAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
  }

  export type Referral_confirmation_details1MaxAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
  }

  export type Referral_confirmation_details1CountAggregateInputType = {
    referred_id?: true
    medical_num?: true
    relationship?: true
    referral_pat_id?: true
    password?: true
    patient_unique_id?: true
    attempts?: true
    brief_history?: true
    phy_advice?: true
    refer_date?: true
    created_by?: true
    login_id?: true
    created_on?: true
    ref_type?: true
    lab_test_status?: true
    _all?: true
  }

  export type Referral_confirmation_details1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_confirmation_details1 to aggregate.
     */
    where?: referral_confirmation_details1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details1s to fetch.
     */
    orderBy?: referral_confirmation_details1OrderByWithRelationInput | referral_confirmation_details1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_confirmation_details1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_confirmation_details1s
    **/
    _count?: true | Referral_confirmation_details1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_confirmation_details1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_confirmation_details1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_confirmation_details1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_confirmation_details1MaxAggregateInputType
  }

  export type GetReferral_confirmation_details1AggregateType<T extends Referral_confirmation_details1AggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_confirmation_details1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_confirmation_details1[P]>
      : GetScalarType<T[P], AggregateReferral_confirmation_details1[P]>
  }




  export type referral_confirmation_details1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_confirmation_details1WhereInput
    orderBy?: referral_confirmation_details1OrderByWithAggregationInput | referral_confirmation_details1OrderByWithAggregationInput[]
    by: Referral_confirmation_details1ScalarFieldEnum[] | Referral_confirmation_details1ScalarFieldEnum
    having?: referral_confirmation_details1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_confirmation_details1CountAggregateInputType | true
    _avg?: Referral_confirmation_details1AvgAggregateInputType
    _sum?: Referral_confirmation_details1SumAggregateInputType
    _min?: Referral_confirmation_details1MinAggregateInputType
    _max?: Referral_confirmation_details1MaxAggregateInputType
  }

  export type Referral_confirmation_details1GroupByOutputType = {
    referred_id: number
    medical_num: string
    relationship: string | null
    referral_pat_id: number | null
    password: string | null
    patient_unique_id: string | null
    attempts: number | null
    brief_history: string | null
    phy_advice: string | null
    refer_date: Date | null
    created_by: string | null
    login_id: number
    created_on: Date
    ref_type: $Enums.referral_confirmation_details1_ref_type
    lab_test_status: number
    _count: Referral_confirmation_details1CountAggregateOutputType | null
    _avg: Referral_confirmation_details1AvgAggregateOutputType | null
    _sum: Referral_confirmation_details1SumAggregateOutputType | null
    _min: Referral_confirmation_details1MinAggregateOutputType | null
    _max: Referral_confirmation_details1MaxAggregateOutputType | null
  }

  type GetReferral_confirmation_details1GroupByPayload<T extends referral_confirmation_details1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_confirmation_details1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_confirmation_details1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_confirmation_details1GroupByOutputType[P]>
            : GetScalarType<T[P], Referral_confirmation_details1GroupByOutputType[P]>
        }
      >
    >


  export type referral_confirmation_details1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referred_id?: boolean
    medical_num?: boolean
    relationship?: boolean
    referral_pat_id?: boolean
    password?: boolean
    patient_unique_id?: boolean
    attempts?: boolean
    brief_history?: boolean
    phy_advice?: boolean
    refer_date?: boolean
    created_by?: boolean
    login_id?: boolean
    created_on?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
  }, ExtArgs["result"]["referral_confirmation_details1"]>


  export type referral_confirmation_details1SelectScalar = {
    referred_id?: boolean
    medical_num?: boolean
    relationship?: boolean
    referral_pat_id?: boolean
    password?: boolean
    patient_unique_id?: boolean
    attempts?: boolean
    brief_history?: boolean
    phy_advice?: boolean
    refer_date?: boolean
    created_by?: boolean
    login_id?: boolean
    created_on?: boolean
    ref_type?: boolean
    lab_test_status?: boolean
  }


  export type $referral_confirmation_details1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_confirmation_details1"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      referred_id: number
      medical_num: string
      relationship: string | null
      referral_pat_id: number | null
      password: string | null
      patient_unique_id: string | null
      attempts: number | null
      brief_history: string | null
      phy_advice: string | null
      refer_date: Date | null
      created_by: string | null
      login_id: number
      created_on: Date
      ref_type: $Enums.referral_confirmation_details1_ref_type
      lab_test_status: number
    }, ExtArgs["result"]["referral_confirmation_details1"]>
    composites: {}
  }

  type referral_confirmation_details1GetPayload<S extends boolean | null | undefined | referral_confirmation_details1DefaultArgs> = $Result.GetResult<Prisma.$referral_confirmation_details1Payload, S>

  type referral_confirmation_details1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<referral_confirmation_details1FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Referral_confirmation_details1CountAggregateInputType | true
    }

  export interface referral_confirmation_details1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_confirmation_details1'], meta: { name: 'referral_confirmation_details1' } }
    /**
     * Find zero or one Referral_confirmation_details1 that matches the filter.
     * @param {referral_confirmation_details1FindUniqueArgs} args - Arguments to find a Referral_confirmation_details1
     * @example
     * // Get one Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_confirmation_details1FindUniqueArgs>(args: SelectSubset<T, referral_confirmation_details1FindUniqueArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral_confirmation_details1 that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {referral_confirmation_details1FindUniqueOrThrowArgs} args - Arguments to find a Referral_confirmation_details1
     * @example
     * // Get one Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_confirmation_details1FindUniqueOrThrowArgs>(args: SelectSubset<T, referral_confirmation_details1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral_confirmation_details1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1FindFirstArgs} args - Arguments to find a Referral_confirmation_details1
     * @example
     * // Get one Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_confirmation_details1FindFirstArgs>(args?: SelectSubset<T, referral_confirmation_details1FindFirstArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral_confirmation_details1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1FindFirstOrThrowArgs} args - Arguments to find a Referral_confirmation_details1
     * @example
     * // Get one Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_confirmation_details1FindFirstOrThrowArgs>(args?: SelectSubset<T, referral_confirmation_details1FindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referral_confirmation_details1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_confirmation_details1s
     * const referral_confirmation_details1s = await prisma.referral_confirmation_details1.findMany()
     * 
     * // Get first 10 Referral_confirmation_details1s
     * const referral_confirmation_details1s = await prisma.referral_confirmation_details1.findMany({ take: 10 })
     * 
     * // Only select the `referred_id`
     * const referral_confirmation_details1WithReferred_idOnly = await prisma.referral_confirmation_details1.findMany({ select: { referred_id: true } })
     * 
     */
    findMany<T extends referral_confirmation_details1FindManyArgs>(args?: SelectSubset<T, referral_confirmation_details1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral_confirmation_details1.
     * @param {referral_confirmation_details1CreateArgs} args - Arguments to create a Referral_confirmation_details1.
     * @example
     * // Create one Referral_confirmation_details1
     * const Referral_confirmation_details1 = await prisma.referral_confirmation_details1.create({
     *   data: {
     *     // ... data to create a Referral_confirmation_details1
     *   }
     * })
     * 
     */
    create<T extends referral_confirmation_details1CreateArgs>(args: SelectSubset<T, referral_confirmation_details1CreateArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referral_confirmation_details1s.
     * @param {referral_confirmation_details1CreateManyArgs} args - Arguments to create many Referral_confirmation_details1s.
     * @example
     * // Create many Referral_confirmation_details1s
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_confirmation_details1CreateManyArgs>(args?: SelectSubset<T, referral_confirmation_details1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_confirmation_details1.
     * @param {referral_confirmation_details1DeleteArgs} args - Arguments to delete one Referral_confirmation_details1.
     * @example
     * // Delete one Referral_confirmation_details1
     * const Referral_confirmation_details1 = await prisma.referral_confirmation_details1.delete({
     *   where: {
     *     // ... filter to delete one Referral_confirmation_details1
     *   }
     * })
     * 
     */
    delete<T extends referral_confirmation_details1DeleteArgs>(args: SelectSubset<T, referral_confirmation_details1DeleteArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral_confirmation_details1.
     * @param {referral_confirmation_details1UpdateArgs} args - Arguments to update one Referral_confirmation_details1.
     * @example
     * // Update one Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_confirmation_details1UpdateArgs>(args: SelectSubset<T, referral_confirmation_details1UpdateArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referral_confirmation_details1s.
     * @param {referral_confirmation_details1DeleteManyArgs} args - Arguments to filter Referral_confirmation_details1s to delete.
     * @example
     * // Delete a few Referral_confirmation_details1s
     * const { count } = await prisma.referral_confirmation_details1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_confirmation_details1DeleteManyArgs>(args?: SelectSubset<T, referral_confirmation_details1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_confirmation_details1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_confirmation_details1s
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_confirmation_details1UpdateManyArgs>(args: SelectSubset<T, referral_confirmation_details1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_confirmation_details1.
     * @param {referral_confirmation_details1UpsertArgs} args - Arguments to update or create a Referral_confirmation_details1.
     * @example
     * // Update or create a Referral_confirmation_details1
     * const referral_confirmation_details1 = await prisma.referral_confirmation_details1.upsert({
     *   create: {
     *     // ... data to create a Referral_confirmation_details1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_confirmation_details1 we want to update
     *   }
     * })
     */
    upsert<T extends referral_confirmation_details1UpsertArgs>(args: SelectSubset<T, referral_confirmation_details1UpsertArgs<ExtArgs>>): Prisma__referral_confirmation_details1Client<$Result.GetResult<Prisma.$referral_confirmation_details1Payload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referral_confirmation_details1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1CountArgs} args - Arguments to filter Referral_confirmation_details1s to count.
     * @example
     * // Count the number of Referral_confirmation_details1s
     * const count = await prisma.referral_confirmation_details1.count({
     *   where: {
     *     // ... the filter for the Referral_confirmation_details1s we want to count
     *   }
     * })
    **/
    count<T extends referral_confirmation_details1CountArgs>(
      args?: Subset<T, referral_confirmation_details1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_confirmation_details1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_confirmation_details1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_confirmation_details1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_confirmation_details1AggregateArgs>(args: Subset<T, Referral_confirmation_details1AggregateArgs>): Prisma.PrismaPromise<GetReferral_confirmation_details1AggregateType<T>>

    /**
     * Group by Referral_confirmation_details1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_confirmation_details1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_confirmation_details1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_confirmation_details1GroupByArgs['orderBy'] }
        : { orderBy?: referral_confirmation_details1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_confirmation_details1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_confirmation_details1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_confirmation_details1 model
   */
  readonly fields: referral_confirmation_details1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_confirmation_details1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_confirmation_details1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_confirmation_details1 model
   */ 
  interface referral_confirmation_details1FieldRefs {
    readonly referred_id: FieldRef<"referral_confirmation_details1", 'Int'>
    readonly medical_num: FieldRef<"referral_confirmation_details1", 'String'>
    readonly relationship: FieldRef<"referral_confirmation_details1", 'String'>
    readonly referral_pat_id: FieldRef<"referral_confirmation_details1", 'Int'>
    readonly password: FieldRef<"referral_confirmation_details1", 'String'>
    readonly patient_unique_id: FieldRef<"referral_confirmation_details1", 'String'>
    readonly attempts: FieldRef<"referral_confirmation_details1", 'Int'>
    readonly brief_history: FieldRef<"referral_confirmation_details1", 'String'>
    readonly phy_advice: FieldRef<"referral_confirmation_details1", 'String'>
    readonly refer_date: FieldRef<"referral_confirmation_details1", 'DateTime'>
    readonly created_by: FieldRef<"referral_confirmation_details1", 'String'>
    readonly login_id: FieldRef<"referral_confirmation_details1", 'Int'>
    readonly created_on: FieldRef<"referral_confirmation_details1", 'DateTime'>
    readonly ref_type: FieldRef<"referral_confirmation_details1", 'referral_confirmation_details1_ref_type'>
    readonly lab_test_status: FieldRef<"referral_confirmation_details1", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * referral_confirmation_details1 findUnique
   */
  export type referral_confirmation_details1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details1 to fetch.
     */
    where: referral_confirmation_details1WhereUniqueInput
  }

  /**
   * referral_confirmation_details1 findUniqueOrThrow
   */
  export type referral_confirmation_details1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details1 to fetch.
     */
    where: referral_confirmation_details1WhereUniqueInput
  }

  /**
   * referral_confirmation_details1 findFirst
   */
  export type referral_confirmation_details1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details1 to fetch.
     */
    where?: referral_confirmation_details1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details1s to fetch.
     */
    orderBy?: referral_confirmation_details1OrderByWithRelationInput | referral_confirmation_details1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_confirmation_details1s.
     */
    cursor?: referral_confirmation_details1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_confirmation_details1s.
     */
    distinct?: Referral_confirmation_details1ScalarFieldEnum | Referral_confirmation_details1ScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details1 findFirstOrThrow
   */
  export type referral_confirmation_details1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details1 to fetch.
     */
    where?: referral_confirmation_details1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details1s to fetch.
     */
    orderBy?: referral_confirmation_details1OrderByWithRelationInput | referral_confirmation_details1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_confirmation_details1s.
     */
    cursor?: referral_confirmation_details1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_confirmation_details1s.
     */
    distinct?: Referral_confirmation_details1ScalarFieldEnum | Referral_confirmation_details1ScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details1 findMany
   */
  export type referral_confirmation_details1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter, which referral_confirmation_details1s to fetch.
     */
    where?: referral_confirmation_details1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_confirmation_details1s to fetch.
     */
    orderBy?: referral_confirmation_details1OrderByWithRelationInput | referral_confirmation_details1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_confirmation_details1s.
     */
    cursor?: referral_confirmation_details1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_confirmation_details1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_confirmation_details1s.
     */
    skip?: number
    distinct?: Referral_confirmation_details1ScalarFieldEnum | Referral_confirmation_details1ScalarFieldEnum[]
  }

  /**
   * referral_confirmation_details1 create
   */
  export type referral_confirmation_details1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * The data needed to create a referral_confirmation_details1.
     */
    data: XOR<referral_confirmation_details1CreateInput, referral_confirmation_details1UncheckedCreateInput>
  }

  /**
   * referral_confirmation_details1 createMany
   */
  export type referral_confirmation_details1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_confirmation_details1s.
     */
    data: referral_confirmation_details1CreateManyInput | referral_confirmation_details1CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_confirmation_details1 update
   */
  export type referral_confirmation_details1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * The data needed to update a referral_confirmation_details1.
     */
    data: XOR<referral_confirmation_details1UpdateInput, referral_confirmation_details1UncheckedUpdateInput>
    /**
     * Choose, which referral_confirmation_details1 to update.
     */
    where: referral_confirmation_details1WhereUniqueInput
  }

  /**
   * referral_confirmation_details1 updateMany
   */
  export type referral_confirmation_details1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_confirmation_details1s.
     */
    data: XOR<referral_confirmation_details1UpdateManyMutationInput, referral_confirmation_details1UncheckedUpdateManyInput>
    /**
     * Filter which referral_confirmation_details1s to update
     */
    where?: referral_confirmation_details1WhereInput
  }

  /**
   * referral_confirmation_details1 upsert
   */
  export type referral_confirmation_details1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * The filter to search for the referral_confirmation_details1 to update in case it exists.
     */
    where: referral_confirmation_details1WhereUniqueInput
    /**
     * In case the referral_confirmation_details1 found by the `where` argument doesn't exist, create a new referral_confirmation_details1 with this data.
     */
    create: XOR<referral_confirmation_details1CreateInput, referral_confirmation_details1UncheckedCreateInput>
    /**
     * In case the referral_confirmation_details1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_confirmation_details1UpdateInput, referral_confirmation_details1UncheckedUpdateInput>
  }

  /**
   * referral_confirmation_details1 delete
   */
  export type referral_confirmation_details1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
    /**
     * Filter which referral_confirmation_details1 to delete.
     */
    where: referral_confirmation_details1WhereUniqueInput
  }

  /**
   * referral_confirmation_details1 deleteMany
   */
  export type referral_confirmation_details1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_confirmation_details1s to delete
     */
    where?: referral_confirmation_details1WhereInput
  }

  /**
   * referral_confirmation_details1 without action
   */
  export type referral_confirmation_details1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_confirmation_details1
     */
    select?: referral_confirmation_details1Select<ExtArgs> | null
  }


  /**
   * Model referral_patient_details
   */

  export type AggregateReferral_patient_details = {
    _count: Referral_patient_detailsCountAggregateOutputType | null
    _avg: Referral_patient_detailsAvgAggregateOutputType | null
    _sum: Referral_patient_detailsSumAggregateOutputType | null
    _min: Referral_patient_detailsMinAggregateOutputType | null
    _max: Referral_patient_detailsMaxAggregateOutputType | null
  }

  export type Referral_patient_detailsAvgAggregateOutputType = {
    referral_patient_id: number | null
    active: number | null
    role_id: number | null
    r_count: number | null
    patient_dep_id: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Referral_patient_detailsSumAggregateOutputType = {
    referral_patient_id: number | null
    active: number | null
    role_id: number | null
    r_count: number | null
    patient_dep_id: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Referral_patient_detailsMinAggregateOutputType = {
    referral_patient_id: number | null
    firstname: string | null
    lastname: string | null
    gender: string | null
    date_of_birth: Date | null
    age: string | null
    address: string | null
    state: string | null
    city: string | null
    pincode: string | null
    mailid: string | null
    phonenum: string | null
    alt_phonenum: string | null
    password: string | null
    relationship: string | null
    created_on: string | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    patient_unique_id: string | null
    physician_id: string | null
    status: string | null
    r_count: number | null
    profile_filename: string | null
    profile_fullpath: string | null
    main_pat_id: string | null
    patient_dep_id: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Referral_patient_detailsMaxAggregateOutputType = {
    referral_patient_id: number | null
    firstname: string | null
    lastname: string | null
    gender: string | null
    date_of_birth: Date | null
    age: string | null
    address: string | null
    state: string | null
    city: string | null
    pincode: string | null
    mailid: string | null
    phonenum: string | null
    alt_phonenum: string | null
    password: string | null
    relationship: string | null
    created_on: string | null
    updated_on: Date | null
    active: number | null
    role_id: number | null
    patient_unique_id: string | null
    physician_id: string | null
    status: string | null
    r_count: number | null
    profile_filename: string | null
    profile_fullpath: string | null
    main_pat_id: string | null
    patient_dep_id: number | null
    count: number | null
    prescribe_receipt: number | null
  }

  export type Referral_patient_detailsCountAggregateOutputType = {
    referral_patient_id: number
    firstname: number
    lastname: number
    gender: number
    date_of_birth: number
    age: number
    address: number
    state: number
    city: number
    pincode: number
    mailid: number
    phonenum: number
    alt_phonenum: number
    password: number
    relationship: number
    created_on: number
    updated_on: number
    active: number
    role_id: number
    patient_unique_id: number
    physician_id: number
    status: number
    r_count: number
    profile_filename: number
    profile_fullpath: number
    main_pat_id: number
    patient_dep_id: number
    count: number
    prescribe_receipt: number
    _all: number
  }


  export type Referral_patient_detailsAvgAggregateInputType = {
    referral_patient_id?: true
    active?: true
    role_id?: true
    r_count?: true
    patient_dep_id?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Referral_patient_detailsSumAggregateInputType = {
    referral_patient_id?: true
    active?: true
    role_id?: true
    r_count?: true
    patient_dep_id?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Referral_patient_detailsMinAggregateInputType = {
    referral_patient_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    state?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    password?: true
    relationship?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    profile_filename?: true
    profile_fullpath?: true
    main_pat_id?: true
    patient_dep_id?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Referral_patient_detailsMaxAggregateInputType = {
    referral_patient_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    state?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    password?: true
    relationship?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    profile_filename?: true
    profile_fullpath?: true
    main_pat_id?: true
    patient_dep_id?: true
    count?: true
    prescribe_receipt?: true
  }

  export type Referral_patient_detailsCountAggregateInputType = {
    referral_patient_id?: true
    firstname?: true
    lastname?: true
    gender?: true
    date_of_birth?: true
    age?: true
    address?: true
    state?: true
    city?: true
    pincode?: true
    mailid?: true
    phonenum?: true
    alt_phonenum?: true
    password?: true
    relationship?: true
    created_on?: true
    updated_on?: true
    active?: true
    role_id?: true
    patient_unique_id?: true
    physician_id?: true
    status?: true
    r_count?: true
    profile_filename?: true
    profile_fullpath?: true
    main_pat_id?: true
    patient_dep_id?: true
    count?: true
    prescribe_receipt?: true
    _all?: true
  }

  export type Referral_patient_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_patient_details to aggregate.
     */
    where?: referral_patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_details to fetch.
     */
    orderBy?: referral_patient_detailsOrderByWithRelationInput | referral_patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_patient_details
    **/
    _count?: true | Referral_patient_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_patient_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_patient_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_patient_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_patient_detailsMaxAggregateInputType
  }

  export type GetReferral_patient_detailsAggregateType<T extends Referral_patient_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_patient_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_patient_details[P]>
      : GetScalarType<T[P], AggregateReferral_patient_details[P]>
  }




  export type referral_patient_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_patient_detailsWhereInput
    orderBy?: referral_patient_detailsOrderByWithAggregationInput | referral_patient_detailsOrderByWithAggregationInput[]
    by: Referral_patient_detailsScalarFieldEnum[] | Referral_patient_detailsScalarFieldEnum
    having?: referral_patient_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_patient_detailsCountAggregateInputType | true
    _avg?: Referral_patient_detailsAvgAggregateInputType
    _sum?: Referral_patient_detailsSumAggregateInputType
    _min?: Referral_patient_detailsMinAggregateInputType
    _max?: Referral_patient_detailsMaxAggregateInputType
  }

  export type Referral_patient_detailsGroupByOutputType = {
    referral_patient_id: number
    firstname: string | null
    lastname: string | null
    gender: string | null
    date_of_birth: Date
    age: string | null
    address: string | null
    state: string | null
    city: string | null
    pincode: string | null
    mailid: string
    phonenum: string
    alt_phonenum: string | null
    password: string | null
    relationship: string
    created_on: string | null
    updated_on: Date | null
    active: number | null
    role_id: number
    patient_unique_id: string | null
    physician_id: string
    status: string
    r_count: number
    profile_filename: string | null
    profile_fullpath: string | null
    main_pat_id: string | null
    patient_dep_id: number | null
    count: number
    prescribe_receipt: number
    _count: Referral_patient_detailsCountAggregateOutputType | null
    _avg: Referral_patient_detailsAvgAggregateOutputType | null
    _sum: Referral_patient_detailsSumAggregateOutputType | null
    _min: Referral_patient_detailsMinAggregateOutputType | null
    _max: Referral_patient_detailsMaxAggregateOutputType | null
  }

  type GetReferral_patient_detailsGroupByPayload<T extends referral_patient_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_patient_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_patient_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_patient_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_patient_detailsGroupByOutputType[P]>
        }
      >
    >


  export type referral_patient_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referral_patient_id?: boolean
    firstname?: boolean
    lastname?: boolean
    gender?: boolean
    date_of_birth?: boolean
    age?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    pincode?: boolean
    mailid?: boolean
    phonenum?: boolean
    alt_phonenum?: boolean
    password?: boolean
    relationship?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    status?: boolean
    r_count?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
    main_pat_id?: boolean
    patient_dep_id?: boolean
    count?: boolean
    prescribe_receipt?: boolean
  }, ExtArgs["result"]["referral_patient_details"]>


  export type referral_patient_detailsSelectScalar = {
    referral_patient_id?: boolean
    firstname?: boolean
    lastname?: boolean
    gender?: boolean
    date_of_birth?: boolean
    age?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    pincode?: boolean
    mailid?: boolean
    phonenum?: boolean
    alt_phonenum?: boolean
    password?: boolean
    relationship?: boolean
    created_on?: boolean
    updated_on?: boolean
    active?: boolean
    role_id?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    status?: boolean
    r_count?: boolean
    profile_filename?: boolean
    profile_fullpath?: boolean
    main_pat_id?: boolean
    patient_dep_id?: boolean
    count?: boolean
    prescribe_receipt?: boolean
  }


  export type $referral_patient_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_patient_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      referral_patient_id: number
      firstname: string | null
      lastname: string | null
      gender: string | null
      date_of_birth: Date
      age: string | null
      address: string | null
      state: string | null
      city: string | null
      pincode: string | null
      mailid: string
      phonenum: string
      alt_phonenum: string | null
      password: string | null
      relationship: string
      created_on: string | null
      updated_on: Date | null
      active: number | null
      role_id: number
      patient_unique_id: string | null
      physician_id: string
      status: string
      r_count: number
      profile_filename: string | null
      profile_fullpath: string | null
      main_pat_id: string | null
      patient_dep_id: number | null
      count: number
      prescribe_receipt: number
    }, ExtArgs["result"]["referral_patient_details"]>
    composites: {}
  }

  type referral_patient_detailsGetPayload<S extends boolean | null | undefined | referral_patient_detailsDefaultArgs> = $Result.GetResult<Prisma.$referral_patient_detailsPayload, S>

  type referral_patient_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<referral_patient_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Referral_patient_detailsCountAggregateInputType | true
    }

  export interface referral_patient_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_patient_details'], meta: { name: 'referral_patient_details' } }
    /**
     * Find zero or one Referral_patient_details that matches the filter.
     * @param {referral_patient_detailsFindUniqueArgs} args - Arguments to find a Referral_patient_details
     * @example
     * // Get one Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_patient_detailsFindUniqueArgs>(args: SelectSubset<T, referral_patient_detailsFindUniqueArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral_patient_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {referral_patient_detailsFindUniqueOrThrowArgs} args - Arguments to find a Referral_patient_details
     * @example
     * // Get one Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_patient_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, referral_patient_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral_patient_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsFindFirstArgs} args - Arguments to find a Referral_patient_details
     * @example
     * // Get one Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_patient_detailsFindFirstArgs>(args?: SelectSubset<T, referral_patient_detailsFindFirstArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral_patient_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsFindFirstOrThrowArgs} args - Arguments to find a Referral_patient_details
     * @example
     * // Get one Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_patient_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, referral_patient_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referral_patient_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findMany()
     * 
     * // Get first 10 Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.findMany({ take: 10 })
     * 
     * // Only select the `referral_patient_id`
     * const referral_patient_detailsWithReferral_patient_idOnly = await prisma.referral_patient_details.findMany({ select: { referral_patient_id: true } })
     * 
     */
    findMany<T extends referral_patient_detailsFindManyArgs>(args?: SelectSubset<T, referral_patient_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral_patient_details.
     * @param {referral_patient_detailsCreateArgs} args - Arguments to create a Referral_patient_details.
     * @example
     * // Create one Referral_patient_details
     * const Referral_patient_details = await prisma.referral_patient_details.create({
     *   data: {
     *     // ... data to create a Referral_patient_details
     *   }
     * })
     * 
     */
    create<T extends referral_patient_detailsCreateArgs>(args: SelectSubset<T, referral_patient_detailsCreateArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referral_patient_details.
     * @param {referral_patient_detailsCreateManyArgs} args - Arguments to create many Referral_patient_details.
     * @example
     * // Create many Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_patient_detailsCreateManyArgs>(args?: SelectSubset<T, referral_patient_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_patient_details.
     * @param {referral_patient_detailsDeleteArgs} args - Arguments to delete one Referral_patient_details.
     * @example
     * // Delete one Referral_patient_details
     * const Referral_patient_details = await prisma.referral_patient_details.delete({
     *   where: {
     *     // ... filter to delete one Referral_patient_details
     *   }
     * })
     * 
     */
    delete<T extends referral_patient_detailsDeleteArgs>(args: SelectSubset<T, referral_patient_detailsDeleteArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral_patient_details.
     * @param {referral_patient_detailsUpdateArgs} args - Arguments to update one Referral_patient_details.
     * @example
     * // Update one Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_patient_detailsUpdateArgs>(args: SelectSubset<T, referral_patient_detailsUpdateArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referral_patient_details.
     * @param {referral_patient_detailsDeleteManyArgs} args - Arguments to filter Referral_patient_details to delete.
     * @example
     * // Delete a few Referral_patient_details
     * const { count } = await prisma.referral_patient_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_patient_detailsDeleteManyArgs>(args?: SelectSubset<T, referral_patient_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_patient_detailsUpdateManyArgs>(args: SelectSubset<T, referral_patient_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_patient_details.
     * @param {referral_patient_detailsUpsertArgs} args - Arguments to update or create a Referral_patient_details.
     * @example
     * // Update or create a Referral_patient_details
     * const referral_patient_details = await prisma.referral_patient_details.upsert({
     *   create: {
     *     // ... data to create a Referral_patient_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_patient_details we want to update
     *   }
     * })
     */
    upsert<T extends referral_patient_detailsUpsertArgs>(args: SelectSubset<T, referral_patient_detailsUpsertArgs<ExtArgs>>): Prisma__referral_patient_detailsClient<$Result.GetResult<Prisma.$referral_patient_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referral_patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsCountArgs} args - Arguments to filter Referral_patient_details to count.
     * @example
     * // Count the number of Referral_patient_details
     * const count = await prisma.referral_patient_details.count({
     *   where: {
     *     // ... the filter for the Referral_patient_details we want to count
     *   }
     * })
    **/
    count<T extends referral_patient_detailsCountArgs>(
      args?: Subset<T, referral_patient_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_patient_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_patient_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_patient_detailsAggregateArgs>(args: Subset<T, Referral_patient_detailsAggregateArgs>): Prisma.PrismaPromise<GetReferral_patient_detailsAggregateType<T>>

    /**
     * Group by Referral_patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_patient_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_patient_detailsGroupByArgs['orderBy'] }
        : { orderBy?: referral_patient_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_patient_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_patient_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_patient_details model
   */
  readonly fields: referral_patient_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_patient_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_patient_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_patient_details model
   */ 
  interface referral_patient_detailsFieldRefs {
    readonly referral_patient_id: FieldRef<"referral_patient_details", 'Int'>
    readonly firstname: FieldRef<"referral_patient_details", 'String'>
    readonly lastname: FieldRef<"referral_patient_details", 'String'>
    readonly gender: FieldRef<"referral_patient_details", 'String'>
    readonly date_of_birth: FieldRef<"referral_patient_details", 'DateTime'>
    readonly age: FieldRef<"referral_patient_details", 'String'>
    readonly address: FieldRef<"referral_patient_details", 'String'>
    readonly state: FieldRef<"referral_patient_details", 'String'>
    readonly city: FieldRef<"referral_patient_details", 'String'>
    readonly pincode: FieldRef<"referral_patient_details", 'String'>
    readonly mailid: FieldRef<"referral_patient_details", 'String'>
    readonly phonenum: FieldRef<"referral_patient_details", 'String'>
    readonly alt_phonenum: FieldRef<"referral_patient_details", 'String'>
    readonly password: FieldRef<"referral_patient_details", 'String'>
    readonly relationship: FieldRef<"referral_patient_details", 'String'>
    readonly created_on: FieldRef<"referral_patient_details", 'String'>
    readonly updated_on: FieldRef<"referral_patient_details", 'DateTime'>
    readonly active: FieldRef<"referral_patient_details", 'Int'>
    readonly role_id: FieldRef<"referral_patient_details", 'Int'>
    readonly patient_unique_id: FieldRef<"referral_patient_details", 'String'>
    readonly physician_id: FieldRef<"referral_patient_details", 'String'>
    readonly status: FieldRef<"referral_patient_details", 'String'>
    readonly r_count: FieldRef<"referral_patient_details", 'Int'>
    readonly profile_filename: FieldRef<"referral_patient_details", 'String'>
    readonly profile_fullpath: FieldRef<"referral_patient_details", 'String'>
    readonly main_pat_id: FieldRef<"referral_patient_details", 'String'>
    readonly patient_dep_id: FieldRef<"referral_patient_details", 'Int'>
    readonly count: FieldRef<"referral_patient_details", 'Int'>
    readonly prescribe_receipt: FieldRef<"referral_patient_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * referral_patient_details findUnique
   */
  export type referral_patient_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_details to fetch.
     */
    where: referral_patient_detailsWhereUniqueInput
  }

  /**
   * referral_patient_details findUniqueOrThrow
   */
  export type referral_patient_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_details to fetch.
     */
    where: referral_patient_detailsWhereUniqueInput
  }

  /**
   * referral_patient_details findFirst
   */
  export type referral_patient_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_details to fetch.
     */
    where?: referral_patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_details to fetch.
     */
    orderBy?: referral_patient_detailsOrderByWithRelationInput | referral_patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_patient_details.
     */
    cursor?: referral_patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_patient_details.
     */
    distinct?: Referral_patient_detailsScalarFieldEnum | Referral_patient_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_details findFirstOrThrow
   */
  export type referral_patient_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_details to fetch.
     */
    where?: referral_patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_details to fetch.
     */
    orderBy?: referral_patient_detailsOrderByWithRelationInput | referral_patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_patient_details.
     */
    cursor?: referral_patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_patient_details.
     */
    distinct?: Referral_patient_detailsScalarFieldEnum | Referral_patient_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_details findMany
   */
  export type referral_patient_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_details to fetch.
     */
    where?: referral_patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_details to fetch.
     */
    orderBy?: referral_patient_detailsOrderByWithRelationInput | referral_patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_patient_details.
     */
    cursor?: referral_patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_details.
     */
    skip?: number
    distinct?: Referral_patient_detailsScalarFieldEnum | Referral_patient_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_details create
   */
  export type referral_patient_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a referral_patient_details.
     */
    data: XOR<referral_patient_detailsCreateInput, referral_patient_detailsUncheckedCreateInput>
  }

  /**
   * referral_patient_details createMany
   */
  export type referral_patient_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_patient_details.
     */
    data: referral_patient_detailsCreateManyInput | referral_patient_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_patient_details update
   */
  export type referral_patient_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a referral_patient_details.
     */
    data: XOR<referral_patient_detailsUpdateInput, referral_patient_detailsUncheckedUpdateInput>
    /**
     * Choose, which referral_patient_details to update.
     */
    where: referral_patient_detailsWhereUniqueInput
  }

  /**
   * referral_patient_details updateMany
   */
  export type referral_patient_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_patient_details.
     */
    data: XOR<referral_patient_detailsUpdateManyMutationInput, referral_patient_detailsUncheckedUpdateManyInput>
    /**
     * Filter which referral_patient_details to update
     */
    where?: referral_patient_detailsWhereInput
  }

  /**
   * referral_patient_details upsert
   */
  export type referral_patient_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the referral_patient_details to update in case it exists.
     */
    where: referral_patient_detailsWhereUniqueInput
    /**
     * In case the referral_patient_details found by the `where` argument doesn't exist, create a new referral_patient_details with this data.
     */
    create: XOR<referral_patient_detailsCreateInput, referral_patient_detailsUncheckedCreateInput>
    /**
     * In case the referral_patient_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_patient_detailsUpdateInput, referral_patient_detailsUncheckedUpdateInput>
  }

  /**
   * referral_patient_details delete
   */
  export type referral_patient_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
    /**
     * Filter which referral_patient_details to delete.
     */
    where: referral_patient_detailsWhereUniqueInput
  }

  /**
   * referral_patient_details deleteMany
   */
  export type referral_patient_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_patient_details to delete
     */
    where?: referral_patient_detailsWhereInput
  }

  /**
   * referral_patient_details without action
   */
  export type referral_patient_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_details
     */
    select?: referral_patient_detailsSelect<ExtArgs> | null
  }


  /**
   * Model referral_patient_test_details
   */

  export type AggregateReferral_patient_test_details = {
    _count: Referral_patient_test_detailsCountAggregateOutputType | null
    _avg: Referral_patient_test_detailsAvgAggregateOutputType | null
    _sum: Referral_patient_test_detailsSumAggregateOutputType | null
    _min: Referral_patient_test_detailsMinAggregateOutputType | null
    _max: Referral_patient_test_detailsMaxAggregateOutputType | null
  }

  export type Referral_patient_test_detailsAvgAggregateOutputType = {
    ID: number | null
    parse_parent_id: number | null
    has_child: number | null
    physician_id: number | null
    laboratory_id: number | null
    dependent_id: number | null
    main_patient_id: number | null
    billing_id: number | null
    sample_collected_id: number | null
    labapproval_id: number | null
    pat_status: number | null
    approved_lab_doc_id: number | null
  }

  export type Referral_patient_test_detailsSumAggregateOutputType = {
    ID: number | null
    parse_parent_id: number | null
    has_child: number | null
    physician_id: number | null
    laboratory_id: number | null
    dependent_id: number | null
    main_patient_id: number | null
    billing_id: number | null
    sample_collected_id: number | null
    labapproval_id: number | null
    pat_status: number | null
    approved_lab_doc_id: number | null
  }

  export type Referral_patient_test_detailsMinAggregateOutputType = {
    ID: number | null
    medical_num: string | null
    laboratory_tests: string | null
    parse_parent_id: number | null
    has_child: number | null
    time: string | null
    date: Date | null
    instruction: string | null
    patient_unique_id: string | null
    physician_id: number | null
    laboratory_id: number | null
    dependent_id: number | null
    main_patient_id: number | null
    billing_id: number | null
    billing_datetime: Date | null
    sample_collected_id: number | null
    sample_datetime: Date | null
    labapproval_id: number | null
    labapproval_datetime: Date | null
    pat_status: number | null
    report_filename: string | null
    report_fullpath: string | null
    approved_lab_doc_id: number | null
    editor: string | null
    created_on: Date | null
  }

  export type Referral_patient_test_detailsMaxAggregateOutputType = {
    ID: number | null
    medical_num: string | null
    laboratory_tests: string | null
    parse_parent_id: number | null
    has_child: number | null
    time: string | null
    date: Date | null
    instruction: string | null
    patient_unique_id: string | null
    physician_id: number | null
    laboratory_id: number | null
    dependent_id: number | null
    main_patient_id: number | null
    billing_id: number | null
    billing_datetime: Date | null
    sample_collected_id: number | null
    sample_datetime: Date | null
    labapproval_id: number | null
    labapproval_datetime: Date | null
    pat_status: number | null
    report_filename: string | null
    report_fullpath: string | null
    approved_lab_doc_id: number | null
    editor: string | null
    created_on: Date | null
  }

  export type Referral_patient_test_detailsCountAggregateOutputType = {
    ID: number
    medical_num: number
    laboratory_tests: number
    parse_parent_id: number
    has_child: number
    time: number
    date: number
    instruction: number
    patient_unique_id: number
    physician_id: number
    laboratory_id: number
    dependent_id: number
    main_patient_id: number
    billing_id: number
    billing_datetime: number
    sample_collected_id: number
    sample_datetime: number
    labapproval_id: number
    labapproval_datetime: number
    pat_status: number
    report_filename: number
    report_fullpath: number
    approved_lab_doc_id: number
    editor: number
    created_on: number
    _all: number
  }


  export type Referral_patient_test_detailsAvgAggregateInputType = {
    ID?: true
    parse_parent_id?: true
    has_child?: true
    physician_id?: true
    laboratory_id?: true
    dependent_id?: true
    main_patient_id?: true
    billing_id?: true
    sample_collected_id?: true
    labapproval_id?: true
    pat_status?: true
    approved_lab_doc_id?: true
  }

  export type Referral_patient_test_detailsSumAggregateInputType = {
    ID?: true
    parse_parent_id?: true
    has_child?: true
    physician_id?: true
    laboratory_id?: true
    dependent_id?: true
    main_patient_id?: true
    billing_id?: true
    sample_collected_id?: true
    labapproval_id?: true
    pat_status?: true
    approved_lab_doc_id?: true
  }

  export type Referral_patient_test_detailsMinAggregateInputType = {
    ID?: true
    medical_num?: true
    laboratory_tests?: true
    parse_parent_id?: true
    has_child?: true
    time?: true
    date?: true
    instruction?: true
    patient_unique_id?: true
    physician_id?: true
    laboratory_id?: true
    dependent_id?: true
    main_patient_id?: true
    billing_id?: true
    billing_datetime?: true
    sample_collected_id?: true
    sample_datetime?: true
    labapproval_id?: true
    labapproval_datetime?: true
    pat_status?: true
    report_filename?: true
    report_fullpath?: true
    approved_lab_doc_id?: true
    editor?: true
    created_on?: true
  }

  export type Referral_patient_test_detailsMaxAggregateInputType = {
    ID?: true
    medical_num?: true
    laboratory_tests?: true
    parse_parent_id?: true
    has_child?: true
    time?: true
    date?: true
    instruction?: true
    patient_unique_id?: true
    physician_id?: true
    laboratory_id?: true
    dependent_id?: true
    main_patient_id?: true
    billing_id?: true
    billing_datetime?: true
    sample_collected_id?: true
    sample_datetime?: true
    labapproval_id?: true
    labapproval_datetime?: true
    pat_status?: true
    report_filename?: true
    report_fullpath?: true
    approved_lab_doc_id?: true
    editor?: true
    created_on?: true
  }

  export type Referral_patient_test_detailsCountAggregateInputType = {
    ID?: true
    medical_num?: true
    laboratory_tests?: true
    parse_parent_id?: true
    has_child?: true
    time?: true
    date?: true
    instruction?: true
    patient_unique_id?: true
    physician_id?: true
    laboratory_id?: true
    dependent_id?: true
    main_patient_id?: true
    billing_id?: true
    billing_datetime?: true
    sample_collected_id?: true
    sample_datetime?: true
    labapproval_id?: true
    labapproval_datetime?: true
    pat_status?: true
    report_filename?: true
    report_fullpath?: true
    approved_lab_doc_id?: true
    editor?: true
    created_on?: true
    _all?: true
  }

  export type Referral_patient_test_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_patient_test_details to aggregate.
     */
    where?: referral_patient_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_test_details to fetch.
     */
    orderBy?: referral_patient_test_detailsOrderByWithRelationInput | referral_patient_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_patient_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_patient_test_details
    **/
    _count?: true | Referral_patient_test_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_patient_test_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_patient_test_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_patient_test_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_patient_test_detailsMaxAggregateInputType
  }

  export type GetReferral_patient_test_detailsAggregateType<T extends Referral_patient_test_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_patient_test_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_patient_test_details[P]>
      : GetScalarType<T[P], AggregateReferral_patient_test_details[P]>
  }




  export type referral_patient_test_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_patient_test_detailsWhereInput
    orderBy?: referral_patient_test_detailsOrderByWithAggregationInput | referral_patient_test_detailsOrderByWithAggregationInput[]
    by: Referral_patient_test_detailsScalarFieldEnum[] | Referral_patient_test_detailsScalarFieldEnum
    having?: referral_patient_test_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_patient_test_detailsCountAggregateInputType | true
    _avg?: Referral_patient_test_detailsAvgAggregateInputType
    _sum?: Referral_patient_test_detailsSumAggregateInputType
    _min?: Referral_patient_test_detailsMinAggregateInputType
    _max?: Referral_patient_test_detailsMaxAggregateInputType
  }

  export type Referral_patient_test_detailsGroupByOutputType = {
    ID: number
    medical_num: string | null
    laboratory_tests: string | null
    parse_parent_id: number
    has_child: number
    time: string | null
    date: Date | null
    instruction: string | null
    patient_unique_id: string | null
    physician_id: number | null
    laboratory_id: number | null
    dependent_id: number | null
    main_patient_id: number | null
    billing_id: number
    billing_datetime: Date
    sample_collected_id: number
    sample_datetime: Date
    labapproval_id: number
    labapproval_datetime: Date
    pat_status: number
    report_filename: string | null
    report_fullpath: string | null
    approved_lab_doc_id: number
    editor: string
    created_on: Date
    _count: Referral_patient_test_detailsCountAggregateOutputType | null
    _avg: Referral_patient_test_detailsAvgAggregateOutputType | null
    _sum: Referral_patient_test_detailsSumAggregateOutputType | null
    _min: Referral_patient_test_detailsMinAggregateOutputType | null
    _max: Referral_patient_test_detailsMaxAggregateOutputType | null
  }

  type GetReferral_patient_test_detailsGroupByPayload<T extends referral_patient_test_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_patient_test_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_patient_test_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_patient_test_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_patient_test_detailsGroupByOutputType[P]>
        }
      >
    >


  export type referral_patient_test_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    medical_num?: boolean
    laboratory_tests?: boolean
    parse_parent_id?: boolean
    has_child?: boolean
    time?: boolean
    date?: boolean
    instruction?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    laboratory_id?: boolean
    dependent_id?: boolean
    main_patient_id?: boolean
    billing_id?: boolean
    billing_datetime?: boolean
    sample_collected_id?: boolean
    sample_datetime?: boolean
    labapproval_id?: boolean
    labapproval_datetime?: boolean
    pat_status?: boolean
    report_filename?: boolean
    report_fullpath?: boolean
    approved_lab_doc_id?: boolean
    editor?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["referral_patient_test_details"]>


  export type referral_patient_test_detailsSelectScalar = {
    ID?: boolean
    medical_num?: boolean
    laboratory_tests?: boolean
    parse_parent_id?: boolean
    has_child?: boolean
    time?: boolean
    date?: boolean
    instruction?: boolean
    patient_unique_id?: boolean
    physician_id?: boolean
    laboratory_id?: boolean
    dependent_id?: boolean
    main_patient_id?: boolean
    billing_id?: boolean
    billing_datetime?: boolean
    sample_collected_id?: boolean
    sample_datetime?: boolean
    labapproval_id?: boolean
    labapproval_datetime?: boolean
    pat_status?: boolean
    report_filename?: boolean
    report_fullpath?: boolean
    approved_lab_doc_id?: boolean
    editor?: boolean
    created_on?: boolean
  }


  export type $referral_patient_test_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_patient_test_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      medical_num: string | null
      laboratory_tests: string | null
      parse_parent_id: number
      has_child: number
      time: string | null
      date: Date | null
      instruction: string | null
      patient_unique_id: string | null
      physician_id: number | null
      laboratory_id: number | null
      dependent_id: number | null
      main_patient_id: number | null
      billing_id: number
      billing_datetime: Date
      sample_collected_id: number
      sample_datetime: Date
      labapproval_id: number
      labapproval_datetime: Date
      pat_status: number
      report_filename: string | null
      report_fullpath: string | null
      approved_lab_doc_id: number
      editor: string
      created_on: Date
    }, ExtArgs["result"]["referral_patient_test_details"]>
    composites: {}
  }

  type referral_patient_test_detailsGetPayload<S extends boolean | null | undefined | referral_patient_test_detailsDefaultArgs> = $Result.GetResult<Prisma.$referral_patient_test_detailsPayload, S>

  type referral_patient_test_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<referral_patient_test_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Referral_patient_test_detailsCountAggregateInputType | true
    }

  export interface referral_patient_test_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_patient_test_details'], meta: { name: 'referral_patient_test_details' } }
    /**
     * Find zero or one Referral_patient_test_details that matches the filter.
     * @param {referral_patient_test_detailsFindUniqueArgs} args - Arguments to find a Referral_patient_test_details
     * @example
     * // Get one Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_patient_test_detailsFindUniqueArgs>(args: SelectSubset<T, referral_patient_test_detailsFindUniqueArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral_patient_test_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {referral_patient_test_detailsFindUniqueOrThrowArgs} args - Arguments to find a Referral_patient_test_details
     * @example
     * // Get one Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_patient_test_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, referral_patient_test_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral_patient_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsFindFirstArgs} args - Arguments to find a Referral_patient_test_details
     * @example
     * // Get one Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_patient_test_detailsFindFirstArgs>(args?: SelectSubset<T, referral_patient_test_detailsFindFirstArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral_patient_test_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsFindFirstOrThrowArgs} args - Arguments to find a Referral_patient_test_details
     * @example
     * // Get one Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_patient_test_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, referral_patient_test_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referral_patient_test_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findMany()
     * 
     * // Get first 10 Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const referral_patient_test_detailsWithIDOnly = await prisma.referral_patient_test_details.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends referral_patient_test_detailsFindManyArgs>(args?: SelectSubset<T, referral_patient_test_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral_patient_test_details.
     * @param {referral_patient_test_detailsCreateArgs} args - Arguments to create a Referral_patient_test_details.
     * @example
     * // Create one Referral_patient_test_details
     * const Referral_patient_test_details = await prisma.referral_patient_test_details.create({
     *   data: {
     *     // ... data to create a Referral_patient_test_details
     *   }
     * })
     * 
     */
    create<T extends referral_patient_test_detailsCreateArgs>(args: SelectSubset<T, referral_patient_test_detailsCreateArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referral_patient_test_details.
     * @param {referral_patient_test_detailsCreateManyArgs} args - Arguments to create many Referral_patient_test_details.
     * @example
     * // Create many Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_patient_test_detailsCreateManyArgs>(args?: SelectSubset<T, referral_patient_test_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_patient_test_details.
     * @param {referral_patient_test_detailsDeleteArgs} args - Arguments to delete one Referral_patient_test_details.
     * @example
     * // Delete one Referral_patient_test_details
     * const Referral_patient_test_details = await prisma.referral_patient_test_details.delete({
     *   where: {
     *     // ... filter to delete one Referral_patient_test_details
     *   }
     * })
     * 
     */
    delete<T extends referral_patient_test_detailsDeleteArgs>(args: SelectSubset<T, referral_patient_test_detailsDeleteArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral_patient_test_details.
     * @param {referral_patient_test_detailsUpdateArgs} args - Arguments to update one Referral_patient_test_details.
     * @example
     * // Update one Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_patient_test_detailsUpdateArgs>(args: SelectSubset<T, referral_patient_test_detailsUpdateArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referral_patient_test_details.
     * @param {referral_patient_test_detailsDeleteManyArgs} args - Arguments to filter Referral_patient_test_details to delete.
     * @example
     * // Delete a few Referral_patient_test_details
     * const { count } = await prisma.referral_patient_test_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_patient_test_detailsDeleteManyArgs>(args?: SelectSubset<T, referral_patient_test_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_patient_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_patient_test_detailsUpdateManyArgs>(args: SelectSubset<T, referral_patient_test_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_patient_test_details.
     * @param {referral_patient_test_detailsUpsertArgs} args - Arguments to update or create a Referral_patient_test_details.
     * @example
     * // Update or create a Referral_patient_test_details
     * const referral_patient_test_details = await prisma.referral_patient_test_details.upsert({
     *   create: {
     *     // ... data to create a Referral_patient_test_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_patient_test_details we want to update
     *   }
     * })
     */
    upsert<T extends referral_patient_test_detailsUpsertArgs>(args: SelectSubset<T, referral_patient_test_detailsUpsertArgs<ExtArgs>>): Prisma__referral_patient_test_detailsClient<$Result.GetResult<Prisma.$referral_patient_test_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referral_patient_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsCountArgs} args - Arguments to filter Referral_patient_test_details to count.
     * @example
     * // Count the number of Referral_patient_test_details
     * const count = await prisma.referral_patient_test_details.count({
     *   where: {
     *     // ... the filter for the Referral_patient_test_details we want to count
     *   }
     * })
    **/
    count<T extends referral_patient_test_detailsCountArgs>(
      args?: Subset<T, referral_patient_test_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_patient_test_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_patient_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_patient_test_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_patient_test_detailsAggregateArgs>(args: Subset<T, Referral_patient_test_detailsAggregateArgs>): Prisma.PrismaPromise<GetReferral_patient_test_detailsAggregateType<T>>

    /**
     * Group by Referral_patient_test_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_patient_test_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_patient_test_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_patient_test_detailsGroupByArgs['orderBy'] }
        : { orderBy?: referral_patient_test_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_patient_test_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_patient_test_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_patient_test_details model
   */
  readonly fields: referral_patient_test_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_patient_test_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_patient_test_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_patient_test_details model
   */ 
  interface referral_patient_test_detailsFieldRefs {
    readonly ID: FieldRef<"referral_patient_test_details", 'Int'>
    readonly medical_num: FieldRef<"referral_patient_test_details", 'String'>
    readonly laboratory_tests: FieldRef<"referral_patient_test_details", 'String'>
    readonly parse_parent_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly has_child: FieldRef<"referral_patient_test_details", 'Int'>
    readonly time: FieldRef<"referral_patient_test_details", 'String'>
    readonly date: FieldRef<"referral_patient_test_details", 'DateTime'>
    readonly instruction: FieldRef<"referral_patient_test_details", 'String'>
    readonly patient_unique_id: FieldRef<"referral_patient_test_details", 'String'>
    readonly physician_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly laboratory_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly dependent_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly main_patient_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly billing_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly billing_datetime: FieldRef<"referral_patient_test_details", 'DateTime'>
    readonly sample_collected_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly sample_datetime: FieldRef<"referral_patient_test_details", 'DateTime'>
    readonly labapproval_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly labapproval_datetime: FieldRef<"referral_patient_test_details", 'DateTime'>
    readonly pat_status: FieldRef<"referral_patient_test_details", 'Int'>
    readonly report_filename: FieldRef<"referral_patient_test_details", 'String'>
    readonly report_fullpath: FieldRef<"referral_patient_test_details", 'String'>
    readonly approved_lab_doc_id: FieldRef<"referral_patient_test_details", 'Int'>
    readonly editor: FieldRef<"referral_patient_test_details", 'String'>
    readonly created_on: FieldRef<"referral_patient_test_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * referral_patient_test_details findUnique
   */
  export type referral_patient_test_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_test_details to fetch.
     */
    where: referral_patient_test_detailsWhereUniqueInput
  }

  /**
   * referral_patient_test_details findUniqueOrThrow
   */
  export type referral_patient_test_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_test_details to fetch.
     */
    where: referral_patient_test_detailsWhereUniqueInput
  }

  /**
   * referral_patient_test_details findFirst
   */
  export type referral_patient_test_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_test_details to fetch.
     */
    where?: referral_patient_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_test_details to fetch.
     */
    orderBy?: referral_patient_test_detailsOrderByWithRelationInput | referral_patient_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_patient_test_details.
     */
    cursor?: referral_patient_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_patient_test_details.
     */
    distinct?: Referral_patient_test_detailsScalarFieldEnum | Referral_patient_test_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_test_details findFirstOrThrow
   */
  export type referral_patient_test_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_test_details to fetch.
     */
    where?: referral_patient_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_test_details to fetch.
     */
    orderBy?: referral_patient_test_detailsOrderByWithRelationInput | referral_patient_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_patient_test_details.
     */
    cursor?: referral_patient_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_test_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_patient_test_details.
     */
    distinct?: Referral_patient_test_detailsScalarFieldEnum | Referral_patient_test_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_test_details findMany
   */
  export type referral_patient_test_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter, which referral_patient_test_details to fetch.
     */
    where?: referral_patient_test_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_patient_test_details to fetch.
     */
    orderBy?: referral_patient_test_detailsOrderByWithRelationInput | referral_patient_test_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_patient_test_details.
     */
    cursor?: referral_patient_test_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_patient_test_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_patient_test_details.
     */
    skip?: number
    distinct?: Referral_patient_test_detailsScalarFieldEnum | Referral_patient_test_detailsScalarFieldEnum[]
  }

  /**
   * referral_patient_test_details create
   */
  export type referral_patient_test_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a referral_patient_test_details.
     */
    data: XOR<referral_patient_test_detailsCreateInput, referral_patient_test_detailsUncheckedCreateInput>
  }

  /**
   * referral_patient_test_details createMany
   */
  export type referral_patient_test_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_patient_test_details.
     */
    data: referral_patient_test_detailsCreateManyInput | referral_patient_test_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_patient_test_details update
   */
  export type referral_patient_test_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a referral_patient_test_details.
     */
    data: XOR<referral_patient_test_detailsUpdateInput, referral_patient_test_detailsUncheckedUpdateInput>
    /**
     * Choose, which referral_patient_test_details to update.
     */
    where: referral_patient_test_detailsWhereUniqueInput
  }

  /**
   * referral_patient_test_details updateMany
   */
  export type referral_patient_test_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_patient_test_details.
     */
    data: XOR<referral_patient_test_detailsUpdateManyMutationInput, referral_patient_test_detailsUncheckedUpdateManyInput>
    /**
     * Filter which referral_patient_test_details to update
     */
    where?: referral_patient_test_detailsWhereInput
  }

  /**
   * referral_patient_test_details upsert
   */
  export type referral_patient_test_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the referral_patient_test_details to update in case it exists.
     */
    where: referral_patient_test_detailsWhereUniqueInput
    /**
     * In case the referral_patient_test_details found by the `where` argument doesn't exist, create a new referral_patient_test_details with this data.
     */
    create: XOR<referral_patient_test_detailsCreateInput, referral_patient_test_detailsUncheckedCreateInput>
    /**
     * In case the referral_patient_test_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_patient_test_detailsUpdateInput, referral_patient_test_detailsUncheckedUpdateInput>
  }

  /**
   * referral_patient_test_details delete
   */
  export type referral_patient_test_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
    /**
     * Filter which referral_patient_test_details to delete.
     */
    where: referral_patient_test_detailsWhereUniqueInput
  }

  /**
   * referral_patient_test_details deleteMany
   */
  export type referral_patient_test_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_patient_test_details to delete
     */
    where?: referral_patient_test_detailsWhereInput
  }

  /**
   * referral_patient_test_details without action
   */
  export type referral_patient_test_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_patient_test_details
     */
    select?: referral_patient_test_detailsSelect<ExtArgs> | null
  }


  /**
   * Model relationship
   */

  export type AggregateRelationship = {
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  export type RelationshipAvgAggregateOutputType = {
    rel_id: number | null
    active: number | null
  }

  export type RelationshipSumAggregateOutputType = {
    rel_id: number | null
    active: number | null
  }

  export type RelationshipMinAggregateOutputType = {
    rel_id: number | null
    rel_name: string | null
    active: number | null
  }

  export type RelationshipMaxAggregateOutputType = {
    rel_id: number | null
    rel_name: string | null
    active: number | null
  }

  export type RelationshipCountAggregateOutputType = {
    rel_id: number
    rel_name: number
    active: number
    _all: number
  }


  export type RelationshipAvgAggregateInputType = {
    rel_id?: true
    active?: true
  }

  export type RelationshipSumAggregateInputType = {
    rel_id?: true
    active?: true
  }

  export type RelationshipMinAggregateInputType = {
    rel_id?: true
    rel_name?: true
    active?: true
  }

  export type RelationshipMaxAggregateInputType = {
    rel_id?: true
    rel_name?: true
    active?: true
  }

  export type RelationshipCountAggregateInputType = {
    rel_id?: true
    rel_name?: true
    active?: true
    _all?: true
  }

  export type RelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which relationship to aggregate.
     */
    where?: relationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relationships to fetch.
     */
    orderBy?: relationshipOrderByWithRelationInput | relationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: relationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned relationships
    **/
    _count?: true | RelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMaxAggregateInputType
  }

  export type GetRelationshipAggregateType<T extends RelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationship[P]>
      : GetScalarType<T[P], AggregateRelationship[P]>
  }




  export type relationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: relationshipWhereInput
    orderBy?: relationshipOrderByWithAggregationInput | relationshipOrderByWithAggregationInput[]
    by: RelationshipScalarFieldEnum[] | RelationshipScalarFieldEnum
    having?: relationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipCountAggregateInputType | true
    _avg?: RelationshipAvgAggregateInputType
    _sum?: RelationshipSumAggregateInputType
    _min?: RelationshipMinAggregateInputType
    _max?: RelationshipMaxAggregateInputType
  }

  export type RelationshipGroupByOutputType = {
    rel_id: number
    rel_name: string
    active: number
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  type GetRelationshipGroupByPayload<T extends relationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
        }
      >
    >


  export type relationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rel_id?: boolean
    rel_name?: boolean
    active?: boolean
  }, ExtArgs["result"]["relationship"]>


  export type relationshipSelectScalar = {
    rel_id?: boolean
    rel_name?: boolean
    active?: boolean
  }


  export type $relationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "relationship"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      rel_id: number
      rel_name: string
      active: number
    }, ExtArgs["result"]["relationship"]>
    composites: {}
  }

  type relationshipGetPayload<S extends boolean | null | undefined | relationshipDefaultArgs> = $Result.GetResult<Prisma.$relationshipPayload, S>

  type relationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<relationshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationshipCountAggregateInputType | true
    }

  export interface relationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['relationship'], meta: { name: 'relationship' } }
    /**
     * Find zero or one Relationship that matches the filter.
     * @param {relationshipFindUniqueArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends relationshipFindUniqueArgs>(args: SelectSubset<T, relationshipFindUniqueArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Relationship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {relationshipFindUniqueOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends relationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, relationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Relationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipFindFirstArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends relationshipFindFirstArgs>(args?: SelectSubset<T, relationshipFindFirstArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Relationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipFindFirstOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends relationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, relationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relationships
     * const relationships = await prisma.relationship.findMany()
     * 
     * // Get first 10 Relationships
     * const relationships = await prisma.relationship.findMany({ take: 10 })
     * 
     * // Only select the `rel_id`
     * const relationshipWithRel_idOnly = await prisma.relationship.findMany({ select: { rel_id: true } })
     * 
     */
    findMany<T extends relationshipFindManyArgs>(args?: SelectSubset<T, relationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Relationship.
     * @param {relationshipCreateArgs} args - Arguments to create a Relationship.
     * @example
     * // Create one Relationship
     * const Relationship = await prisma.relationship.create({
     *   data: {
     *     // ... data to create a Relationship
     *   }
     * })
     * 
     */
    create<T extends relationshipCreateArgs>(args: SelectSubset<T, relationshipCreateArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Relationships.
     * @param {relationshipCreateManyArgs} args - Arguments to create many Relationships.
     * @example
     * // Create many Relationships
     * const relationship = await prisma.relationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends relationshipCreateManyArgs>(args?: SelectSubset<T, relationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relationship.
     * @param {relationshipDeleteArgs} args - Arguments to delete one Relationship.
     * @example
     * // Delete one Relationship
     * const Relationship = await prisma.relationship.delete({
     *   where: {
     *     // ... filter to delete one Relationship
     *   }
     * })
     * 
     */
    delete<T extends relationshipDeleteArgs>(args: SelectSubset<T, relationshipDeleteArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Relationship.
     * @param {relationshipUpdateArgs} args - Arguments to update one Relationship.
     * @example
     * // Update one Relationship
     * const relationship = await prisma.relationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends relationshipUpdateArgs>(args: SelectSubset<T, relationshipUpdateArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Relationships.
     * @param {relationshipDeleteManyArgs} args - Arguments to filter Relationships to delete.
     * @example
     * // Delete a few Relationships
     * const { count } = await prisma.relationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends relationshipDeleteManyArgs>(args?: SelectSubset<T, relationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends relationshipUpdateManyArgs>(args: SelectSubset<T, relationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relationship.
     * @param {relationshipUpsertArgs} args - Arguments to update or create a Relationship.
     * @example
     * // Update or create a Relationship
     * const relationship = await prisma.relationship.upsert({
     *   create: {
     *     // ... data to create a Relationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relationship we want to update
     *   }
     * })
     */
    upsert<T extends relationshipUpsertArgs>(args: SelectSubset<T, relationshipUpsertArgs<ExtArgs>>): Prisma__relationshipClient<$Result.GetResult<Prisma.$relationshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipCountArgs} args - Arguments to filter Relationships to count.
     * @example
     * // Count the number of Relationships
     * const count = await prisma.relationship.count({
     *   where: {
     *     // ... the filter for the Relationships we want to count
     *   }
     * })
    **/
    count<T extends relationshipCountArgs>(
      args?: Subset<T, relationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipAggregateArgs>(args: Subset<T, RelationshipAggregateArgs>): Prisma.PrismaPromise<GetRelationshipAggregateType<T>>

    /**
     * Group by Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends relationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: relationshipGroupByArgs['orderBy'] }
        : { orderBy?: relationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, relationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the relationship model
   */
  readonly fields: relationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for relationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__relationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the relationship model
   */ 
  interface relationshipFieldRefs {
    readonly rel_id: FieldRef<"relationship", 'Int'>
    readonly rel_name: FieldRef<"relationship", 'String'>
    readonly active: FieldRef<"relationship", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * relationship findUnique
   */
  export type relationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter, which relationship to fetch.
     */
    where: relationshipWhereUniqueInput
  }

  /**
   * relationship findUniqueOrThrow
   */
  export type relationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter, which relationship to fetch.
     */
    where: relationshipWhereUniqueInput
  }

  /**
   * relationship findFirst
   */
  export type relationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter, which relationship to fetch.
     */
    where?: relationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relationships to fetch.
     */
    orderBy?: relationshipOrderByWithRelationInput | relationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relationships.
     */
    cursor?: relationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * relationship findFirstOrThrow
   */
  export type relationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter, which relationship to fetch.
     */
    where?: relationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relationships to fetch.
     */
    orderBy?: relationshipOrderByWithRelationInput | relationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relationships.
     */
    cursor?: relationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * relationship findMany
   */
  export type relationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter, which relationships to fetch.
     */
    where?: relationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relationships to fetch.
     */
    orderBy?: relationshipOrderByWithRelationInput | relationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing relationships.
     */
    cursor?: relationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relationships.
     */
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * relationship create
   */
  export type relationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * The data needed to create a relationship.
     */
    data: XOR<relationshipCreateInput, relationshipUncheckedCreateInput>
  }

  /**
   * relationship createMany
   */
  export type relationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many relationships.
     */
    data: relationshipCreateManyInput | relationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * relationship update
   */
  export type relationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * The data needed to update a relationship.
     */
    data: XOR<relationshipUpdateInput, relationshipUncheckedUpdateInput>
    /**
     * Choose, which relationship to update.
     */
    where: relationshipWhereUniqueInput
  }

  /**
   * relationship updateMany
   */
  export type relationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update relationships.
     */
    data: XOR<relationshipUpdateManyMutationInput, relationshipUncheckedUpdateManyInput>
    /**
     * Filter which relationships to update
     */
    where?: relationshipWhereInput
  }

  /**
   * relationship upsert
   */
  export type relationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * The filter to search for the relationship to update in case it exists.
     */
    where: relationshipWhereUniqueInput
    /**
     * In case the relationship found by the `where` argument doesn't exist, create a new relationship with this data.
     */
    create: XOR<relationshipCreateInput, relationshipUncheckedCreateInput>
    /**
     * In case the relationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<relationshipUpdateInput, relationshipUncheckedUpdateInput>
  }

  /**
   * relationship delete
   */
  export type relationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
    /**
     * Filter which relationship to delete.
     */
    where: relationshipWhereUniqueInput
  }

  /**
   * relationship deleteMany
   */
  export type relationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which relationships to delete
     */
    where?: relationshipWhereInput
  }

  /**
   * relationship without action
   */
  export type relationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the relationship
     */
    select?: relationshipSelect<ExtArgs> | null
  }


  /**
   * Model report_template
   */

  export type AggregateReport_template = {
    _count: Report_templateCountAggregateOutputType | null
    _avg: Report_templateAvgAggregateOutputType | null
    _sum: Report_templateSumAggregateOutputType | null
    _min: Report_templateMinAggregateOutputType | null
    _max: Report_templateMaxAggregateOutputType | null
  }

  export type Report_templateAvgAggregateOutputType = {
    template_id: number | null
    header: number | null
    footer: number | null
    print_size: number | null
    lab_id: number | null
  }

  export type Report_templateSumAggregateOutputType = {
    template_id: number | null
    header: number | null
    footer: number | null
    print_size: number | null
    lab_id: number | null
  }

  export type Report_templateMinAggregateOutputType = {
    template_id: number | null
    header: number | null
    footer: number | null
    print_size: number | null
    lab_id: number | null
    created_on: string | null
    status: string | null
  }

  export type Report_templateMaxAggregateOutputType = {
    template_id: number | null
    header: number | null
    footer: number | null
    print_size: number | null
    lab_id: number | null
    created_on: string | null
    status: string | null
  }

  export type Report_templateCountAggregateOutputType = {
    template_id: number
    header: number
    footer: number
    print_size: number
    lab_id: number
    created_on: number
    status: number
    _all: number
  }


  export type Report_templateAvgAggregateInputType = {
    template_id?: true
    header?: true
    footer?: true
    print_size?: true
    lab_id?: true
  }

  export type Report_templateSumAggregateInputType = {
    template_id?: true
    header?: true
    footer?: true
    print_size?: true
    lab_id?: true
  }

  export type Report_templateMinAggregateInputType = {
    template_id?: true
    header?: true
    footer?: true
    print_size?: true
    lab_id?: true
    created_on?: true
    status?: true
  }

  export type Report_templateMaxAggregateInputType = {
    template_id?: true
    header?: true
    footer?: true
    print_size?: true
    lab_id?: true
    created_on?: true
    status?: true
  }

  export type Report_templateCountAggregateInputType = {
    template_id?: true
    header?: true
    footer?: true
    print_size?: true
    lab_id?: true
    created_on?: true
    status?: true
    _all?: true
  }

  export type Report_templateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_template to aggregate.
     */
    where?: report_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_templates to fetch.
     */
    orderBy?: report_templateOrderByWithRelationInput | report_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: report_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned report_templates
    **/
    _count?: true | Report_templateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Report_templateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Report_templateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_templateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_templateMaxAggregateInputType
  }

  export type GetReport_templateAggregateType<T extends Report_templateAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_template]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_template[P]>
      : GetScalarType<T[P], AggregateReport_template[P]>
  }




  export type report_templateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_templateWhereInput
    orderBy?: report_templateOrderByWithAggregationInput | report_templateOrderByWithAggregationInput[]
    by: Report_templateScalarFieldEnum[] | Report_templateScalarFieldEnum
    having?: report_templateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_templateCountAggregateInputType | true
    _avg?: Report_templateAvgAggregateInputType
    _sum?: Report_templateSumAggregateInputType
    _min?: Report_templateMinAggregateInputType
    _max?: Report_templateMaxAggregateInputType
  }

  export type Report_templateGroupByOutputType = {
    template_id: number
    header: number
    footer: number
    print_size: number
    lab_id: number
    created_on: string
    status: string
    _count: Report_templateCountAggregateOutputType | null
    _avg: Report_templateAvgAggregateOutputType | null
    _sum: Report_templateSumAggregateOutputType | null
    _min: Report_templateMinAggregateOutputType | null
    _max: Report_templateMaxAggregateOutputType | null
  }

  type GetReport_templateGroupByPayload<T extends report_templateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Report_templateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_templateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_templateGroupByOutputType[P]>
            : GetScalarType<T[P], Report_templateGroupByOutputType[P]>
        }
      >
    >


  export type report_templateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    template_id?: boolean
    header?: boolean
    footer?: boolean
    print_size?: boolean
    lab_id?: boolean
    created_on?: boolean
    status?: boolean
  }, ExtArgs["result"]["report_template"]>


  export type report_templateSelectScalar = {
    template_id?: boolean
    header?: boolean
    footer?: boolean
    print_size?: boolean
    lab_id?: boolean
    created_on?: boolean
    status?: boolean
  }


  export type $report_templatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report_template"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      template_id: number
      header: number
      footer: number
      print_size: number
      lab_id: number
      created_on: string
      status: string
    }, ExtArgs["result"]["report_template"]>
    composites: {}
  }

  type report_templateGetPayload<S extends boolean | null | undefined | report_templateDefaultArgs> = $Result.GetResult<Prisma.$report_templatePayload, S>

  type report_templateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<report_templateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Report_templateCountAggregateInputType | true
    }

  export interface report_templateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report_template'], meta: { name: 'report_template' } }
    /**
     * Find zero or one Report_template that matches the filter.
     * @param {report_templateFindUniqueArgs} args - Arguments to find a Report_template
     * @example
     * // Get one Report_template
     * const report_template = await prisma.report_template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends report_templateFindUniqueArgs>(args: SelectSubset<T, report_templateFindUniqueArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report_template that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {report_templateFindUniqueOrThrowArgs} args - Arguments to find a Report_template
     * @example
     * // Get one Report_template
     * const report_template = await prisma.report_template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends report_templateFindUniqueOrThrowArgs>(args: SelectSubset<T, report_templateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report_template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateFindFirstArgs} args - Arguments to find a Report_template
     * @example
     * // Get one Report_template
     * const report_template = await prisma.report_template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends report_templateFindFirstArgs>(args?: SelectSubset<T, report_templateFindFirstArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report_template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateFindFirstOrThrowArgs} args - Arguments to find a Report_template
     * @example
     * // Get one Report_template
     * const report_template = await prisma.report_template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends report_templateFindFirstOrThrowArgs>(args?: SelectSubset<T, report_templateFindFirstOrThrowArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Report_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_templates
     * const report_templates = await prisma.report_template.findMany()
     * 
     * // Get first 10 Report_templates
     * const report_templates = await prisma.report_template.findMany({ take: 10 })
     * 
     * // Only select the `template_id`
     * const report_templateWithTemplate_idOnly = await prisma.report_template.findMany({ select: { template_id: true } })
     * 
     */
    findMany<T extends report_templateFindManyArgs>(args?: SelectSubset<T, report_templateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report_template.
     * @param {report_templateCreateArgs} args - Arguments to create a Report_template.
     * @example
     * // Create one Report_template
     * const Report_template = await prisma.report_template.create({
     *   data: {
     *     // ... data to create a Report_template
     *   }
     * })
     * 
     */
    create<T extends report_templateCreateArgs>(args: SelectSubset<T, report_templateCreateArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Report_templates.
     * @param {report_templateCreateManyArgs} args - Arguments to create many Report_templates.
     * @example
     * // Create many Report_templates
     * const report_template = await prisma.report_template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends report_templateCreateManyArgs>(args?: SelectSubset<T, report_templateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report_template.
     * @param {report_templateDeleteArgs} args - Arguments to delete one Report_template.
     * @example
     * // Delete one Report_template
     * const Report_template = await prisma.report_template.delete({
     *   where: {
     *     // ... filter to delete one Report_template
     *   }
     * })
     * 
     */
    delete<T extends report_templateDeleteArgs>(args: SelectSubset<T, report_templateDeleteArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report_template.
     * @param {report_templateUpdateArgs} args - Arguments to update one Report_template.
     * @example
     * // Update one Report_template
     * const report_template = await prisma.report_template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends report_templateUpdateArgs>(args: SelectSubset<T, report_templateUpdateArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Report_templates.
     * @param {report_templateDeleteManyArgs} args - Arguments to filter Report_templates to delete.
     * @example
     * // Delete a few Report_templates
     * const { count } = await prisma.report_template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends report_templateDeleteManyArgs>(args?: SelectSubset<T, report_templateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_templates
     * const report_template = await prisma.report_template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends report_templateUpdateManyArgs>(args: SelectSubset<T, report_templateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report_template.
     * @param {report_templateUpsertArgs} args - Arguments to update or create a Report_template.
     * @example
     * // Update or create a Report_template
     * const report_template = await prisma.report_template.upsert({
     *   create: {
     *     // ... data to create a Report_template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_template we want to update
     *   }
     * })
     */
    upsert<T extends report_templateUpsertArgs>(args: SelectSubset<T, report_templateUpsertArgs<ExtArgs>>): Prisma__report_templateClient<$Result.GetResult<Prisma.$report_templatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Report_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateCountArgs} args - Arguments to filter Report_templates to count.
     * @example
     * // Count the number of Report_templates
     * const count = await prisma.report_template.count({
     *   where: {
     *     // ... the filter for the Report_templates we want to count
     *   }
     * })
    **/
    count<T extends report_templateCountArgs>(
      args?: Subset<T, report_templateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_templateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_templateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_templateAggregateArgs>(args: Subset<T, Report_templateAggregateArgs>): Prisma.PrismaPromise<GetReport_templateAggregateType<T>>

    /**
     * Group by Report_template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_templateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends report_templateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: report_templateGroupByArgs['orderBy'] }
        : { orderBy?: report_templateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, report_templateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_templateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report_template model
   */
  readonly fields: report_templateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report_template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__report_templateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report_template model
   */ 
  interface report_templateFieldRefs {
    readonly template_id: FieldRef<"report_template", 'Int'>
    readonly header: FieldRef<"report_template", 'Int'>
    readonly footer: FieldRef<"report_template", 'Int'>
    readonly print_size: FieldRef<"report_template", 'Int'>
    readonly lab_id: FieldRef<"report_template", 'Int'>
    readonly created_on: FieldRef<"report_template", 'String'>
    readonly status: FieldRef<"report_template", 'String'>
  }
    

  // Custom InputTypes
  /**
   * report_template findUnique
   */
  export type report_templateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter, which report_template to fetch.
     */
    where: report_templateWhereUniqueInput
  }

  /**
   * report_template findUniqueOrThrow
   */
  export type report_templateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter, which report_template to fetch.
     */
    where: report_templateWhereUniqueInput
  }

  /**
   * report_template findFirst
   */
  export type report_templateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter, which report_template to fetch.
     */
    where?: report_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_templates to fetch.
     */
    orderBy?: report_templateOrderByWithRelationInput | report_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_templates.
     */
    cursor?: report_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_templates.
     */
    distinct?: Report_templateScalarFieldEnum | Report_templateScalarFieldEnum[]
  }

  /**
   * report_template findFirstOrThrow
   */
  export type report_templateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter, which report_template to fetch.
     */
    where?: report_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_templates to fetch.
     */
    orderBy?: report_templateOrderByWithRelationInput | report_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_templates.
     */
    cursor?: report_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_templates.
     */
    distinct?: Report_templateScalarFieldEnum | Report_templateScalarFieldEnum[]
  }

  /**
   * report_template findMany
   */
  export type report_templateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter, which report_templates to fetch.
     */
    where?: report_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_templates to fetch.
     */
    orderBy?: report_templateOrderByWithRelationInput | report_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing report_templates.
     */
    cursor?: report_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_templates.
     */
    skip?: number
    distinct?: Report_templateScalarFieldEnum | Report_templateScalarFieldEnum[]
  }

  /**
   * report_template create
   */
  export type report_templateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * The data needed to create a report_template.
     */
    data: XOR<report_templateCreateInput, report_templateUncheckedCreateInput>
  }

  /**
   * report_template createMany
   */
  export type report_templateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many report_templates.
     */
    data: report_templateCreateManyInput | report_templateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report_template update
   */
  export type report_templateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * The data needed to update a report_template.
     */
    data: XOR<report_templateUpdateInput, report_templateUncheckedUpdateInput>
    /**
     * Choose, which report_template to update.
     */
    where: report_templateWhereUniqueInput
  }

  /**
   * report_template updateMany
   */
  export type report_templateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update report_templates.
     */
    data: XOR<report_templateUpdateManyMutationInput, report_templateUncheckedUpdateManyInput>
    /**
     * Filter which report_templates to update
     */
    where?: report_templateWhereInput
  }

  /**
   * report_template upsert
   */
  export type report_templateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * The filter to search for the report_template to update in case it exists.
     */
    where: report_templateWhereUniqueInput
    /**
     * In case the report_template found by the `where` argument doesn't exist, create a new report_template with this data.
     */
    create: XOR<report_templateCreateInput, report_templateUncheckedCreateInput>
    /**
     * In case the report_template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<report_templateUpdateInput, report_templateUncheckedUpdateInput>
  }

  /**
   * report_template delete
   */
  export type report_templateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
    /**
     * Filter which report_template to delete.
     */
    where: report_templateWhereUniqueInput
  }

  /**
   * report_template deleteMany
   */
  export type report_templateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_templates to delete
     */
    where?: report_templateWhereInput
  }

  /**
   * report_template without action
   */
  export type report_templateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_template
     */
    select?: report_templateSelect<ExtArgs> | null
  }


  /**
   * Model sample_results
   */

  export type AggregateSample_results = {
    _count: Sample_resultsCountAggregateOutputType | null
    _avg: Sample_resultsAvgAggregateOutputType | null
    _sum: Sample_resultsSumAggregateOutputType | null
    _min: Sample_resultsMinAggregateOutputType | null
    _max: Sample_resultsMaxAggregateOutputType | null
  }

  export type Sample_resultsAvgAggregateOutputType = {
    result_id: number | null
    referral_test_ID: number | null
  }

  export type Sample_resultsSumAggregateOutputType = {
    result_id: number | null
    referral_test_ID: number | null
  }

  export type Sample_resultsMinAggregateOutputType = {
    result_id: number | null
    sample_value: string | null
    referral_test_ID: number | null
    created_on: Date | null
  }

  export type Sample_resultsMaxAggregateOutputType = {
    result_id: number | null
    sample_value: string | null
    referral_test_ID: number | null
    created_on: Date | null
  }

  export type Sample_resultsCountAggregateOutputType = {
    result_id: number
    sample_value: number
    referral_test_ID: number
    created_on: number
    _all: number
  }


  export type Sample_resultsAvgAggregateInputType = {
    result_id?: true
    referral_test_ID?: true
  }

  export type Sample_resultsSumAggregateInputType = {
    result_id?: true
    referral_test_ID?: true
  }

  export type Sample_resultsMinAggregateInputType = {
    result_id?: true
    sample_value?: true
    referral_test_ID?: true
    created_on?: true
  }

  export type Sample_resultsMaxAggregateInputType = {
    result_id?: true
    sample_value?: true
    referral_test_ID?: true
    created_on?: true
  }

  export type Sample_resultsCountAggregateInputType = {
    result_id?: true
    sample_value?: true
    referral_test_ID?: true
    created_on?: true
    _all?: true
  }

  export type Sample_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sample_results to aggregate.
     */
    where?: sample_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sample_results to fetch.
     */
    orderBy?: sample_resultsOrderByWithRelationInput | sample_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sample_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sample_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sample_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sample_results
    **/
    _count?: true | Sample_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sample_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sample_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sample_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sample_resultsMaxAggregateInputType
  }

  export type GetSample_resultsAggregateType<T extends Sample_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateSample_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSample_results[P]>
      : GetScalarType<T[P], AggregateSample_results[P]>
  }




  export type sample_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sample_resultsWhereInput
    orderBy?: sample_resultsOrderByWithAggregationInput | sample_resultsOrderByWithAggregationInput[]
    by: Sample_resultsScalarFieldEnum[] | Sample_resultsScalarFieldEnum
    having?: sample_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sample_resultsCountAggregateInputType | true
    _avg?: Sample_resultsAvgAggregateInputType
    _sum?: Sample_resultsSumAggregateInputType
    _min?: Sample_resultsMinAggregateInputType
    _max?: Sample_resultsMaxAggregateInputType
  }

  export type Sample_resultsGroupByOutputType = {
    result_id: number
    sample_value: string
    referral_test_ID: number
    created_on: Date
    _count: Sample_resultsCountAggregateOutputType | null
    _avg: Sample_resultsAvgAggregateOutputType | null
    _sum: Sample_resultsSumAggregateOutputType | null
    _min: Sample_resultsMinAggregateOutputType | null
    _max: Sample_resultsMaxAggregateOutputType | null
  }

  type GetSample_resultsGroupByPayload<T extends sample_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sample_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sample_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sample_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Sample_resultsGroupByOutputType[P]>
        }
      >
    >


  export type sample_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    result_id?: boolean
    sample_value?: boolean
    referral_test_ID?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["sample_results"]>


  export type sample_resultsSelectScalar = {
    result_id?: boolean
    sample_value?: boolean
    referral_test_ID?: boolean
    created_on?: boolean
  }


  export type $sample_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sample_results"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      result_id: number
      sample_value: string
      referral_test_ID: number
      created_on: Date
    }, ExtArgs["result"]["sample_results"]>
    composites: {}
  }

  type sample_resultsGetPayload<S extends boolean | null | undefined | sample_resultsDefaultArgs> = $Result.GetResult<Prisma.$sample_resultsPayload, S>

  type sample_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sample_resultsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sample_resultsCountAggregateInputType | true
    }

  export interface sample_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sample_results'], meta: { name: 'sample_results' } }
    /**
     * Find zero or one Sample_results that matches the filter.
     * @param {sample_resultsFindUniqueArgs} args - Arguments to find a Sample_results
     * @example
     * // Get one Sample_results
     * const sample_results = await prisma.sample_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sample_resultsFindUniqueArgs>(args: SelectSubset<T, sample_resultsFindUniqueArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sample_results that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sample_resultsFindUniqueOrThrowArgs} args - Arguments to find a Sample_results
     * @example
     * // Get one Sample_results
     * const sample_results = await prisma.sample_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sample_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, sample_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sample_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsFindFirstArgs} args - Arguments to find a Sample_results
     * @example
     * // Get one Sample_results
     * const sample_results = await prisma.sample_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sample_resultsFindFirstArgs>(args?: SelectSubset<T, sample_resultsFindFirstArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sample_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsFindFirstOrThrowArgs} args - Arguments to find a Sample_results
     * @example
     * // Get one Sample_results
     * const sample_results = await prisma.sample_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sample_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, sample_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sample_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sample_results
     * const sample_results = await prisma.sample_results.findMany()
     * 
     * // Get first 10 Sample_results
     * const sample_results = await prisma.sample_results.findMany({ take: 10 })
     * 
     * // Only select the `result_id`
     * const sample_resultsWithResult_idOnly = await prisma.sample_results.findMany({ select: { result_id: true } })
     * 
     */
    findMany<T extends sample_resultsFindManyArgs>(args?: SelectSubset<T, sample_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sample_results.
     * @param {sample_resultsCreateArgs} args - Arguments to create a Sample_results.
     * @example
     * // Create one Sample_results
     * const Sample_results = await prisma.sample_results.create({
     *   data: {
     *     // ... data to create a Sample_results
     *   }
     * })
     * 
     */
    create<T extends sample_resultsCreateArgs>(args: SelectSubset<T, sample_resultsCreateArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sample_results.
     * @param {sample_resultsCreateManyArgs} args - Arguments to create many Sample_results.
     * @example
     * // Create many Sample_results
     * const sample_results = await prisma.sample_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sample_resultsCreateManyArgs>(args?: SelectSubset<T, sample_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sample_results.
     * @param {sample_resultsDeleteArgs} args - Arguments to delete one Sample_results.
     * @example
     * // Delete one Sample_results
     * const Sample_results = await prisma.sample_results.delete({
     *   where: {
     *     // ... filter to delete one Sample_results
     *   }
     * })
     * 
     */
    delete<T extends sample_resultsDeleteArgs>(args: SelectSubset<T, sample_resultsDeleteArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sample_results.
     * @param {sample_resultsUpdateArgs} args - Arguments to update one Sample_results.
     * @example
     * // Update one Sample_results
     * const sample_results = await prisma.sample_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sample_resultsUpdateArgs>(args: SelectSubset<T, sample_resultsUpdateArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sample_results.
     * @param {sample_resultsDeleteManyArgs} args - Arguments to filter Sample_results to delete.
     * @example
     * // Delete a few Sample_results
     * const { count } = await prisma.sample_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sample_resultsDeleteManyArgs>(args?: SelectSubset<T, sample_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sample_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sample_results
     * const sample_results = await prisma.sample_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sample_resultsUpdateManyArgs>(args: SelectSubset<T, sample_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sample_results.
     * @param {sample_resultsUpsertArgs} args - Arguments to update or create a Sample_results.
     * @example
     * // Update or create a Sample_results
     * const sample_results = await prisma.sample_results.upsert({
     *   create: {
     *     // ... data to create a Sample_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sample_results we want to update
     *   }
     * })
     */
    upsert<T extends sample_resultsUpsertArgs>(args: SelectSubset<T, sample_resultsUpsertArgs<ExtArgs>>): Prisma__sample_resultsClient<$Result.GetResult<Prisma.$sample_resultsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sample_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsCountArgs} args - Arguments to filter Sample_results to count.
     * @example
     * // Count the number of Sample_results
     * const count = await prisma.sample_results.count({
     *   where: {
     *     // ... the filter for the Sample_results we want to count
     *   }
     * })
    **/
    count<T extends sample_resultsCountArgs>(
      args?: Subset<T, sample_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sample_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sample_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sample_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sample_resultsAggregateArgs>(args: Subset<T, Sample_resultsAggregateArgs>): Prisma.PrismaPromise<GetSample_resultsAggregateType<T>>

    /**
     * Group by Sample_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sample_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sample_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sample_resultsGroupByArgs['orderBy'] }
        : { orderBy?: sample_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sample_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSample_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sample_results model
   */
  readonly fields: sample_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sample_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sample_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sample_results model
   */ 
  interface sample_resultsFieldRefs {
    readonly result_id: FieldRef<"sample_results", 'Int'>
    readonly sample_value: FieldRef<"sample_results", 'String'>
    readonly referral_test_ID: FieldRef<"sample_results", 'Int'>
    readonly created_on: FieldRef<"sample_results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sample_results findUnique
   */
  export type sample_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter, which sample_results to fetch.
     */
    where: sample_resultsWhereUniqueInput
  }

  /**
   * sample_results findUniqueOrThrow
   */
  export type sample_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter, which sample_results to fetch.
     */
    where: sample_resultsWhereUniqueInput
  }

  /**
   * sample_results findFirst
   */
  export type sample_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter, which sample_results to fetch.
     */
    where?: sample_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sample_results to fetch.
     */
    orderBy?: sample_resultsOrderByWithRelationInput | sample_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sample_results.
     */
    cursor?: sample_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sample_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sample_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sample_results.
     */
    distinct?: Sample_resultsScalarFieldEnum | Sample_resultsScalarFieldEnum[]
  }

  /**
   * sample_results findFirstOrThrow
   */
  export type sample_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter, which sample_results to fetch.
     */
    where?: sample_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sample_results to fetch.
     */
    orderBy?: sample_resultsOrderByWithRelationInput | sample_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sample_results.
     */
    cursor?: sample_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sample_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sample_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sample_results.
     */
    distinct?: Sample_resultsScalarFieldEnum | Sample_resultsScalarFieldEnum[]
  }

  /**
   * sample_results findMany
   */
  export type sample_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter, which sample_results to fetch.
     */
    where?: sample_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sample_results to fetch.
     */
    orderBy?: sample_resultsOrderByWithRelationInput | sample_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sample_results.
     */
    cursor?: sample_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sample_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sample_results.
     */
    skip?: number
    distinct?: Sample_resultsScalarFieldEnum | Sample_resultsScalarFieldEnum[]
  }

  /**
   * sample_results create
   */
  export type sample_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * The data needed to create a sample_results.
     */
    data: XOR<sample_resultsCreateInput, sample_resultsUncheckedCreateInput>
  }

  /**
   * sample_results createMany
   */
  export type sample_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sample_results.
     */
    data: sample_resultsCreateManyInput | sample_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sample_results update
   */
  export type sample_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * The data needed to update a sample_results.
     */
    data: XOR<sample_resultsUpdateInput, sample_resultsUncheckedUpdateInput>
    /**
     * Choose, which sample_results to update.
     */
    where: sample_resultsWhereUniqueInput
  }

  /**
   * sample_results updateMany
   */
  export type sample_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sample_results.
     */
    data: XOR<sample_resultsUpdateManyMutationInput, sample_resultsUncheckedUpdateManyInput>
    /**
     * Filter which sample_results to update
     */
    where?: sample_resultsWhereInput
  }

  /**
   * sample_results upsert
   */
  export type sample_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * The filter to search for the sample_results to update in case it exists.
     */
    where: sample_resultsWhereUniqueInput
    /**
     * In case the sample_results found by the `where` argument doesn't exist, create a new sample_results with this data.
     */
    create: XOR<sample_resultsCreateInput, sample_resultsUncheckedCreateInput>
    /**
     * In case the sample_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sample_resultsUpdateInput, sample_resultsUncheckedUpdateInput>
  }

  /**
   * sample_results delete
   */
  export type sample_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
    /**
     * Filter which sample_results to delete.
     */
    where: sample_resultsWhereUniqueInput
  }

  /**
   * sample_results deleteMany
   */
  export type sample_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sample_results to delete
     */
    where?: sample_resultsWhereInput
  }

  /**
   * sample_results without action
   */
  export type sample_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sample_results
     */
    select?: sample_resultsSelect<ExtArgs> | null
  }


  /**
   * Model ssconsultation_billing
   */

  export type AggregateSsconsultation_billing = {
    _count: Ssconsultation_billingCountAggregateOutputType | null
    _avg: Ssconsultation_billingAvgAggregateOutputType | null
    _sum: Ssconsultation_billingSumAggregateOutputType | null
    _min: Ssconsultation_billingMinAggregateOutputType | null
    _max: Ssconsultation_billingMaxAggregateOutputType | null
  }

  export type Ssconsultation_billingAvgAggregateOutputType = {
    ssbilling_id: number | null
    ss_id: number | null
    lab_id: number | null
  }

  export type Ssconsultation_billingSumAggregateOutputType = {
    ssbilling_id: number | null
    ss_id: number | null
    lab_id: number | null
  }

  export type Ssconsultation_billingMinAggregateOutputType = {
    ssbilling_id: number | null
    ss_id: number | null
    tot_amt: string | null
    lab_id: number | null
    unique_billid: string | null
    created_on: string | null
  }

  export type Ssconsultation_billingMaxAggregateOutputType = {
    ssbilling_id: number | null
    ss_id: number | null
    tot_amt: string | null
    lab_id: number | null
    unique_billid: string | null
    created_on: string | null
  }

  export type Ssconsultation_billingCountAggregateOutputType = {
    ssbilling_id: number
    ss_id: number
    tot_amt: number
    lab_id: number
    unique_billid: number
    created_on: number
    _all: number
  }


  export type Ssconsultation_billingAvgAggregateInputType = {
    ssbilling_id?: true
    ss_id?: true
    lab_id?: true
  }

  export type Ssconsultation_billingSumAggregateInputType = {
    ssbilling_id?: true
    ss_id?: true
    lab_id?: true
  }

  export type Ssconsultation_billingMinAggregateInputType = {
    ssbilling_id?: true
    ss_id?: true
    tot_amt?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
  }

  export type Ssconsultation_billingMaxAggregateInputType = {
    ssbilling_id?: true
    ss_id?: true
    tot_amt?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
  }

  export type Ssconsultation_billingCountAggregateInputType = {
    ssbilling_id?: true
    ss_id?: true
    tot_amt?: true
    lab_id?: true
    unique_billid?: true
    created_on?: true
    _all?: true
  }

  export type Ssconsultation_billingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ssconsultation_billing to aggregate.
     */
    where?: ssconsultation_billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_billings to fetch.
     */
    orderBy?: ssconsultation_billingOrderByWithRelationInput | ssconsultation_billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ssconsultation_billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ssconsultation_billings
    **/
    _count?: true | Ssconsultation_billingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ssconsultation_billingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ssconsultation_billingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ssconsultation_billingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ssconsultation_billingMaxAggregateInputType
  }

  export type GetSsconsultation_billingAggregateType<T extends Ssconsultation_billingAggregateArgs> = {
        [P in keyof T & keyof AggregateSsconsultation_billing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSsconsultation_billing[P]>
      : GetScalarType<T[P], AggregateSsconsultation_billing[P]>
  }




  export type ssconsultation_billingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ssconsultation_billingWhereInput
    orderBy?: ssconsultation_billingOrderByWithAggregationInput | ssconsultation_billingOrderByWithAggregationInput[]
    by: Ssconsultation_billingScalarFieldEnum[] | Ssconsultation_billingScalarFieldEnum
    having?: ssconsultation_billingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ssconsultation_billingCountAggregateInputType | true
    _avg?: Ssconsultation_billingAvgAggregateInputType
    _sum?: Ssconsultation_billingSumAggregateInputType
    _min?: Ssconsultation_billingMinAggregateInputType
    _max?: Ssconsultation_billingMaxAggregateInputType
  }

  export type Ssconsultation_billingGroupByOutputType = {
    ssbilling_id: number
    ss_id: number
    tot_amt: string | null
    lab_id: number
    unique_billid: string
    created_on: string | null
    _count: Ssconsultation_billingCountAggregateOutputType | null
    _avg: Ssconsultation_billingAvgAggregateOutputType | null
    _sum: Ssconsultation_billingSumAggregateOutputType | null
    _min: Ssconsultation_billingMinAggregateOutputType | null
    _max: Ssconsultation_billingMaxAggregateOutputType | null
  }

  type GetSsconsultation_billingGroupByPayload<T extends ssconsultation_billingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ssconsultation_billingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ssconsultation_billingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ssconsultation_billingGroupByOutputType[P]>
            : GetScalarType<T[P], Ssconsultation_billingGroupByOutputType[P]>
        }
      >
    >


  export type ssconsultation_billingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ssbilling_id?: boolean
    ss_id?: boolean
    tot_amt?: boolean
    lab_id?: boolean
    unique_billid?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["ssconsultation_billing"]>


  export type ssconsultation_billingSelectScalar = {
    ssbilling_id?: boolean
    ss_id?: boolean
    tot_amt?: boolean
    lab_id?: boolean
    unique_billid?: boolean
    created_on?: boolean
  }


  export type $ssconsultation_billingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ssconsultation_billing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ssbilling_id: number
      ss_id: number
      tot_amt: string | null
      lab_id: number
      unique_billid: string
      created_on: string | null
    }, ExtArgs["result"]["ssconsultation_billing"]>
    composites: {}
  }

  type ssconsultation_billingGetPayload<S extends boolean | null | undefined | ssconsultation_billingDefaultArgs> = $Result.GetResult<Prisma.$ssconsultation_billingPayload, S>

  type ssconsultation_billingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ssconsultation_billingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ssconsultation_billingCountAggregateInputType | true
    }

  export interface ssconsultation_billingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ssconsultation_billing'], meta: { name: 'ssconsultation_billing' } }
    /**
     * Find zero or one Ssconsultation_billing that matches the filter.
     * @param {ssconsultation_billingFindUniqueArgs} args - Arguments to find a Ssconsultation_billing
     * @example
     * // Get one Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ssconsultation_billingFindUniqueArgs>(args: SelectSubset<T, ssconsultation_billingFindUniqueArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ssconsultation_billing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ssconsultation_billingFindUniqueOrThrowArgs} args - Arguments to find a Ssconsultation_billing
     * @example
     * // Get one Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ssconsultation_billingFindUniqueOrThrowArgs>(args: SelectSubset<T, ssconsultation_billingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ssconsultation_billing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingFindFirstArgs} args - Arguments to find a Ssconsultation_billing
     * @example
     * // Get one Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ssconsultation_billingFindFirstArgs>(args?: SelectSubset<T, ssconsultation_billingFindFirstArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ssconsultation_billing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingFindFirstOrThrowArgs} args - Arguments to find a Ssconsultation_billing
     * @example
     * // Get one Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ssconsultation_billingFindFirstOrThrowArgs>(args?: SelectSubset<T, ssconsultation_billingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ssconsultation_billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ssconsultation_billings
     * const ssconsultation_billings = await prisma.ssconsultation_billing.findMany()
     * 
     * // Get first 10 Ssconsultation_billings
     * const ssconsultation_billings = await prisma.ssconsultation_billing.findMany({ take: 10 })
     * 
     * // Only select the `ssbilling_id`
     * const ssconsultation_billingWithSsbilling_idOnly = await prisma.ssconsultation_billing.findMany({ select: { ssbilling_id: true } })
     * 
     */
    findMany<T extends ssconsultation_billingFindManyArgs>(args?: SelectSubset<T, ssconsultation_billingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ssconsultation_billing.
     * @param {ssconsultation_billingCreateArgs} args - Arguments to create a Ssconsultation_billing.
     * @example
     * // Create one Ssconsultation_billing
     * const Ssconsultation_billing = await prisma.ssconsultation_billing.create({
     *   data: {
     *     // ... data to create a Ssconsultation_billing
     *   }
     * })
     * 
     */
    create<T extends ssconsultation_billingCreateArgs>(args: SelectSubset<T, ssconsultation_billingCreateArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ssconsultation_billings.
     * @param {ssconsultation_billingCreateManyArgs} args - Arguments to create many Ssconsultation_billings.
     * @example
     * // Create many Ssconsultation_billings
     * const ssconsultation_billing = await prisma.ssconsultation_billing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ssconsultation_billingCreateManyArgs>(args?: SelectSubset<T, ssconsultation_billingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ssconsultation_billing.
     * @param {ssconsultation_billingDeleteArgs} args - Arguments to delete one Ssconsultation_billing.
     * @example
     * // Delete one Ssconsultation_billing
     * const Ssconsultation_billing = await prisma.ssconsultation_billing.delete({
     *   where: {
     *     // ... filter to delete one Ssconsultation_billing
     *   }
     * })
     * 
     */
    delete<T extends ssconsultation_billingDeleteArgs>(args: SelectSubset<T, ssconsultation_billingDeleteArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ssconsultation_billing.
     * @param {ssconsultation_billingUpdateArgs} args - Arguments to update one Ssconsultation_billing.
     * @example
     * // Update one Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ssconsultation_billingUpdateArgs>(args: SelectSubset<T, ssconsultation_billingUpdateArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ssconsultation_billings.
     * @param {ssconsultation_billingDeleteManyArgs} args - Arguments to filter Ssconsultation_billings to delete.
     * @example
     * // Delete a few Ssconsultation_billings
     * const { count } = await prisma.ssconsultation_billing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ssconsultation_billingDeleteManyArgs>(args?: SelectSubset<T, ssconsultation_billingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ssconsultation_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ssconsultation_billings
     * const ssconsultation_billing = await prisma.ssconsultation_billing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ssconsultation_billingUpdateManyArgs>(args: SelectSubset<T, ssconsultation_billingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ssconsultation_billing.
     * @param {ssconsultation_billingUpsertArgs} args - Arguments to update or create a Ssconsultation_billing.
     * @example
     * // Update or create a Ssconsultation_billing
     * const ssconsultation_billing = await prisma.ssconsultation_billing.upsert({
     *   create: {
     *     // ... data to create a Ssconsultation_billing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ssconsultation_billing we want to update
     *   }
     * })
     */
    upsert<T extends ssconsultation_billingUpsertArgs>(args: SelectSubset<T, ssconsultation_billingUpsertArgs<ExtArgs>>): Prisma__ssconsultation_billingClient<$Result.GetResult<Prisma.$ssconsultation_billingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ssconsultation_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingCountArgs} args - Arguments to filter Ssconsultation_billings to count.
     * @example
     * // Count the number of Ssconsultation_billings
     * const count = await prisma.ssconsultation_billing.count({
     *   where: {
     *     // ... the filter for the Ssconsultation_billings we want to count
     *   }
     * })
    **/
    count<T extends ssconsultation_billingCountArgs>(
      args?: Subset<T, ssconsultation_billingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ssconsultation_billingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ssconsultation_billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ssconsultation_billingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ssconsultation_billingAggregateArgs>(args: Subset<T, Ssconsultation_billingAggregateArgs>): Prisma.PrismaPromise<GetSsconsultation_billingAggregateType<T>>

    /**
     * Group by Ssconsultation_billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_billingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ssconsultation_billingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ssconsultation_billingGroupByArgs['orderBy'] }
        : { orderBy?: ssconsultation_billingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ssconsultation_billingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSsconsultation_billingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ssconsultation_billing model
   */
  readonly fields: ssconsultation_billingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ssconsultation_billing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ssconsultation_billingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ssconsultation_billing model
   */ 
  interface ssconsultation_billingFieldRefs {
    readonly ssbilling_id: FieldRef<"ssconsultation_billing", 'Int'>
    readonly ss_id: FieldRef<"ssconsultation_billing", 'Int'>
    readonly tot_amt: FieldRef<"ssconsultation_billing", 'String'>
    readonly lab_id: FieldRef<"ssconsultation_billing", 'Int'>
    readonly unique_billid: FieldRef<"ssconsultation_billing", 'String'>
    readonly created_on: FieldRef<"ssconsultation_billing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ssconsultation_billing findUnique
   */
  export type ssconsultation_billingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_billing to fetch.
     */
    where: ssconsultation_billingWhereUniqueInput
  }

  /**
   * ssconsultation_billing findUniqueOrThrow
   */
  export type ssconsultation_billingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_billing to fetch.
     */
    where: ssconsultation_billingWhereUniqueInput
  }

  /**
   * ssconsultation_billing findFirst
   */
  export type ssconsultation_billingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_billing to fetch.
     */
    where?: ssconsultation_billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_billings to fetch.
     */
    orderBy?: ssconsultation_billingOrderByWithRelationInput | ssconsultation_billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ssconsultation_billings.
     */
    cursor?: ssconsultation_billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ssconsultation_billings.
     */
    distinct?: Ssconsultation_billingScalarFieldEnum | Ssconsultation_billingScalarFieldEnum[]
  }

  /**
   * ssconsultation_billing findFirstOrThrow
   */
  export type ssconsultation_billingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_billing to fetch.
     */
    where?: ssconsultation_billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_billings to fetch.
     */
    orderBy?: ssconsultation_billingOrderByWithRelationInput | ssconsultation_billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ssconsultation_billings.
     */
    cursor?: ssconsultation_billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ssconsultation_billings.
     */
    distinct?: Ssconsultation_billingScalarFieldEnum | Ssconsultation_billingScalarFieldEnum[]
  }

  /**
   * ssconsultation_billing findMany
   */
  export type ssconsultation_billingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_billings to fetch.
     */
    where?: ssconsultation_billingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_billings to fetch.
     */
    orderBy?: ssconsultation_billingOrderByWithRelationInput | ssconsultation_billingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ssconsultation_billings.
     */
    cursor?: ssconsultation_billingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_billings.
     */
    skip?: number
    distinct?: Ssconsultation_billingScalarFieldEnum | Ssconsultation_billingScalarFieldEnum[]
  }

  /**
   * ssconsultation_billing create
   */
  export type ssconsultation_billingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * The data needed to create a ssconsultation_billing.
     */
    data: XOR<ssconsultation_billingCreateInput, ssconsultation_billingUncheckedCreateInput>
  }

  /**
   * ssconsultation_billing createMany
   */
  export type ssconsultation_billingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ssconsultation_billings.
     */
    data: ssconsultation_billingCreateManyInput | ssconsultation_billingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ssconsultation_billing update
   */
  export type ssconsultation_billingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * The data needed to update a ssconsultation_billing.
     */
    data: XOR<ssconsultation_billingUpdateInput, ssconsultation_billingUncheckedUpdateInput>
    /**
     * Choose, which ssconsultation_billing to update.
     */
    where: ssconsultation_billingWhereUniqueInput
  }

  /**
   * ssconsultation_billing updateMany
   */
  export type ssconsultation_billingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ssconsultation_billings.
     */
    data: XOR<ssconsultation_billingUpdateManyMutationInput, ssconsultation_billingUncheckedUpdateManyInput>
    /**
     * Filter which ssconsultation_billings to update
     */
    where?: ssconsultation_billingWhereInput
  }

  /**
   * ssconsultation_billing upsert
   */
  export type ssconsultation_billingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * The filter to search for the ssconsultation_billing to update in case it exists.
     */
    where: ssconsultation_billingWhereUniqueInput
    /**
     * In case the ssconsultation_billing found by the `where` argument doesn't exist, create a new ssconsultation_billing with this data.
     */
    create: XOR<ssconsultation_billingCreateInput, ssconsultation_billingUncheckedCreateInput>
    /**
     * In case the ssconsultation_billing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ssconsultation_billingUpdateInput, ssconsultation_billingUncheckedUpdateInput>
  }

  /**
   * ssconsultation_billing delete
   */
  export type ssconsultation_billingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
    /**
     * Filter which ssconsultation_billing to delete.
     */
    where: ssconsultation_billingWhereUniqueInput
  }

  /**
   * ssconsultation_billing deleteMany
   */
  export type ssconsultation_billingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ssconsultation_billings to delete
     */
    where?: ssconsultation_billingWhereInput
  }

  /**
   * ssconsultation_billing without action
   */
  export type ssconsultation_billingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_billing
     */
    select?: ssconsultation_billingSelect<ExtArgs> | null
  }


  /**
   * Model ssconsultation_log
   */

  export type AggregateSsconsultation_log = {
    _count: Ssconsultation_logCountAggregateOutputType | null
    _avg: Ssconsultation_logAvgAggregateOutputType | null
    _sum: Ssconsultation_logSumAggregateOutputType | null
    _min: Ssconsultation_logMinAggregateOutputType | null
    _max: Ssconsultation_logMaxAggregateOutputType | null
  }

  export type Ssconsultation_logAvgAggregateOutputType = {
    ssconsultation_log_id: number | null
    ssbilling_id: number | null
    payment_method: number | null
  }

  export type Ssconsultation_logSumAggregateOutputType = {
    ssconsultation_log_id: number | null
    ssbilling_id: number | null
    payment_method: number | null
  }

  export type Ssconsultation_logMinAggregateOutputType = {
    ssconsultation_log_id: number | null
    ssbilling_id: number | null
    amt: string | null
    payment_method: number | null
    added_date: Date | null
  }

  export type Ssconsultation_logMaxAggregateOutputType = {
    ssconsultation_log_id: number | null
    ssbilling_id: number | null
    amt: string | null
    payment_method: number | null
    added_date: Date | null
  }

  export type Ssconsultation_logCountAggregateOutputType = {
    ssconsultation_log_id: number
    ssbilling_id: number
    amt: number
    payment_method: number
    added_date: number
    _all: number
  }


  export type Ssconsultation_logAvgAggregateInputType = {
    ssconsultation_log_id?: true
    ssbilling_id?: true
    payment_method?: true
  }

  export type Ssconsultation_logSumAggregateInputType = {
    ssconsultation_log_id?: true
    ssbilling_id?: true
    payment_method?: true
  }

  export type Ssconsultation_logMinAggregateInputType = {
    ssconsultation_log_id?: true
    ssbilling_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
  }

  export type Ssconsultation_logMaxAggregateInputType = {
    ssconsultation_log_id?: true
    ssbilling_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
  }

  export type Ssconsultation_logCountAggregateInputType = {
    ssconsultation_log_id?: true
    ssbilling_id?: true
    amt?: true
    payment_method?: true
    added_date?: true
    _all?: true
  }

  export type Ssconsultation_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ssconsultation_log to aggregate.
     */
    where?: ssconsultation_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_logs to fetch.
     */
    orderBy?: ssconsultation_logOrderByWithRelationInput | ssconsultation_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ssconsultation_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ssconsultation_logs
    **/
    _count?: true | Ssconsultation_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ssconsultation_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ssconsultation_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ssconsultation_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ssconsultation_logMaxAggregateInputType
  }

  export type GetSsconsultation_logAggregateType<T extends Ssconsultation_logAggregateArgs> = {
        [P in keyof T & keyof AggregateSsconsultation_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSsconsultation_log[P]>
      : GetScalarType<T[P], AggregateSsconsultation_log[P]>
  }




  export type ssconsultation_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ssconsultation_logWhereInput
    orderBy?: ssconsultation_logOrderByWithAggregationInput | ssconsultation_logOrderByWithAggregationInput[]
    by: Ssconsultation_logScalarFieldEnum[] | Ssconsultation_logScalarFieldEnum
    having?: ssconsultation_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ssconsultation_logCountAggregateInputType | true
    _avg?: Ssconsultation_logAvgAggregateInputType
    _sum?: Ssconsultation_logSumAggregateInputType
    _min?: Ssconsultation_logMinAggregateInputType
    _max?: Ssconsultation_logMaxAggregateInputType
  }

  export type Ssconsultation_logGroupByOutputType = {
    ssconsultation_log_id: number
    ssbilling_id: number
    amt: string
    payment_method: number
    added_date: Date
    _count: Ssconsultation_logCountAggregateOutputType | null
    _avg: Ssconsultation_logAvgAggregateOutputType | null
    _sum: Ssconsultation_logSumAggregateOutputType | null
    _min: Ssconsultation_logMinAggregateOutputType | null
    _max: Ssconsultation_logMaxAggregateOutputType | null
  }

  type GetSsconsultation_logGroupByPayload<T extends ssconsultation_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ssconsultation_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ssconsultation_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ssconsultation_logGroupByOutputType[P]>
            : GetScalarType<T[P], Ssconsultation_logGroupByOutputType[P]>
        }
      >
    >


  export type ssconsultation_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ssconsultation_log_id?: boolean
    ssbilling_id?: boolean
    amt?: boolean
    payment_method?: boolean
    added_date?: boolean
  }, ExtArgs["result"]["ssconsultation_log"]>


  export type ssconsultation_logSelectScalar = {
    ssconsultation_log_id?: boolean
    ssbilling_id?: boolean
    amt?: boolean
    payment_method?: boolean
    added_date?: boolean
  }


  export type $ssconsultation_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ssconsultation_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ssconsultation_log_id: number
      ssbilling_id: number
      amt: string
      payment_method: number
      added_date: Date
    }, ExtArgs["result"]["ssconsultation_log"]>
    composites: {}
  }

  type ssconsultation_logGetPayload<S extends boolean | null | undefined | ssconsultation_logDefaultArgs> = $Result.GetResult<Prisma.$ssconsultation_logPayload, S>

  type ssconsultation_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ssconsultation_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ssconsultation_logCountAggregateInputType | true
    }

  export interface ssconsultation_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ssconsultation_log'], meta: { name: 'ssconsultation_log' } }
    /**
     * Find zero or one Ssconsultation_log that matches the filter.
     * @param {ssconsultation_logFindUniqueArgs} args - Arguments to find a Ssconsultation_log
     * @example
     * // Get one Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ssconsultation_logFindUniqueArgs>(args: SelectSubset<T, ssconsultation_logFindUniqueArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ssconsultation_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ssconsultation_logFindUniqueOrThrowArgs} args - Arguments to find a Ssconsultation_log
     * @example
     * // Get one Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ssconsultation_logFindUniqueOrThrowArgs>(args: SelectSubset<T, ssconsultation_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ssconsultation_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logFindFirstArgs} args - Arguments to find a Ssconsultation_log
     * @example
     * // Get one Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ssconsultation_logFindFirstArgs>(args?: SelectSubset<T, ssconsultation_logFindFirstArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ssconsultation_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logFindFirstOrThrowArgs} args - Arguments to find a Ssconsultation_log
     * @example
     * // Get one Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ssconsultation_logFindFirstOrThrowArgs>(args?: SelectSubset<T, ssconsultation_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ssconsultation_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ssconsultation_logs
     * const ssconsultation_logs = await prisma.ssconsultation_log.findMany()
     * 
     * // Get first 10 Ssconsultation_logs
     * const ssconsultation_logs = await prisma.ssconsultation_log.findMany({ take: 10 })
     * 
     * // Only select the `ssconsultation_log_id`
     * const ssconsultation_logWithSsconsultation_log_idOnly = await prisma.ssconsultation_log.findMany({ select: { ssconsultation_log_id: true } })
     * 
     */
    findMany<T extends ssconsultation_logFindManyArgs>(args?: SelectSubset<T, ssconsultation_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ssconsultation_log.
     * @param {ssconsultation_logCreateArgs} args - Arguments to create a Ssconsultation_log.
     * @example
     * // Create one Ssconsultation_log
     * const Ssconsultation_log = await prisma.ssconsultation_log.create({
     *   data: {
     *     // ... data to create a Ssconsultation_log
     *   }
     * })
     * 
     */
    create<T extends ssconsultation_logCreateArgs>(args: SelectSubset<T, ssconsultation_logCreateArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ssconsultation_logs.
     * @param {ssconsultation_logCreateManyArgs} args - Arguments to create many Ssconsultation_logs.
     * @example
     * // Create many Ssconsultation_logs
     * const ssconsultation_log = await prisma.ssconsultation_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ssconsultation_logCreateManyArgs>(args?: SelectSubset<T, ssconsultation_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ssconsultation_log.
     * @param {ssconsultation_logDeleteArgs} args - Arguments to delete one Ssconsultation_log.
     * @example
     * // Delete one Ssconsultation_log
     * const Ssconsultation_log = await prisma.ssconsultation_log.delete({
     *   where: {
     *     // ... filter to delete one Ssconsultation_log
     *   }
     * })
     * 
     */
    delete<T extends ssconsultation_logDeleteArgs>(args: SelectSubset<T, ssconsultation_logDeleteArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ssconsultation_log.
     * @param {ssconsultation_logUpdateArgs} args - Arguments to update one Ssconsultation_log.
     * @example
     * // Update one Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ssconsultation_logUpdateArgs>(args: SelectSubset<T, ssconsultation_logUpdateArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ssconsultation_logs.
     * @param {ssconsultation_logDeleteManyArgs} args - Arguments to filter Ssconsultation_logs to delete.
     * @example
     * // Delete a few Ssconsultation_logs
     * const { count } = await prisma.ssconsultation_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ssconsultation_logDeleteManyArgs>(args?: SelectSubset<T, ssconsultation_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ssconsultation_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ssconsultation_logs
     * const ssconsultation_log = await prisma.ssconsultation_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ssconsultation_logUpdateManyArgs>(args: SelectSubset<T, ssconsultation_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ssconsultation_log.
     * @param {ssconsultation_logUpsertArgs} args - Arguments to update or create a Ssconsultation_log.
     * @example
     * // Update or create a Ssconsultation_log
     * const ssconsultation_log = await prisma.ssconsultation_log.upsert({
     *   create: {
     *     // ... data to create a Ssconsultation_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ssconsultation_log we want to update
     *   }
     * })
     */
    upsert<T extends ssconsultation_logUpsertArgs>(args: SelectSubset<T, ssconsultation_logUpsertArgs<ExtArgs>>): Prisma__ssconsultation_logClient<$Result.GetResult<Prisma.$ssconsultation_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ssconsultation_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logCountArgs} args - Arguments to filter Ssconsultation_logs to count.
     * @example
     * // Count the number of Ssconsultation_logs
     * const count = await prisma.ssconsultation_log.count({
     *   where: {
     *     // ... the filter for the Ssconsultation_logs we want to count
     *   }
     * })
    **/
    count<T extends ssconsultation_logCountArgs>(
      args?: Subset<T, ssconsultation_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ssconsultation_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ssconsultation_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ssconsultation_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ssconsultation_logAggregateArgs>(args: Subset<T, Ssconsultation_logAggregateArgs>): Prisma.PrismaPromise<GetSsconsultation_logAggregateType<T>>

    /**
     * Group by Ssconsultation_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ssconsultation_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ssconsultation_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ssconsultation_logGroupByArgs['orderBy'] }
        : { orderBy?: ssconsultation_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ssconsultation_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSsconsultation_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ssconsultation_log model
   */
  readonly fields: ssconsultation_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ssconsultation_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ssconsultation_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ssconsultation_log model
   */ 
  interface ssconsultation_logFieldRefs {
    readonly ssconsultation_log_id: FieldRef<"ssconsultation_log", 'Int'>
    readonly ssbilling_id: FieldRef<"ssconsultation_log", 'Int'>
    readonly amt: FieldRef<"ssconsultation_log", 'String'>
    readonly payment_method: FieldRef<"ssconsultation_log", 'Int'>
    readonly added_date: FieldRef<"ssconsultation_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ssconsultation_log findUnique
   */
  export type ssconsultation_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_log to fetch.
     */
    where: ssconsultation_logWhereUniqueInput
  }

  /**
   * ssconsultation_log findUniqueOrThrow
   */
  export type ssconsultation_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_log to fetch.
     */
    where: ssconsultation_logWhereUniqueInput
  }

  /**
   * ssconsultation_log findFirst
   */
  export type ssconsultation_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_log to fetch.
     */
    where?: ssconsultation_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_logs to fetch.
     */
    orderBy?: ssconsultation_logOrderByWithRelationInput | ssconsultation_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ssconsultation_logs.
     */
    cursor?: ssconsultation_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ssconsultation_logs.
     */
    distinct?: Ssconsultation_logScalarFieldEnum | Ssconsultation_logScalarFieldEnum[]
  }

  /**
   * ssconsultation_log findFirstOrThrow
   */
  export type ssconsultation_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_log to fetch.
     */
    where?: ssconsultation_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_logs to fetch.
     */
    orderBy?: ssconsultation_logOrderByWithRelationInput | ssconsultation_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ssconsultation_logs.
     */
    cursor?: ssconsultation_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ssconsultation_logs.
     */
    distinct?: Ssconsultation_logScalarFieldEnum | Ssconsultation_logScalarFieldEnum[]
  }

  /**
   * ssconsultation_log findMany
   */
  export type ssconsultation_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter, which ssconsultation_logs to fetch.
     */
    where?: ssconsultation_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ssconsultation_logs to fetch.
     */
    orderBy?: ssconsultation_logOrderByWithRelationInput | ssconsultation_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ssconsultation_logs.
     */
    cursor?: ssconsultation_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ssconsultation_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ssconsultation_logs.
     */
    skip?: number
    distinct?: Ssconsultation_logScalarFieldEnum | Ssconsultation_logScalarFieldEnum[]
  }

  /**
   * ssconsultation_log create
   */
  export type ssconsultation_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * The data needed to create a ssconsultation_log.
     */
    data: XOR<ssconsultation_logCreateInput, ssconsultation_logUncheckedCreateInput>
  }

  /**
   * ssconsultation_log createMany
   */
  export type ssconsultation_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ssconsultation_logs.
     */
    data: ssconsultation_logCreateManyInput | ssconsultation_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ssconsultation_log update
   */
  export type ssconsultation_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * The data needed to update a ssconsultation_log.
     */
    data: XOR<ssconsultation_logUpdateInput, ssconsultation_logUncheckedUpdateInput>
    /**
     * Choose, which ssconsultation_log to update.
     */
    where: ssconsultation_logWhereUniqueInput
  }

  /**
   * ssconsultation_log updateMany
   */
  export type ssconsultation_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ssconsultation_logs.
     */
    data: XOR<ssconsultation_logUpdateManyMutationInput, ssconsultation_logUncheckedUpdateManyInput>
    /**
     * Filter which ssconsultation_logs to update
     */
    where?: ssconsultation_logWhereInput
  }

  /**
   * ssconsultation_log upsert
   */
  export type ssconsultation_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * The filter to search for the ssconsultation_log to update in case it exists.
     */
    where: ssconsultation_logWhereUniqueInput
    /**
     * In case the ssconsultation_log found by the `where` argument doesn't exist, create a new ssconsultation_log with this data.
     */
    create: XOR<ssconsultation_logCreateInput, ssconsultation_logUncheckedCreateInput>
    /**
     * In case the ssconsultation_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ssconsultation_logUpdateInput, ssconsultation_logUncheckedUpdateInput>
  }

  /**
   * ssconsultation_log delete
   */
  export type ssconsultation_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
    /**
     * Filter which ssconsultation_log to delete.
     */
    where: ssconsultation_logWhereUniqueInput
  }

  /**
   * ssconsultation_log deleteMany
   */
  export type ssconsultation_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ssconsultation_logs to delete
     */
    where?: ssconsultation_logWhereInput
  }

  /**
   * ssconsultation_log without action
   */
  export type ssconsultation_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ssconsultation_log
     */
    select?: ssconsultation_logSelect<ExtArgs> | null
  }


  /**
   * Model state
   */

  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    state_id: number | null
    country_id: number | null
  }

  export type StateSumAggregateOutputType = {
    state_id: number | null
    country_id: number | null
  }

  export type StateMinAggregateOutputType = {
    state_id: number | null
    state_name: string | null
    country_id: number | null
    active: boolean | null
  }

  export type StateMaxAggregateOutputType = {
    state_id: number | null
    state_name: string | null
    country_id: number | null
    active: boolean | null
  }

  export type StateCountAggregateOutputType = {
    state_id: number
    state_name: number
    country_id: number
    active: number
    _all: number
  }


  export type StateAvgAggregateInputType = {
    state_id?: true
    country_id?: true
  }

  export type StateSumAggregateInputType = {
    state_id?: true
    country_id?: true
  }

  export type StateMinAggregateInputType = {
    state_id?: true
    state_name?: true
    country_id?: true
    active?: true
  }

  export type StateMaxAggregateInputType = {
    state_id?: true
    state_name?: true
    country_id?: true
    active?: true
  }

  export type StateCountAggregateInputType = {
    state_id?: true
    state_name?: true
    country_id?: true
    active?: true
    _all?: true
  }

  export type StateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which state to aggregate.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned states
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type stateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stateWhereInput
    orderBy?: stateOrderByWithAggregationInput | stateOrderByWithAggregationInput[]
    by: StateScalarFieldEnum[] | StateScalarFieldEnum
    having?: stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _avg?: StateAvgAggregateInputType
    _sum?: StateSumAggregateInputType
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }

  export type StateGroupByOutputType = {
    state_id: number
    state_name: string
    country_id: number
    active: boolean
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends stateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type stateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state_id?: boolean
    state_name?: boolean
    country_id?: boolean
    active?: boolean
  }, ExtArgs["result"]["state"]>


  export type stateSelectScalar = {
    state_id?: boolean
    state_name?: boolean
    country_id?: boolean
    active?: boolean
  }


  export type $statePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "state"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      state_id: number
      state_name: string
      country_id: number
      active: boolean
    }, ExtArgs["result"]["state"]>
    composites: {}
  }

  type stateGetPayload<S extends boolean | null | undefined | stateDefaultArgs> = $Result.GetResult<Prisma.$statePayload, S>

  type stateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<stateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface stateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['state'], meta: { name: 'state' } }
    /**
     * Find zero or one State that matches the filter.
     * @param {stateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stateFindUniqueArgs>(args: SelectSubset<T, stateFindUniqueArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one State that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {stateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stateFindUniqueOrThrowArgs>(args: SelectSubset<T, stateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stateFindFirstArgs>(args?: SelectSubset<T, stateFindFirstArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first State that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stateFindFirstOrThrowArgs>(args?: SelectSubset<T, stateFindFirstOrThrowArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `state_id`
     * const stateWithState_idOnly = await prisma.state.findMany({ select: { state_id: true } })
     * 
     */
    findMany<T extends stateFindManyArgs>(args?: SelectSubset<T, stateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a State.
     * @param {stateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
     */
    create<T extends stateCreateArgs>(args: SelectSubset<T, stateCreateArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many States.
     * @param {stateCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stateCreateManyArgs>(args?: SelectSubset<T, stateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {stateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
     */
    delete<T extends stateDeleteArgs>(args: SelectSubset<T, stateDeleteArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one State.
     * @param {stateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stateUpdateArgs>(args: SelectSubset<T, stateUpdateArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more States.
     * @param {stateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stateDeleteManyArgs>(args?: SelectSubset<T, stateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stateUpdateManyArgs>(args: SelectSubset<T, stateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {stateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
     */
    upsert<T extends stateUpsertArgs>(args: SelectSubset<T, stateUpsertArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends stateCountArgs>(
      args?: Subset<T, stateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): Prisma.PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stateGroupByArgs['orderBy'] }
        : { orderBy?: stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the state model
   */
  readonly fields: stateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the state model
   */ 
  interface stateFieldRefs {
    readonly state_id: FieldRef<"state", 'Int'>
    readonly state_name: FieldRef<"state", 'String'>
    readonly country_id: FieldRef<"state", 'Int'>
    readonly active: FieldRef<"state", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * state findUnique
   */
  export type stateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state findUniqueOrThrow
   */
  export type stateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state findFirst
   */
  export type stateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state findFirstOrThrow
   */
  export type stateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state findMany
   */
  export type stateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state create
   */
  export type stateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * The data needed to create a state.
     */
    data: XOR<stateCreateInput, stateUncheckedCreateInput>
  }

  /**
   * state createMany
   */
  export type stateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many states.
     */
    data: stateCreateManyInput | stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * state update
   */
  export type stateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * The data needed to update a state.
     */
    data: XOR<stateUpdateInput, stateUncheckedUpdateInput>
    /**
     * Choose, which state to update.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state updateMany
   */
  export type stateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update states.
     */
    data: XOR<stateUpdateManyMutationInput, stateUncheckedUpdateManyInput>
    /**
     * Filter which states to update
     */
    where?: stateWhereInput
  }

  /**
   * state upsert
   */
  export type stateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * The filter to search for the state to update in case it exists.
     */
    where: stateWhereUniqueInput
    /**
     * In case the state found by the `where` argument doesn't exist, create a new state with this data.
     */
    create: XOR<stateCreateInput, stateUncheckedCreateInput>
    /**
     * In case the state was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stateUpdateInput, stateUncheckedUpdateInput>
  }

  /**
   * state delete
   */
  export type stateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Filter which state to delete.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state deleteMany
   */
  export type stateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which states to delete
     */
    where?: stateWhereInput
  }

  /**
   * state without action
   */
  export type stateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
  }


  /**
   * Model status_master
   */

  export type AggregateStatus_master = {
    _count: Status_masterCountAggregateOutputType | null
    _avg: Status_masterAvgAggregateOutputType | null
    _sum: Status_masterSumAggregateOutputType | null
    _min: Status_masterMinAggregateOutputType | null
    _max: Status_masterMaxAggregateOutputType | null
  }

  export type Status_masterAvgAggregateOutputType = {
    status_id: number | null
  }

  export type Status_masterSumAggregateOutputType = {
    status_id: number | null
  }

  export type Status_masterMinAggregateOutputType = {
    status_id: number | null
    status: string | null
  }

  export type Status_masterMaxAggregateOutputType = {
    status_id: number | null
    status: string | null
  }

  export type Status_masterCountAggregateOutputType = {
    status_id: number
    status: number
    _all: number
  }


  export type Status_masterAvgAggregateInputType = {
    status_id?: true
  }

  export type Status_masterSumAggregateInputType = {
    status_id?: true
  }

  export type Status_masterMinAggregateInputType = {
    status_id?: true
    status?: true
  }

  export type Status_masterMaxAggregateInputType = {
    status_id?: true
    status?: true
  }

  export type Status_masterCountAggregateInputType = {
    status_id?: true
    status?: true
    _all?: true
  }

  export type Status_masterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which status_master to aggregate.
     */
    where?: status_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_masters to fetch.
     */
    orderBy?: status_masterOrderByWithRelationInput | status_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: status_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned status_masters
    **/
    _count?: true | Status_masterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Status_masterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Status_masterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Status_masterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Status_masterMaxAggregateInputType
  }

  export type GetStatus_masterAggregateType<T extends Status_masterAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus_master]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus_master[P]>
      : GetScalarType<T[P], AggregateStatus_master[P]>
  }




  export type status_masterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: status_masterWhereInput
    orderBy?: status_masterOrderByWithAggregationInput | status_masterOrderByWithAggregationInput[]
    by: Status_masterScalarFieldEnum[] | Status_masterScalarFieldEnum
    having?: status_masterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Status_masterCountAggregateInputType | true
    _avg?: Status_masterAvgAggregateInputType
    _sum?: Status_masterSumAggregateInputType
    _min?: Status_masterMinAggregateInputType
    _max?: Status_masterMaxAggregateInputType
  }

  export type Status_masterGroupByOutputType = {
    status_id: number
    status: string
    _count: Status_masterCountAggregateOutputType | null
    _avg: Status_masterAvgAggregateOutputType | null
    _sum: Status_masterSumAggregateOutputType | null
    _min: Status_masterMinAggregateOutputType | null
    _max: Status_masterMaxAggregateOutputType | null
  }

  type GetStatus_masterGroupByPayload<T extends status_masterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Status_masterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Status_masterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Status_masterGroupByOutputType[P]>
            : GetScalarType<T[P], Status_masterGroupByOutputType[P]>
        }
      >
    >


  export type status_masterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    status?: boolean
  }, ExtArgs["result"]["status_master"]>


  export type status_masterSelectScalar = {
    status_id?: boolean
    status?: boolean
  }


  export type $status_masterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "status_master"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      status_id: number
      status: string
    }, ExtArgs["result"]["status_master"]>
    composites: {}
  }

  type status_masterGetPayload<S extends boolean | null | undefined | status_masterDefaultArgs> = $Result.GetResult<Prisma.$status_masterPayload, S>

  type status_masterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<status_masterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Status_masterCountAggregateInputType | true
    }

  export interface status_masterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['status_master'], meta: { name: 'status_master' } }
    /**
     * Find zero or one Status_master that matches the filter.
     * @param {status_masterFindUniqueArgs} args - Arguments to find a Status_master
     * @example
     * // Get one Status_master
     * const status_master = await prisma.status_master.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends status_masterFindUniqueArgs>(args: SelectSubset<T, status_masterFindUniqueArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Status_master that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {status_masterFindUniqueOrThrowArgs} args - Arguments to find a Status_master
     * @example
     * // Get one Status_master
     * const status_master = await prisma.status_master.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends status_masterFindUniqueOrThrowArgs>(args: SelectSubset<T, status_masterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Status_master that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterFindFirstArgs} args - Arguments to find a Status_master
     * @example
     * // Get one Status_master
     * const status_master = await prisma.status_master.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends status_masterFindFirstArgs>(args?: SelectSubset<T, status_masterFindFirstArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Status_master that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterFindFirstOrThrowArgs} args - Arguments to find a Status_master
     * @example
     * // Get one Status_master
     * const status_master = await prisma.status_master.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends status_masterFindFirstOrThrowArgs>(args?: SelectSubset<T, status_masterFindFirstOrThrowArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Status_masters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Status_masters
     * const status_masters = await prisma.status_master.findMany()
     * 
     * // Get first 10 Status_masters
     * const status_masters = await prisma.status_master.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const status_masterWithStatus_idOnly = await prisma.status_master.findMany({ select: { status_id: true } })
     * 
     */
    findMany<T extends status_masterFindManyArgs>(args?: SelectSubset<T, status_masterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Status_master.
     * @param {status_masterCreateArgs} args - Arguments to create a Status_master.
     * @example
     * // Create one Status_master
     * const Status_master = await prisma.status_master.create({
     *   data: {
     *     // ... data to create a Status_master
     *   }
     * })
     * 
     */
    create<T extends status_masterCreateArgs>(args: SelectSubset<T, status_masterCreateArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Status_masters.
     * @param {status_masterCreateManyArgs} args - Arguments to create many Status_masters.
     * @example
     * // Create many Status_masters
     * const status_master = await prisma.status_master.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends status_masterCreateManyArgs>(args?: SelectSubset<T, status_masterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Status_master.
     * @param {status_masterDeleteArgs} args - Arguments to delete one Status_master.
     * @example
     * // Delete one Status_master
     * const Status_master = await prisma.status_master.delete({
     *   where: {
     *     // ... filter to delete one Status_master
     *   }
     * })
     * 
     */
    delete<T extends status_masterDeleteArgs>(args: SelectSubset<T, status_masterDeleteArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Status_master.
     * @param {status_masterUpdateArgs} args - Arguments to update one Status_master.
     * @example
     * // Update one Status_master
     * const status_master = await prisma.status_master.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends status_masterUpdateArgs>(args: SelectSubset<T, status_masterUpdateArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Status_masters.
     * @param {status_masterDeleteManyArgs} args - Arguments to filter Status_masters to delete.
     * @example
     * // Delete a few Status_masters
     * const { count } = await prisma.status_master.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends status_masterDeleteManyArgs>(args?: SelectSubset<T, status_masterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Status_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Status_masters
     * const status_master = await prisma.status_master.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends status_masterUpdateManyArgs>(args: SelectSubset<T, status_masterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Status_master.
     * @param {status_masterUpsertArgs} args - Arguments to update or create a Status_master.
     * @example
     * // Update or create a Status_master
     * const status_master = await prisma.status_master.upsert({
     *   create: {
     *     // ... data to create a Status_master
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status_master we want to update
     *   }
     * })
     */
    upsert<T extends status_masterUpsertArgs>(args: SelectSubset<T, status_masterUpsertArgs<ExtArgs>>): Prisma__status_masterClient<$Result.GetResult<Prisma.$status_masterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Status_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterCountArgs} args - Arguments to filter Status_masters to count.
     * @example
     * // Count the number of Status_masters
     * const count = await prisma.status_master.count({
     *   where: {
     *     // ... the filter for the Status_masters we want to count
     *   }
     * })
    **/
    count<T extends status_masterCountArgs>(
      args?: Subset<T, status_masterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Status_masterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Status_masterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Status_masterAggregateArgs>(args: Subset<T, Status_masterAggregateArgs>): Prisma.PrismaPromise<GetStatus_masterAggregateType<T>>

    /**
     * Group by Status_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_masterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends status_masterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: status_masterGroupByArgs['orderBy'] }
        : { orderBy?: status_masterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, status_masterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatus_masterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the status_master model
   */
  readonly fields: status_masterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for status_master.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__status_masterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the status_master model
   */ 
  interface status_masterFieldRefs {
    readonly status_id: FieldRef<"status_master", 'Int'>
    readonly status: FieldRef<"status_master", 'String'>
  }
    

  // Custom InputTypes
  /**
   * status_master findUnique
   */
  export type status_masterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter, which status_master to fetch.
     */
    where: status_masterWhereUniqueInput
  }

  /**
   * status_master findUniqueOrThrow
   */
  export type status_masterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter, which status_master to fetch.
     */
    where: status_masterWhereUniqueInput
  }

  /**
   * status_master findFirst
   */
  export type status_masterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter, which status_master to fetch.
     */
    where?: status_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_masters to fetch.
     */
    orderBy?: status_masterOrderByWithRelationInput | status_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for status_masters.
     */
    cursor?: status_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of status_masters.
     */
    distinct?: Status_masterScalarFieldEnum | Status_masterScalarFieldEnum[]
  }

  /**
   * status_master findFirstOrThrow
   */
  export type status_masterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter, which status_master to fetch.
     */
    where?: status_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_masters to fetch.
     */
    orderBy?: status_masterOrderByWithRelationInput | status_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for status_masters.
     */
    cursor?: status_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of status_masters.
     */
    distinct?: Status_masterScalarFieldEnum | Status_masterScalarFieldEnum[]
  }

  /**
   * status_master findMany
   */
  export type status_masterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter, which status_masters to fetch.
     */
    where?: status_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_masters to fetch.
     */
    orderBy?: status_masterOrderByWithRelationInput | status_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing status_masters.
     */
    cursor?: status_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_masters.
     */
    skip?: number
    distinct?: Status_masterScalarFieldEnum | Status_masterScalarFieldEnum[]
  }

  /**
   * status_master create
   */
  export type status_masterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * The data needed to create a status_master.
     */
    data: XOR<status_masterCreateInput, status_masterUncheckedCreateInput>
  }

  /**
   * status_master createMany
   */
  export type status_masterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many status_masters.
     */
    data: status_masterCreateManyInput | status_masterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * status_master update
   */
  export type status_masterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * The data needed to update a status_master.
     */
    data: XOR<status_masterUpdateInput, status_masterUncheckedUpdateInput>
    /**
     * Choose, which status_master to update.
     */
    where: status_masterWhereUniqueInput
  }

  /**
   * status_master updateMany
   */
  export type status_masterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update status_masters.
     */
    data: XOR<status_masterUpdateManyMutationInput, status_masterUncheckedUpdateManyInput>
    /**
     * Filter which status_masters to update
     */
    where?: status_masterWhereInput
  }

  /**
   * status_master upsert
   */
  export type status_masterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * The filter to search for the status_master to update in case it exists.
     */
    where: status_masterWhereUniqueInput
    /**
     * In case the status_master found by the `where` argument doesn't exist, create a new status_master with this data.
     */
    create: XOR<status_masterCreateInput, status_masterUncheckedCreateInput>
    /**
     * In case the status_master was found with the provided `where` argument, update it with this data.
     */
    update: XOR<status_masterUpdateInput, status_masterUncheckedUpdateInput>
  }

  /**
   * status_master delete
   */
  export type status_masterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
    /**
     * Filter which status_master to delete.
     */
    where: status_masterWhereUniqueInput
  }

  /**
   * status_master deleteMany
   */
  export type status_masterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which status_masters to delete
     */
    where?: status_masterWhereInput
  }

  /**
   * status_master without action
   */
  export type status_masterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_master
     */
    select?: status_masterSelect<ExtArgs> | null
  }


  /**
   * Model super_speciality
   */

  export type AggregateSuper_speciality = {
    _count: Super_specialityCountAggregateOutputType | null
    _avg: Super_specialityAvgAggregateOutputType | null
    _sum: Super_specialitySumAggregateOutputType | null
    _min: Super_specialityMinAggregateOutputType | null
    _max: Super_specialityMaxAggregateOutputType | null
  }

  export type Super_specialityAvgAggregateOutputType = {
    superspeciality_id: number | null
    active: number | null
  }

  export type Super_specialitySumAggregateOutputType = {
    superspeciality_id: number | null
    active: number | null
  }

  export type Super_specialityMinAggregateOutputType = {
    superspeciality_id: number | null
    superspeciality_name: string | null
    created_on: Date | null
    active: number | null
  }

  export type Super_specialityMaxAggregateOutputType = {
    superspeciality_id: number | null
    superspeciality_name: string | null
    created_on: Date | null
    active: number | null
  }

  export type Super_specialityCountAggregateOutputType = {
    superspeciality_id: number
    superspeciality_name: number
    created_on: number
    active: number
    _all: number
  }


  export type Super_specialityAvgAggregateInputType = {
    superspeciality_id?: true
    active?: true
  }

  export type Super_specialitySumAggregateInputType = {
    superspeciality_id?: true
    active?: true
  }

  export type Super_specialityMinAggregateInputType = {
    superspeciality_id?: true
    superspeciality_name?: true
    created_on?: true
    active?: true
  }

  export type Super_specialityMaxAggregateInputType = {
    superspeciality_id?: true
    superspeciality_name?: true
    created_on?: true
    active?: true
  }

  export type Super_specialityCountAggregateInputType = {
    superspeciality_id?: true
    superspeciality_name?: true
    created_on?: true
    active?: true
    _all?: true
  }

  export type Super_specialityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which super_speciality to aggregate.
     */
    where?: super_specialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of super_specialities to fetch.
     */
    orderBy?: super_specialityOrderByWithRelationInput | super_specialityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: super_specialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` super_specialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` super_specialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned super_specialities
    **/
    _count?: true | Super_specialityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Super_specialityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Super_specialitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Super_specialityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Super_specialityMaxAggregateInputType
  }

  export type GetSuper_specialityAggregateType<T extends Super_specialityAggregateArgs> = {
        [P in keyof T & keyof AggregateSuper_speciality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuper_speciality[P]>
      : GetScalarType<T[P], AggregateSuper_speciality[P]>
  }




  export type super_specialityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: super_specialityWhereInput
    orderBy?: super_specialityOrderByWithAggregationInput | super_specialityOrderByWithAggregationInput[]
    by: Super_specialityScalarFieldEnum[] | Super_specialityScalarFieldEnum
    having?: super_specialityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Super_specialityCountAggregateInputType | true
    _avg?: Super_specialityAvgAggregateInputType
    _sum?: Super_specialitySumAggregateInputType
    _min?: Super_specialityMinAggregateInputType
    _max?: Super_specialityMaxAggregateInputType
  }

  export type Super_specialityGroupByOutputType = {
    superspeciality_id: number
    superspeciality_name: string | null
    created_on: Date | null
    active: number
    _count: Super_specialityCountAggregateOutputType | null
    _avg: Super_specialityAvgAggregateOutputType | null
    _sum: Super_specialitySumAggregateOutputType | null
    _min: Super_specialityMinAggregateOutputType | null
    _max: Super_specialityMaxAggregateOutputType | null
  }

  type GetSuper_specialityGroupByPayload<T extends super_specialityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Super_specialityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Super_specialityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Super_specialityGroupByOutputType[P]>
            : GetScalarType<T[P], Super_specialityGroupByOutputType[P]>
        }
      >
    >


  export type super_specialitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    superspeciality_id?: boolean
    superspeciality_name?: boolean
    created_on?: boolean
    active?: boolean
  }, ExtArgs["result"]["super_speciality"]>


  export type super_specialitySelectScalar = {
    superspeciality_id?: boolean
    superspeciality_name?: boolean
    created_on?: boolean
    active?: boolean
  }


  export type $super_specialityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "super_speciality"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      superspeciality_id: number
      superspeciality_name: string | null
      created_on: Date | null
      active: number
    }, ExtArgs["result"]["super_speciality"]>
    composites: {}
  }

  type super_specialityGetPayload<S extends boolean | null | undefined | super_specialityDefaultArgs> = $Result.GetResult<Prisma.$super_specialityPayload, S>

  type super_specialityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<super_specialityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Super_specialityCountAggregateInputType | true
    }

  export interface super_specialityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['super_speciality'], meta: { name: 'super_speciality' } }
    /**
     * Find zero or one Super_speciality that matches the filter.
     * @param {super_specialityFindUniqueArgs} args - Arguments to find a Super_speciality
     * @example
     * // Get one Super_speciality
     * const super_speciality = await prisma.super_speciality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends super_specialityFindUniqueArgs>(args: SelectSubset<T, super_specialityFindUniqueArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Super_speciality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {super_specialityFindUniqueOrThrowArgs} args - Arguments to find a Super_speciality
     * @example
     * // Get one Super_speciality
     * const super_speciality = await prisma.super_speciality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends super_specialityFindUniqueOrThrowArgs>(args: SelectSubset<T, super_specialityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Super_speciality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityFindFirstArgs} args - Arguments to find a Super_speciality
     * @example
     * // Get one Super_speciality
     * const super_speciality = await prisma.super_speciality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends super_specialityFindFirstArgs>(args?: SelectSubset<T, super_specialityFindFirstArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Super_speciality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityFindFirstOrThrowArgs} args - Arguments to find a Super_speciality
     * @example
     * // Get one Super_speciality
     * const super_speciality = await prisma.super_speciality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends super_specialityFindFirstOrThrowArgs>(args?: SelectSubset<T, super_specialityFindFirstOrThrowArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Super_specialities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Super_specialities
     * const super_specialities = await prisma.super_speciality.findMany()
     * 
     * // Get first 10 Super_specialities
     * const super_specialities = await prisma.super_speciality.findMany({ take: 10 })
     * 
     * // Only select the `superspeciality_id`
     * const super_specialityWithSuperspeciality_idOnly = await prisma.super_speciality.findMany({ select: { superspeciality_id: true } })
     * 
     */
    findMany<T extends super_specialityFindManyArgs>(args?: SelectSubset<T, super_specialityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Super_speciality.
     * @param {super_specialityCreateArgs} args - Arguments to create a Super_speciality.
     * @example
     * // Create one Super_speciality
     * const Super_speciality = await prisma.super_speciality.create({
     *   data: {
     *     // ... data to create a Super_speciality
     *   }
     * })
     * 
     */
    create<T extends super_specialityCreateArgs>(args: SelectSubset<T, super_specialityCreateArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Super_specialities.
     * @param {super_specialityCreateManyArgs} args - Arguments to create many Super_specialities.
     * @example
     * // Create many Super_specialities
     * const super_speciality = await prisma.super_speciality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends super_specialityCreateManyArgs>(args?: SelectSubset<T, super_specialityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Super_speciality.
     * @param {super_specialityDeleteArgs} args - Arguments to delete one Super_speciality.
     * @example
     * // Delete one Super_speciality
     * const Super_speciality = await prisma.super_speciality.delete({
     *   where: {
     *     // ... filter to delete one Super_speciality
     *   }
     * })
     * 
     */
    delete<T extends super_specialityDeleteArgs>(args: SelectSubset<T, super_specialityDeleteArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Super_speciality.
     * @param {super_specialityUpdateArgs} args - Arguments to update one Super_speciality.
     * @example
     * // Update one Super_speciality
     * const super_speciality = await prisma.super_speciality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends super_specialityUpdateArgs>(args: SelectSubset<T, super_specialityUpdateArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Super_specialities.
     * @param {super_specialityDeleteManyArgs} args - Arguments to filter Super_specialities to delete.
     * @example
     * // Delete a few Super_specialities
     * const { count } = await prisma.super_speciality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends super_specialityDeleteManyArgs>(args?: SelectSubset<T, super_specialityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Super_specialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Super_specialities
     * const super_speciality = await prisma.super_speciality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends super_specialityUpdateManyArgs>(args: SelectSubset<T, super_specialityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Super_speciality.
     * @param {super_specialityUpsertArgs} args - Arguments to update or create a Super_speciality.
     * @example
     * // Update or create a Super_speciality
     * const super_speciality = await prisma.super_speciality.upsert({
     *   create: {
     *     // ... data to create a Super_speciality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Super_speciality we want to update
     *   }
     * })
     */
    upsert<T extends super_specialityUpsertArgs>(args: SelectSubset<T, super_specialityUpsertArgs<ExtArgs>>): Prisma__super_specialityClient<$Result.GetResult<Prisma.$super_specialityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Super_specialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityCountArgs} args - Arguments to filter Super_specialities to count.
     * @example
     * // Count the number of Super_specialities
     * const count = await prisma.super_speciality.count({
     *   where: {
     *     // ... the filter for the Super_specialities we want to count
     *   }
     * })
    **/
    count<T extends super_specialityCountArgs>(
      args?: Subset<T, super_specialityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Super_specialityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Super_speciality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Super_specialityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Super_specialityAggregateArgs>(args: Subset<T, Super_specialityAggregateArgs>): Prisma.PrismaPromise<GetSuper_specialityAggregateType<T>>

    /**
     * Group by Super_speciality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {super_specialityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends super_specialityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: super_specialityGroupByArgs['orderBy'] }
        : { orderBy?: super_specialityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, super_specialityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuper_specialityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the super_speciality model
   */
  readonly fields: super_specialityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for super_speciality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__super_specialityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the super_speciality model
   */ 
  interface super_specialityFieldRefs {
    readonly superspeciality_id: FieldRef<"super_speciality", 'Int'>
    readonly superspeciality_name: FieldRef<"super_speciality", 'String'>
    readonly created_on: FieldRef<"super_speciality", 'DateTime'>
    readonly active: FieldRef<"super_speciality", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * super_speciality findUnique
   */
  export type super_specialityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter, which super_speciality to fetch.
     */
    where: super_specialityWhereUniqueInput
  }

  /**
   * super_speciality findUniqueOrThrow
   */
  export type super_specialityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter, which super_speciality to fetch.
     */
    where: super_specialityWhereUniqueInput
  }

  /**
   * super_speciality findFirst
   */
  export type super_specialityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter, which super_speciality to fetch.
     */
    where?: super_specialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of super_specialities to fetch.
     */
    orderBy?: super_specialityOrderByWithRelationInput | super_specialityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for super_specialities.
     */
    cursor?: super_specialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` super_specialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` super_specialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of super_specialities.
     */
    distinct?: Super_specialityScalarFieldEnum | Super_specialityScalarFieldEnum[]
  }

  /**
   * super_speciality findFirstOrThrow
   */
  export type super_specialityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter, which super_speciality to fetch.
     */
    where?: super_specialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of super_specialities to fetch.
     */
    orderBy?: super_specialityOrderByWithRelationInput | super_specialityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for super_specialities.
     */
    cursor?: super_specialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` super_specialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` super_specialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of super_specialities.
     */
    distinct?: Super_specialityScalarFieldEnum | Super_specialityScalarFieldEnum[]
  }

  /**
   * super_speciality findMany
   */
  export type super_specialityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter, which super_specialities to fetch.
     */
    where?: super_specialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of super_specialities to fetch.
     */
    orderBy?: super_specialityOrderByWithRelationInput | super_specialityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing super_specialities.
     */
    cursor?: super_specialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` super_specialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` super_specialities.
     */
    skip?: number
    distinct?: Super_specialityScalarFieldEnum | Super_specialityScalarFieldEnum[]
  }

  /**
   * super_speciality create
   */
  export type super_specialityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * The data needed to create a super_speciality.
     */
    data?: XOR<super_specialityCreateInput, super_specialityUncheckedCreateInput>
  }

  /**
   * super_speciality createMany
   */
  export type super_specialityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many super_specialities.
     */
    data: super_specialityCreateManyInput | super_specialityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * super_speciality update
   */
  export type super_specialityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * The data needed to update a super_speciality.
     */
    data: XOR<super_specialityUpdateInput, super_specialityUncheckedUpdateInput>
    /**
     * Choose, which super_speciality to update.
     */
    where: super_specialityWhereUniqueInput
  }

  /**
   * super_speciality updateMany
   */
  export type super_specialityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update super_specialities.
     */
    data: XOR<super_specialityUpdateManyMutationInput, super_specialityUncheckedUpdateManyInput>
    /**
     * Filter which super_specialities to update
     */
    where?: super_specialityWhereInput
  }

  /**
   * super_speciality upsert
   */
  export type super_specialityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * The filter to search for the super_speciality to update in case it exists.
     */
    where: super_specialityWhereUniqueInput
    /**
     * In case the super_speciality found by the `where` argument doesn't exist, create a new super_speciality with this data.
     */
    create: XOR<super_specialityCreateInput, super_specialityUncheckedCreateInput>
    /**
     * In case the super_speciality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<super_specialityUpdateInput, super_specialityUncheckedUpdateInput>
  }

  /**
   * super_speciality delete
   */
  export type super_specialityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
    /**
     * Filter which super_speciality to delete.
     */
    where: super_specialityWhereUniqueInput
  }

  /**
   * super_speciality deleteMany
   */
  export type super_specialityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which super_specialities to delete
     */
    where?: super_specialityWhereInput
  }

  /**
   * super_speciality without action
   */
  export type super_specialityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the super_speciality
     */
    select?: super_specialitySelect<ExtArgs> | null
  }


  /**
   * Model superspeciality_consultation
   */

  export type AggregateSuperspeciality_consultation = {
    _count: Superspeciality_consultationCountAggregateOutputType | null
    _avg: Superspeciality_consultationAvgAggregateOutputType | null
    _sum: Superspeciality_consultationSumAggregateOutputType | null
    _min: Superspeciality_consultationMinAggregateOutputType | null
    _max: Superspeciality_consultationMaxAggregateOutputType | null
  }

  export type Superspeciality_consultationAvgAggregateOutputType = {
    ss_id: number | null
    laboratory_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    by_assign: number | null
    to_assign: number | null
    consultationId: number | null
    consultationAmount: number | null
    miscellaneousAmount: number | null
    totalAmount: number | null
    status: number | null
  }

  export type Superspeciality_consultationSumAggregateOutputType = {
    ss_id: number | null
    laboratory_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    by_assign: number | null
    to_assign: number | null
    consultationId: number | null
    consultationAmount: number | null
    miscellaneousAmount: number | null
    totalAmount: number | null
    status: number | null
  }

  export type Superspeciality_consultationMinAggregateOutputType = {
    ss_id: number | null
    laboratory_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    comments: string | null
    by_assign: number | null
    to_assign: number | null
    referdate: Date | null
    refertime: string | null
    referclinic_name: string | null
    consultationId: number | null
    consultationDate: Date | null
    consultationAmount: number | null
    miscellaneousAmount: number | null
    totalAmount: number | null
    status: number | null
  }

  export type Superspeciality_consultationMaxAggregateOutputType = {
    ss_id: number | null
    laboratory_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    comments: string | null
    by_assign: number | null
    to_assign: number | null
    referdate: Date | null
    refertime: string | null
    referclinic_name: string | null
    consultationId: number | null
    consultationDate: Date | null
    consultationAmount: number | null
    miscellaneousAmount: number | null
    totalAmount: number | null
    status: number | null
  }

  export type Superspeciality_consultationCountAggregateOutputType = {
    ss_id: number
    laboratory_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: number
    by_assign: number
    to_assign: number
    referdate: number
    refertime: number
    referclinic_name: number
    consultationId: number
    consultationDate: number
    consultationAmount: number
    miscellaneousAmount: number
    totalAmount: number
    status: number
    _all: number
  }


  export type Superspeciality_consultationAvgAggregateInputType = {
    ss_id?: true
    laboratory_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    by_assign?: true
    to_assign?: true
    consultationId?: true
    consultationAmount?: true
    miscellaneousAmount?: true
    totalAmount?: true
    status?: true
  }

  export type Superspeciality_consultationSumAggregateInputType = {
    ss_id?: true
    laboratory_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    by_assign?: true
    to_assign?: true
    consultationId?: true
    consultationAmount?: true
    miscellaneousAmount?: true
    totalAmount?: true
    status?: true
  }

  export type Superspeciality_consultationMinAggregateInputType = {
    ss_id?: true
    laboratory_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    consultationId?: true
    consultationDate?: true
    consultationAmount?: true
    miscellaneousAmount?: true
    totalAmount?: true
    status?: true
  }

  export type Superspeciality_consultationMaxAggregateInputType = {
    ss_id?: true
    laboratory_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    consultationId?: true
    consultationDate?: true
    consultationAmount?: true
    miscellaneousAmount?: true
    totalAmount?: true
    status?: true
  }

  export type Superspeciality_consultationCountAggregateInputType = {
    ss_id?: true
    laboratory_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    consultationId?: true
    consultationDate?: true
    consultationAmount?: true
    miscellaneousAmount?: true
    totalAmount?: true
    status?: true
    _all?: true
  }

  export type Superspeciality_consultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superspeciality_consultation to aggregate.
     */
    where?: superspeciality_consultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_consultations to fetch.
     */
    orderBy?: superspeciality_consultationOrderByWithRelationInput | superspeciality_consultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: superspeciality_consultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned superspeciality_consultations
    **/
    _count?: true | Superspeciality_consultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Superspeciality_consultationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Superspeciality_consultationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Superspeciality_consultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Superspeciality_consultationMaxAggregateInputType
  }

  export type GetSuperspeciality_consultationAggregateType<T extends Superspeciality_consultationAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperspeciality_consultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperspeciality_consultation[P]>
      : GetScalarType<T[P], AggregateSuperspeciality_consultation[P]>
  }




  export type superspeciality_consultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: superspeciality_consultationWhereInput
    orderBy?: superspeciality_consultationOrderByWithAggregationInput | superspeciality_consultationOrderByWithAggregationInput[]
    by: Superspeciality_consultationScalarFieldEnum[] | Superspeciality_consultationScalarFieldEnum
    having?: superspeciality_consultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Superspeciality_consultationCountAggregateInputType | true
    _avg?: Superspeciality_consultationAvgAggregateInputType
    _sum?: Superspeciality_consultationSumAggregateInputType
    _min?: Superspeciality_consultationMinAggregateInputType
    _max?: Superspeciality_consultationMaxAggregateInputType
  }

  export type Superspeciality_consultationGroupByOutputType = {
    ss_id: number
    laboratory_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: string
    by_assign: number
    to_assign: number
    referdate: Date
    refertime: string
    referclinic_name: string
    consultationId: number
    consultationDate: Date | null
    consultationAmount: number | null
    miscellaneousAmount: number | null
    totalAmount: number | null
    status: number
    _count: Superspeciality_consultationCountAggregateOutputType | null
    _avg: Superspeciality_consultationAvgAggregateOutputType | null
    _sum: Superspeciality_consultationSumAggregateOutputType | null
    _min: Superspeciality_consultationMinAggregateOutputType | null
    _max: Superspeciality_consultationMaxAggregateOutputType | null
  }

  type GetSuperspeciality_consultationGroupByPayload<T extends superspeciality_consultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Superspeciality_consultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Superspeciality_consultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Superspeciality_consultationGroupByOutputType[P]>
            : GetScalarType<T[P], Superspeciality_consultationGroupByOutputType[P]>
        }
      >
    >


  export type superspeciality_consultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ss_id?: boolean
    laboratory_id?: boolean
    referral_patient_id?: boolean
    patient_dep_id?: boolean
    superspeciality_id?: boolean
    comments?: boolean
    by_assign?: boolean
    to_assign?: boolean
    referdate?: boolean
    refertime?: boolean
    referclinic_name?: boolean
    consultationId?: boolean
    consultationDate?: boolean
    consultationAmount?: boolean
    miscellaneousAmount?: boolean
    totalAmount?: boolean
    status?: boolean
  }, ExtArgs["result"]["superspeciality_consultation"]>


  export type superspeciality_consultationSelectScalar = {
    ss_id?: boolean
    laboratory_id?: boolean
    referral_patient_id?: boolean
    patient_dep_id?: boolean
    superspeciality_id?: boolean
    comments?: boolean
    by_assign?: boolean
    to_assign?: boolean
    referdate?: boolean
    refertime?: boolean
    referclinic_name?: boolean
    consultationId?: boolean
    consultationDate?: boolean
    consultationAmount?: boolean
    miscellaneousAmount?: boolean
    totalAmount?: boolean
    status?: boolean
  }


  export type $superspeciality_consultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "superspeciality_consultation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ss_id: number
      laboratory_id: number
      referral_patient_id: number
      patient_dep_id: number
      superspeciality_id: number
      comments: string
      by_assign: number
      to_assign: number
      referdate: Date
      refertime: string
      referclinic_name: string
      consultationId: number
      consultationDate: Date | null
      consultationAmount: number | null
      miscellaneousAmount: number | null
      totalAmount: number | null
      status: number
    }, ExtArgs["result"]["superspeciality_consultation"]>
    composites: {}
  }

  type superspeciality_consultationGetPayload<S extends boolean | null | undefined | superspeciality_consultationDefaultArgs> = $Result.GetResult<Prisma.$superspeciality_consultationPayload, S>

  type superspeciality_consultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<superspeciality_consultationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Superspeciality_consultationCountAggregateInputType | true
    }

  export interface superspeciality_consultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['superspeciality_consultation'], meta: { name: 'superspeciality_consultation' } }
    /**
     * Find zero or one Superspeciality_consultation that matches the filter.
     * @param {superspeciality_consultationFindUniqueArgs} args - Arguments to find a Superspeciality_consultation
     * @example
     * // Get one Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superspeciality_consultationFindUniqueArgs>(args: SelectSubset<T, superspeciality_consultationFindUniqueArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Superspeciality_consultation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {superspeciality_consultationFindUniqueOrThrowArgs} args - Arguments to find a Superspeciality_consultation
     * @example
     * // Get one Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends superspeciality_consultationFindUniqueOrThrowArgs>(args: SelectSubset<T, superspeciality_consultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Superspeciality_consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationFindFirstArgs} args - Arguments to find a Superspeciality_consultation
     * @example
     * // Get one Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superspeciality_consultationFindFirstArgs>(args?: SelectSubset<T, superspeciality_consultationFindFirstArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Superspeciality_consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationFindFirstOrThrowArgs} args - Arguments to find a Superspeciality_consultation
     * @example
     * // Get one Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superspeciality_consultationFindFirstOrThrowArgs>(args?: SelectSubset<T, superspeciality_consultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Superspeciality_consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superspeciality_consultations
     * const superspeciality_consultations = await prisma.superspeciality_consultation.findMany()
     * 
     * // Get first 10 Superspeciality_consultations
     * const superspeciality_consultations = await prisma.superspeciality_consultation.findMany({ take: 10 })
     * 
     * // Only select the `ss_id`
     * const superspeciality_consultationWithSs_idOnly = await prisma.superspeciality_consultation.findMany({ select: { ss_id: true } })
     * 
     */
    findMany<T extends superspeciality_consultationFindManyArgs>(args?: SelectSubset<T, superspeciality_consultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Superspeciality_consultation.
     * @param {superspeciality_consultationCreateArgs} args - Arguments to create a Superspeciality_consultation.
     * @example
     * // Create one Superspeciality_consultation
     * const Superspeciality_consultation = await prisma.superspeciality_consultation.create({
     *   data: {
     *     // ... data to create a Superspeciality_consultation
     *   }
     * })
     * 
     */
    create<T extends superspeciality_consultationCreateArgs>(args: SelectSubset<T, superspeciality_consultationCreateArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Superspeciality_consultations.
     * @param {superspeciality_consultationCreateManyArgs} args - Arguments to create many Superspeciality_consultations.
     * @example
     * // Create many Superspeciality_consultations
     * const superspeciality_consultation = await prisma.superspeciality_consultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends superspeciality_consultationCreateManyArgs>(args?: SelectSubset<T, superspeciality_consultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Superspeciality_consultation.
     * @param {superspeciality_consultationDeleteArgs} args - Arguments to delete one Superspeciality_consultation.
     * @example
     * // Delete one Superspeciality_consultation
     * const Superspeciality_consultation = await prisma.superspeciality_consultation.delete({
     *   where: {
     *     // ... filter to delete one Superspeciality_consultation
     *   }
     * })
     * 
     */
    delete<T extends superspeciality_consultationDeleteArgs>(args: SelectSubset<T, superspeciality_consultationDeleteArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Superspeciality_consultation.
     * @param {superspeciality_consultationUpdateArgs} args - Arguments to update one Superspeciality_consultation.
     * @example
     * // Update one Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends superspeciality_consultationUpdateArgs>(args: SelectSubset<T, superspeciality_consultationUpdateArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Superspeciality_consultations.
     * @param {superspeciality_consultationDeleteManyArgs} args - Arguments to filter Superspeciality_consultations to delete.
     * @example
     * // Delete a few Superspeciality_consultations
     * const { count } = await prisma.superspeciality_consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends superspeciality_consultationDeleteManyArgs>(args?: SelectSubset<T, superspeciality_consultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Superspeciality_consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superspeciality_consultations
     * const superspeciality_consultation = await prisma.superspeciality_consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends superspeciality_consultationUpdateManyArgs>(args: SelectSubset<T, superspeciality_consultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Superspeciality_consultation.
     * @param {superspeciality_consultationUpsertArgs} args - Arguments to update or create a Superspeciality_consultation.
     * @example
     * // Update or create a Superspeciality_consultation
     * const superspeciality_consultation = await prisma.superspeciality_consultation.upsert({
     *   create: {
     *     // ... data to create a Superspeciality_consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superspeciality_consultation we want to update
     *   }
     * })
     */
    upsert<T extends superspeciality_consultationUpsertArgs>(args: SelectSubset<T, superspeciality_consultationUpsertArgs<ExtArgs>>): Prisma__superspeciality_consultationClient<$Result.GetResult<Prisma.$superspeciality_consultationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Superspeciality_consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationCountArgs} args - Arguments to filter Superspeciality_consultations to count.
     * @example
     * // Count the number of Superspeciality_consultations
     * const count = await prisma.superspeciality_consultation.count({
     *   where: {
     *     // ... the filter for the Superspeciality_consultations we want to count
     *   }
     * })
    **/
    count<T extends superspeciality_consultationCountArgs>(
      args?: Subset<T, superspeciality_consultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Superspeciality_consultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Superspeciality_consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Superspeciality_consultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Superspeciality_consultationAggregateArgs>(args: Subset<T, Superspeciality_consultationAggregateArgs>): Prisma.PrismaPromise<GetSuperspeciality_consultationAggregateType<T>>

    /**
     * Group by Superspeciality_consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_consultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends superspeciality_consultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superspeciality_consultationGroupByArgs['orderBy'] }
        : { orderBy?: superspeciality_consultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, superspeciality_consultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperspeciality_consultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the superspeciality_consultation model
   */
  readonly fields: superspeciality_consultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superspeciality_consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superspeciality_consultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the superspeciality_consultation model
   */ 
  interface superspeciality_consultationFieldRefs {
    readonly ss_id: FieldRef<"superspeciality_consultation", 'Int'>
    readonly laboratory_id: FieldRef<"superspeciality_consultation", 'Int'>
    readonly referral_patient_id: FieldRef<"superspeciality_consultation", 'Int'>
    readonly patient_dep_id: FieldRef<"superspeciality_consultation", 'Int'>
    readonly superspeciality_id: FieldRef<"superspeciality_consultation", 'Int'>
    readonly comments: FieldRef<"superspeciality_consultation", 'String'>
    readonly by_assign: FieldRef<"superspeciality_consultation", 'Int'>
    readonly to_assign: FieldRef<"superspeciality_consultation", 'Int'>
    readonly referdate: FieldRef<"superspeciality_consultation", 'DateTime'>
    readonly refertime: FieldRef<"superspeciality_consultation", 'String'>
    readonly referclinic_name: FieldRef<"superspeciality_consultation", 'String'>
    readonly consultationId: FieldRef<"superspeciality_consultation", 'Int'>
    readonly consultationDate: FieldRef<"superspeciality_consultation", 'DateTime'>
    readonly consultationAmount: FieldRef<"superspeciality_consultation", 'Int'>
    readonly miscellaneousAmount: FieldRef<"superspeciality_consultation", 'Int'>
    readonly totalAmount: FieldRef<"superspeciality_consultation", 'Int'>
    readonly status: FieldRef<"superspeciality_consultation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * superspeciality_consultation findUnique
   */
  export type superspeciality_consultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_consultation to fetch.
     */
    where: superspeciality_consultationWhereUniqueInput
  }

  /**
   * superspeciality_consultation findUniqueOrThrow
   */
  export type superspeciality_consultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_consultation to fetch.
     */
    where: superspeciality_consultationWhereUniqueInput
  }

  /**
   * superspeciality_consultation findFirst
   */
  export type superspeciality_consultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_consultation to fetch.
     */
    where?: superspeciality_consultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_consultations to fetch.
     */
    orderBy?: superspeciality_consultationOrderByWithRelationInput | superspeciality_consultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superspeciality_consultations.
     */
    cursor?: superspeciality_consultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superspeciality_consultations.
     */
    distinct?: Superspeciality_consultationScalarFieldEnum | Superspeciality_consultationScalarFieldEnum[]
  }

  /**
   * superspeciality_consultation findFirstOrThrow
   */
  export type superspeciality_consultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_consultation to fetch.
     */
    where?: superspeciality_consultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_consultations to fetch.
     */
    orderBy?: superspeciality_consultationOrderByWithRelationInput | superspeciality_consultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superspeciality_consultations.
     */
    cursor?: superspeciality_consultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superspeciality_consultations.
     */
    distinct?: Superspeciality_consultationScalarFieldEnum | Superspeciality_consultationScalarFieldEnum[]
  }

  /**
   * superspeciality_consultation findMany
   */
  export type superspeciality_consultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_consultations to fetch.
     */
    where?: superspeciality_consultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_consultations to fetch.
     */
    orderBy?: superspeciality_consultationOrderByWithRelationInput | superspeciality_consultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing superspeciality_consultations.
     */
    cursor?: superspeciality_consultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_consultations.
     */
    skip?: number
    distinct?: Superspeciality_consultationScalarFieldEnum | Superspeciality_consultationScalarFieldEnum[]
  }

  /**
   * superspeciality_consultation create
   */
  export type superspeciality_consultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * The data needed to create a superspeciality_consultation.
     */
    data: XOR<superspeciality_consultationCreateInput, superspeciality_consultationUncheckedCreateInput>
  }

  /**
   * superspeciality_consultation createMany
   */
  export type superspeciality_consultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many superspeciality_consultations.
     */
    data: superspeciality_consultationCreateManyInput | superspeciality_consultationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * superspeciality_consultation update
   */
  export type superspeciality_consultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * The data needed to update a superspeciality_consultation.
     */
    data: XOR<superspeciality_consultationUpdateInput, superspeciality_consultationUncheckedUpdateInput>
    /**
     * Choose, which superspeciality_consultation to update.
     */
    where: superspeciality_consultationWhereUniqueInput
  }

  /**
   * superspeciality_consultation updateMany
   */
  export type superspeciality_consultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update superspeciality_consultations.
     */
    data: XOR<superspeciality_consultationUpdateManyMutationInput, superspeciality_consultationUncheckedUpdateManyInput>
    /**
     * Filter which superspeciality_consultations to update
     */
    where?: superspeciality_consultationWhereInput
  }

  /**
   * superspeciality_consultation upsert
   */
  export type superspeciality_consultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * The filter to search for the superspeciality_consultation to update in case it exists.
     */
    where: superspeciality_consultationWhereUniqueInput
    /**
     * In case the superspeciality_consultation found by the `where` argument doesn't exist, create a new superspeciality_consultation with this data.
     */
    create: XOR<superspeciality_consultationCreateInput, superspeciality_consultationUncheckedCreateInput>
    /**
     * In case the superspeciality_consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<superspeciality_consultationUpdateInput, superspeciality_consultationUncheckedUpdateInput>
  }

  /**
   * superspeciality_consultation delete
   */
  export type superspeciality_consultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
    /**
     * Filter which superspeciality_consultation to delete.
     */
    where: superspeciality_consultationWhereUniqueInput
  }

  /**
   * superspeciality_consultation deleteMany
   */
  export type superspeciality_consultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superspeciality_consultations to delete
     */
    where?: superspeciality_consultationWhereInput
  }

  /**
   * superspeciality_consultation without action
   */
  export type superspeciality_consultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_consultation
     */
    select?: superspeciality_consultationSelect<ExtArgs> | null
  }


  /**
   * Model superspeciality_details
   */

  export type AggregateSuperspeciality_details = {
    _count: Superspeciality_detailsCountAggregateOutputType | null
    _avg: Superspeciality_detailsAvgAggregateOutputType | null
    _sum: Superspeciality_detailsSumAggregateOutputType | null
    _min: Superspeciality_detailsMinAggregateOutputType | null
    _max: Superspeciality_detailsMaxAggregateOutputType | null
  }

  export type Superspeciality_detailsAvgAggregateOutputType = {
    speciality_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    by_assign: number | null
    to_assign: number | null
    active: number | null
    laboratory_id: number | null
  }

  export type Superspeciality_detailsSumAggregateOutputType = {
    speciality_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    by_assign: number | null
    to_assign: number | null
    active: number | null
    laboratory_id: number | null
  }

  export type Superspeciality_detailsMinAggregateOutputType = {
    speciality_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    comments: string | null
    by_assign: number | null
    to_assign: number | null
    referdate: Date | null
    refertime: string | null
    referclinic_name: string | null
    created_on: Date | null
    active: number | null
    laboratory_id: number | null
  }

  export type Superspeciality_detailsMaxAggregateOutputType = {
    speciality_id: number | null
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    comments: string | null
    by_assign: number | null
    to_assign: number | null
    referdate: Date | null
    refertime: string | null
    referclinic_name: string | null
    created_on: Date | null
    active: number | null
    laboratory_id: number | null
  }

  export type Superspeciality_detailsCountAggregateOutputType = {
    speciality_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: number
    by_assign: number
    to_assign: number
    referdate: number
    refertime: number
    referclinic_name: number
    created_on: number
    active: number
    laboratory_id: number
    _all: number
  }


  export type Superspeciality_detailsAvgAggregateInputType = {
    speciality_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    by_assign?: true
    to_assign?: true
    active?: true
    laboratory_id?: true
  }

  export type Superspeciality_detailsSumAggregateInputType = {
    speciality_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    by_assign?: true
    to_assign?: true
    active?: true
    laboratory_id?: true
  }

  export type Superspeciality_detailsMinAggregateInputType = {
    speciality_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    created_on?: true
    active?: true
    laboratory_id?: true
  }

  export type Superspeciality_detailsMaxAggregateInputType = {
    speciality_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    created_on?: true
    active?: true
    laboratory_id?: true
  }

  export type Superspeciality_detailsCountAggregateInputType = {
    speciality_id?: true
    referral_patient_id?: true
    patient_dep_id?: true
    superspeciality_id?: true
    comments?: true
    by_assign?: true
    to_assign?: true
    referdate?: true
    refertime?: true
    referclinic_name?: true
    created_on?: true
    active?: true
    laboratory_id?: true
    _all?: true
  }

  export type Superspeciality_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superspeciality_details to aggregate.
     */
    where?: superspeciality_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_details to fetch.
     */
    orderBy?: superspeciality_detailsOrderByWithRelationInput | superspeciality_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: superspeciality_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned superspeciality_details
    **/
    _count?: true | Superspeciality_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Superspeciality_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Superspeciality_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Superspeciality_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Superspeciality_detailsMaxAggregateInputType
  }

  export type GetSuperspeciality_detailsAggregateType<T extends Superspeciality_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperspeciality_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperspeciality_details[P]>
      : GetScalarType<T[P], AggregateSuperspeciality_details[P]>
  }




  export type superspeciality_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: superspeciality_detailsWhereInput
    orderBy?: superspeciality_detailsOrderByWithAggregationInput | superspeciality_detailsOrderByWithAggregationInput[]
    by: Superspeciality_detailsScalarFieldEnum[] | Superspeciality_detailsScalarFieldEnum
    having?: superspeciality_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Superspeciality_detailsCountAggregateInputType | true
    _avg?: Superspeciality_detailsAvgAggregateInputType
    _sum?: Superspeciality_detailsSumAggregateInputType
    _min?: Superspeciality_detailsMinAggregateInputType
    _max?: Superspeciality_detailsMaxAggregateInputType
  }

  export type Superspeciality_detailsGroupByOutputType = {
    speciality_id: number
    referral_patient_id: number | null
    patient_dep_id: number | null
    superspeciality_id: number | null
    comments: string | null
    by_assign: number | null
    to_assign: number | null
    referdate: Date | null
    refertime: string | null
    referclinic_name: string | null
    created_on: Date
    active: number
    laboratory_id: number
    _count: Superspeciality_detailsCountAggregateOutputType | null
    _avg: Superspeciality_detailsAvgAggregateOutputType | null
    _sum: Superspeciality_detailsSumAggregateOutputType | null
    _min: Superspeciality_detailsMinAggregateOutputType | null
    _max: Superspeciality_detailsMaxAggregateOutputType | null
  }

  type GetSuperspeciality_detailsGroupByPayload<T extends superspeciality_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Superspeciality_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Superspeciality_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Superspeciality_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Superspeciality_detailsGroupByOutputType[P]>
        }
      >
    >


  export type superspeciality_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speciality_id?: boolean
    referral_patient_id?: boolean
    patient_dep_id?: boolean
    superspeciality_id?: boolean
    comments?: boolean
    by_assign?: boolean
    to_assign?: boolean
    referdate?: boolean
    refertime?: boolean
    referclinic_name?: boolean
    created_on?: boolean
    active?: boolean
    laboratory_id?: boolean
  }, ExtArgs["result"]["superspeciality_details"]>


  export type superspeciality_detailsSelectScalar = {
    speciality_id?: boolean
    referral_patient_id?: boolean
    patient_dep_id?: boolean
    superspeciality_id?: boolean
    comments?: boolean
    by_assign?: boolean
    to_assign?: boolean
    referdate?: boolean
    refertime?: boolean
    referclinic_name?: boolean
    created_on?: boolean
    active?: boolean
    laboratory_id?: boolean
  }


  export type $superspeciality_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "superspeciality_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      speciality_id: number
      referral_patient_id: number | null
      patient_dep_id: number | null
      superspeciality_id: number | null
      comments: string | null
      by_assign: number | null
      to_assign: number | null
      referdate: Date | null
      refertime: string | null
      referclinic_name: string | null
      created_on: Date
      active: number
      laboratory_id: number
    }, ExtArgs["result"]["superspeciality_details"]>
    composites: {}
  }

  type superspeciality_detailsGetPayload<S extends boolean | null | undefined | superspeciality_detailsDefaultArgs> = $Result.GetResult<Prisma.$superspeciality_detailsPayload, S>

  type superspeciality_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<superspeciality_detailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Superspeciality_detailsCountAggregateInputType | true
    }

  export interface superspeciality_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['superspeciality_details'], meta: { name: 'superspeciality_details' } }
    /**
     * Find zero or one Superspeciality_details that matches the filter.
     * @param {superspeciality_detailsFindUniqueArgs} args - Arguments to find a Superspeciality_details
     * @example
     * // Get one Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superspeciality_detailsFindUniqueArgs>(args: SelectSubset<T, superspeciality_detailsFindUniqueArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Superspeciality_details that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {superspeciality_detailsFindUniqueOrThrowArgs} args - Arguments to find a Superspeciality_details
     * @example
     * // Get one Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends superspeciality_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, superspeciality_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Superspeciality_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsFindFirstArgs} args - Arguments to find a Superspeciality_details
     * @example
     * // Get one Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superspeciality_detailsFindFirstArgs>(args?: SelectSubset<T, superspeciality_detailsFindFirstArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Superspeciality_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsFindFirstOrThrowArgs} args - Arguments to find a Superspeciality_details
     * @example
     * // Get one Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superspeciality_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, superspeciality_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Superspeciality_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findMany()
     * 
     * // Get first 10 Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.findMany({ take: 10 })
     * 
     * // Only select the `speciality_id`
     * const superspeciality_detailsWithSpeciality_idOnly = await prisma.superspeciality_details.findMany({ select: { speciality_id: true } })
     * 
     */
    findMany<T extends superspeciality_detailsFindManyArgs>(args?: SelectSubset<T, superspeciality_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Superspeciality_details.
     * @param {superspeciality_detailsCreateArgs} args - Arguments to create a Superspeciality_details.
     * @example
     * // Create one Superspeciality_details
     * const Superspeciality_details = await prisma.superspeciality_details.create({
     *   data: {
     *     // ... data to create a Superspeciality_details
     *   }
     * })
     * 
     */
    create<T extends superspeciality_detailsCreateArgs>(args: SelectSubset<T, superspeciality_detailsCreateArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Superspeciality_details.
     * @param {superspeciality_detailsCreateManyArgs} args - Arguments to create many Superspeciality_details.
     * @example
     * // Create many Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends superspeciality_detailsCreateManyArgs>(args?: SelectSubset<T, superspeciality_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Superspeciality_details.
     * @param {superspeciality_detailsDeleteArgs} args - Arguments to delete one Superspeciality_details.
     * @example
     * // Delete one Superspeciality_details
     * const Superspeciality_details = await prisma.superspeciality_details.delete({
     *   where: {
     *     // ... filter to delete one Superspeciality_details
     *   }
     * })
     * 
     */
    delete<T extends superspeciality_detailsDeleteArgs>(args: SelectSubset<T, superspeciality_detailsDeleteArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Superspeciality_details.
     * @param {superspeciality_detailsUpdateArgs} args - Arguments to update one Superspeciality_details.
     * @example
     * // Update one Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends superspeciality_detailsUpdateArgs>(args: SelectSubset<T, superspeciality_detailsUpdateArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Superspeciality_details.
     * @param {superspeciality_detailsDeleteManyArgs} args - Arguments to filter Superspeciality_details to delete.
     * @example
     * // Delete a few Superspeciality_details
     * const { count } = await prisma.superspeciality_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends superspeciality_detailsDeleteManyArgs>(args?: SelectSubset<T, superspeciality_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Superspeciality_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends superspeciality_detailsUpdateManyArgs>(args: SelectSubset<T, superspeciality_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Superspeciality_details.
     * @param {superspeciality_detailsUpsertArgs} args - Arguments to update or create a Superspeciality_details.
     * @example
     * // Update or create a Superspeciality_details
     * const superspeciality_details = await prisma.superspeciality_details.upsert({
     *   create: {
     *     // ... data to create a Superspeciality_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Superspeciality_details we want to update
     *   }
     * })
     */
    upsert<T extends superspeciality_detailsUpsertArgs>(args: SelectSubset<T, superspeciality_detailsUpsertArgs<ExtArgs>>): Prisma__superspeciality_detailsClient<$Result.GetResult<Prisma.$superspeciality_detailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Superspeciality_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsCountArgs} args - Arguments to filter Superspeciality_details to count.
     * @example
     * // Count the number of Superspeciality_details
     * const count = await prisma.superspeciality_details.count({
     *   where: {
     *     // ... the filter for the Superspeciality_details we want to count
     *   }
     * })
    **/
    count<T extends superspeciality_detailsCountArgs>(
      args?: Subset<T, superspeciality_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Superspeciality_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Superspeciality_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Superspeciality_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Superspeciality_detailsAggregateArgs>(args: Subset<T, Superspeciality_detailsAggregateArgs>): Prisma.PrismaPromise<GetSuperspeciality_detailsAggregateType<T>>

    /**
     * Group by Superspeciality_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superspeciality_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends superspeciality_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superspeciality_detailsGroupByArgs['orderBy'] }
        : { orderBy?: superspeciality_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, superspeciality_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperspeciality_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the superspeciality_details model
   */
  readonly fields: superspeciality_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superspeciality_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superspeciality_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the superspeciality_details model
   */ 
  interface superspeciality_detailsFieldRefs {
    readonly speciality_id: FieldRef<"superspeciality_details", 'Int'>
    readonly referral_patient_id: FieldRef<"superspeciality_details", 'Int'>
    readonly patient_dep_id: FieldRef<"superspeciality_details", 'Int'>
    readonly superspeciality_id: FieldRef<"superspeciality_details", 'Int'>
    readonly comments: FieldRef<"superspeciality_details", 'String'>
    readonly by_assign: FieldRef<"superspeciality_details", 'Int'>
    readonly to_assign: FieldRef<"superspeciality_details", 'Int'>
    readonly referdate: FieldRef<"superspeciality_details", 'DateTime'>
    readonly refertime: FieldRef<"superspeciality_details", 'String'>
    readonly referclinic_name: FieldRef<"superspeciality_details", 'String'>
    readonly created_on: FieldRef<"superspeciality_details", 'DateTime'>
    readonly active: FieldRef<"superspeciality_details", 'Int'>
    readonly laboratory_id: FieldRef<"superspeciality_details", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * superspeciality_details findUnique
   */
  export type superspeciality_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_details to fetch.
     */
    where: superspeciality_detailsWhereUniqueInput
  }

  /**
   * superspeciality_details findUniqueOrThrow
   */
  export type superspeciality_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_details to fetch.
     */
    where: superspeciality_detailsWhereUniqueInput
  }

  /**
   * superspeciality_details findFirst
   */
  export type superspeciality_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_details to fetch.
     */
    where?: superspeciality_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_details to fetch.
     */
    orderBy?: superspeciality_detailsOrderByWithRelationInput | superspeciality_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superspeciality_details.
     */
    cursor?: superspeciality_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superspeciality_details.
     */
    distinct?: Superspeciality_detailsScalarFieldEnum | Superspeciality_detailsScalarFieldEnum[]
  }

  /**
   * superspeciality_details findFirstOrThrow
   */
  export type superspeciality_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_details to fetch.
     */
    where?: superspeciality_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_details to fetch.
     */
    orderBy?: superspeciality_detailsOrderByWithRelationInput | superspeciality_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superspeciality_details.
     */
    cursor?: superspeciality_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superspeciality_details.
     */
    distinct?: Superspeciality_detailsScalarFieldEnum | Superspeciality_detailsScalarFieldEnum[]
  }

  /**
   * superspeciality_details findMany
   */
  export type superspeciality_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter, which superspeciality_details to fetch.
     */
    where?: superspeciality_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superspeciality_details to fetch.
     */
    orderBy?: superspeciality_detailsOrderByWithRelationInput | superspeciality_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing superspeciality_details.
     */
    cursor?: superspeciality_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superspeciality_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superspeciality_details.
     */
    skip?: number
    distinct?: Superspeciality_detailsScalarFieldEnum | Superspeciality_detailsScalarFieldEnum[]
  }

  /**
   * superspeciality_details create
   */
  export type superspeciality_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a superspeciality_details.
     */
    data?: XOR<superspeciality_detailsCreateInput, superspeciality_detailsUncheckedCreateInput>
  }

  /**
   * superspeciality_details createMany
   */
  export type superspeciality_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many superspeciality_details.
     */
    data: superspeciality_detailsCreateManyInput | superspeciality_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * superspeciality_details update
   */
  export type superspeciality_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a superspeciality_details.
     */
    data: XOR<superspeciality_detailsUpdateInput, superspeciality_detailsUncheckedUpdateInput>
    /**
     * Choose, which superspeciality_details to update.
     */
    where: superspeciality_detailsWhereUniqueInput
  }

  /**
   * superspeciality_details updateMany
   */
  export type superspeciality_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update superspeciality_details.
     */
    data: XOR<superspeciality_detailsUpdateManyMutationInput, superspeciality_detailsUncheckedUpdateManyInput>
    /**
     * Filter which superspeciality_details to update
     */
    where?: superspeciality_detailsWhereInput
  }

  /**
   * superspeciality_details upsert
   */
  export type superspeciality_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the superspeciality_details to update in case it exists.
     */
    where: superspeciality_detailsWhereUniqueInput
    /**
     * In case the superspeciality_details found by the `where` argument doesn't exist, create a new superspeciality_details with this data.
     */
    create: XOR<superspeciality_detailsCreateInput, superspeciality_detailsUncheckedCreateInput>
    /**
     * In case the superspeciality_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<superspeciality_detailsUpdateInput, superspeciality_detailsUncheckedUpdateInput>
  }

  /**
   * superspeciality_details delete
   */
  export type superspeciality_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
    /**
     * Filter which superspeciality_details to delete.
     */
    where: superspeciality_detailsWhereUniqueInput
  }

  /**
   * superspeciality_details deleteMany
   */
  export type superspeciality_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superspeciality_details to delete
     */
    where?: superspeciality_detailsWhereInput
  }

  /**
   * superspeciality_details without action
   */
  export type superspeciality_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superspeciality_details
     */
    select?: superspeciality_detailsSelect<ExtArgs> | null
  }


  /**
   * Model test_report_notes
   */

  export type AggregateTest_report_notes = {
    _count: Test_report_notesCountAggregateOutputType | null
    _avg: Test_report_notesAvgAggregateOutputType | null
    _sum: Test_report_notesSumAggregateOutputType | null
    _min: Test_report_notesMinAggregateOutputType | null
    _max: Test_report_notesMaxAggregateOutputType | null
  }

  export type Test_report_notesAvgAggregateOutputType = {
    test_report_notes_id: number | null
    referral_patient_test_details_id: number | null
  }

  export type Test_report_notesSumAggregateOutputType = {
    test_report_notes_id: number | null
    referral_patient_test_details_id: number | null
  }

  export type Test_report_notesMinAggregateOutputType = {
    test_report_notes_id: number | null
    laboratory_tests: string | null
    medical_num: string | null
    referral_patient_test_details_id: number | null
    title: string | null
    description: string | null
    added_date: Date | null
  }

  export type Test_report_notesMaxAggregateOutputType = {
    test_report_notes_id: number | null
    laboratory_tests: string | null
    medical_num: string | null
    referral_patient_test_details_id: number | null
    title: string | null
    description: string | null
    added_date: Date | null
  }

  export type Test_report_notesCountAggregateOutputType = {
    test_report_notes_id: number
    laboratory_tests: number
    medical_num: number
    referral_patient_test_details_id: number
    title: number
    description: number
    added_date: number
    _all: number
  }


  export type Test_report_notesAvgAggregateInputType = {
    test_report_notes_id?: true
    referral_patient_test_details_id?: true
  }

  export type Test_report_notesSumAggregateInputType = {
    test_report_notes_id?: true
    referral_patient_test_details_id?: true
  }

  export type Test_report_notesMinAggregateInputType = {
    test_report_notes_id?: true
    laboratory_tests?: true
    medical_num?: true
    referral_patient_test_details_id?: true
    title?: true
    description?: true
    added_date?: true
  }

  export type Test_report_notesMaxAggregateInputType = {
    test_report_notes_id?: true
    laboratory_tests?: true
    medical_num?: true
    referral_patient_test_details_id?: true
    title?: true
    description?: true
    added_date?: true
  }

  export type Test_report_notesCountAggregateInputType = {
    test_report_notes_id?: true
    laboratory_tests?: true
    medical_num?: true
    referral_patient_test_details_id?: true
    title?: true
    description?: true
    added_date?: true
    _all?: true
  }

  export type Test_report_notesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_report_notes to aggregate.
     */
    where?: test_report_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_report_notes to fetch.
     */
    orderBy?: test_report_notesOrderByWithRelationInput | test_report_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_report_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_report_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_report_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_report_notes
    **/
    _count?: true | Test_report_notesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_report_notesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_report_notesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_report_notesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_report_notesMaxAggregateInputType
  }

  export type GetTest_report_notesAggregateType<T extends Test_report_notesAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_report_notes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_report_notes[P]>
      : GetScalarType<T[P], AggregateTest_report_notes[P]>
  }




  export type test_report_notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_report_notesWhereInput
    orderBy?: test_report_notesOrderByWithAggregationInput | test_report_notesOrderByWithAggregationInput[]
    by: Test_report_notesScalarFieldEnum[] | Test_report_notesScalarFieldEnum
    having?: test_report_notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_report_notesCountAggregateInputType | true
    _avg?: Test_report_notesAvgAggregateInputType
    _sum?: Test_report_notesSumAggregateInputType
    _min?: Test_report_notesMinAggregateInputType
    _max?: Test_report_notesMaxAggregateInputType
  }

  export type Test_report_notesGroupByOutputType = {
    test_report_notes_id: number
    laboratory_tests: string
    medical_num: string
    referral_patient_test_details_id: number
    title: string | null
    description: string
    added_date: Date
    _count: Test_report_notesCountAggregateOutputType | null
    _avg: Test_report_notesAvgAggregateOutputType | null
    _sum: Test_report_notesSumAggregateOutputType | null
    _min: Test_report_notesMinAggregateOutputType | null
    _max: Test_report_notesMaxAggregateOutputType | null
  }

  type GetTest_report_notesGroupByPayload<T extends test_report_notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_report_notesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_report_notesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_report_notesGroupByOutputType[P]>
            : GetScalarType<T[P], Test_report_notesGroupByOutputType[P]>
        }
      >
    >


  export type test_report_notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_report_notes_id?: boolean
    laboratory_tests?: boolean
    medical_num?: boolean
    referral_patient_test_details_id?: boolean
    title?: boolean
    description?: boolean
    added_date?: boolean
  }, ExtArgs["result"]["test_report_notes"]>


  export type test_report_notesSelectScalar = {
    test_report_notes_id?: boolean
    laboratory_tests?: boolean
    medical_num?: boolean
    referral_patient_test_details_id?: boolean
    title?: boolean
    description?: boolean
    added_date?: boolean
  }


  export type $test_report_notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_report_notes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      test_report_notes_id: number
      laboratory_tests: string
      medical_num: string
      referral_patient_test_details_id: number
      title: string | null
      description: string
      added_date: Date
    }, ExtArgs["result"]["test_report_notes"]>
    composites: {}
  }

  type test_report_notesGetPayload<S extends boolean | null | undefined | test_report_notesDefaultArgs> = $Result.GetResult<Prisma.$test_report_notesPayload, S>

  type test_report_notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<test_report_notesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Test_report_notesCountAggregateInputType | true
    }

  export interface test_report_notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_report_notes'], meta: { name: 'test_report_notes' } }
    /**
     * Find zero or one Test_report_notes that matches the filter.
     * @param {test_report_notesFindUniqueArgs} args - Arguments to find a Test_report_notes
     * @example
     * // Get one Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_report_notesFindUniqueArgs>(args: SelectSubset<T, test_report_notesFindUniqueArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Test_report_notes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {test_report_notesFindUniqueOrThrowArgs} args - Arguments to find a Test_report_notes
     * @example
     * // Get one Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_report_notesFindUniqueOrThrowArgs>(args: SelectSubset<T, test_report_notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Test_report_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesFindFirstArgs} args - Arguments to find a Test_report_notes
     * @example
     * // Get one Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_report_notesFindFirstArgs>(args?: SelectSubset<T, test_report_notesFindFirstArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Test_report_notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesFindFirstOrThrowArgs} args - Arguments to find a Test_report_notes
     * @example
     * // Get one Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_report_notesFindFirstOrThrowArgs>(args?: SelectSubset<T, test_report_notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Test_report_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findMany()
     * 
     * // Get first 10 Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.findMany({ take: 10 })
     * 
     * // Only select the `test_report_notes_id`
     * const test_report_notesWithTest_report_notes_idOnly = await prisma.test_report_notes.findMany({ select: { test_report_notes_id: true } })
     * 
     */
    findMany<T extends test_report_notesFindManyArgs>(args?: SelectSubset<T, test_report_notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Test_report_notes.
     * @param {test_report_notesCreateArgs} args - Arguments to create a Test_report_notes.
     * @example
     * // Create one Test_report_notes
     * const Test_report_notes = await prisma.test_report_notes.create({
     *   data: {
     *     // ... data to create a Test_report_notes
     *   }
     * })
     * 
     */
    create<T extends test_report_notesCreateArgs>(args: SelectSubset<T, test_report_notesCreateArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Test_report_notes.
     * @param {test_report_notesCreateManyArgs} args - Arguments to create many Test_report_notes.
     * @example
     * // Create many Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_report_notesCreateManyArgs>(args?: SelectSubset<T, test_report_notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_report_notes.
     * @param {test_report_notesDeleteArgs} args - Arguments to delete one Test_report_notes.
     * @example
     * // Delete one Test_report_notes
     * const Test_report_notes = await prisma.test_report_notes.delete({
     *   where: {
     *     // ... filter to delete one Test_report_notes
     *   }
     * })
     * 
     */
    delete<T extends test_report_notesDeleteArgs>(args: SelectSubset<T, test_report_notesDeleteArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Test_report_notes.
     * @param {test_report_notesUpdateArgs} args - Arguments to update one Test_report_notes.
     * @example
     * // Update one Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_report_notesUpdateArgs>(args: SelectSubset<T, test_report_notesUpdateArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Test_report_notes.
     * @param {test_report_notesDeleteManyArgs} args - Arguments to filter Test_report_notes to delete.
     * @example
     * // Delete a few Test_report_notes
     * const { count } = await prisma.test_report_notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_report_notesDeleteManyArgs>(args?: SelectSubset<T, test_report_notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_report_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_report_notesUpdateManyArgs>(args: SelectSubset<T, test_report_notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_report_notes.
     * @param {test_report_notesUpsertArgs} args - Arguments to update or create a Test_report_notes.
     * @example
     * // Update or create a Test_report_notes
     * const test_report_notes = await prisma.test_report_notes.upsert({
     *   create: {
     *     // ... data to create a Test_report_notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_report_notes we want to update
     *   }
     * })
     */
    upsert<T extends test_report_notesUpsertArgs>(args: SelectSubset<T, test_report_notesUpsertArgs<ExtArgs>>): Prisma__test_report_notesClient<$Result.GetResult<Prisma.$test_report_notesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Test_report_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesCountArgs} args - Arguments to filter Test_report_notes to count.
     * @example
     * // Count the number of Test_report_notes
     * const count = await prisma.test_report_notes.count({
     *   where: {
     *     // ... the filter for the Test_report_notes we want to count
     *   }
     * })
    **/
    count<T extends test_report_notesCountArgs>(
      args?: Subset<T, test_report_notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_report_notesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_report_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_report_notesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_report_notesAggregateArgs>(args: Subset<T, Test_report_notesAggregateArgs>): Prisma.PrismaPromise<GetTest_report_notesAggregateType<T>>

    /**
     * Group by Test_report_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_report_notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_report_notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_report_notesGroupByArgs['orderBy'] }
        : { orderBy?: test_report_notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_report_notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_report_notesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_report_notes model
   */
  readonly fields: test_report_notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_report_notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_report_notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_report_notes model
   */ 
  interface test_report_notesFieldRefs {
    readonly test_report_notes_id: FieldRef<"test_report_notes", 'Int'>
    readonly laboratory_tests: FieldRef<"test_report_notes", 'String'>
    readonly medical_num: FieldRef<"test_report_notes", 'String'>
    readonly referral_patient_test_details_id: FieldRef<"test_report_notes", 'Int'>
    readonly title: FieldRef<"test_report_notes", 'String'>
    readonly description: FieldRef<"test_report_notes", 'String'>
    readonly added_date: FieldRef<"test_report_notes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_report_notes findUnique
   */
  export type test_report_notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter, which test_report_notes to fetch.
     */
    where: test_report_notesWhereUniqueInput
  }

  /**
   * test_report_notes findUniqueOrThrow
   */
  export type test_report_notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter, which test_report_notes to fetch.
     */
    where: test_report_notesWhereUniqueInput
  }

  /**
   * test_report_notes findFirst
   */
  export type test_report_notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter, which test_report_notes to fetch.
     */
    where?: test_report_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_report_notes to fetch.
     */
    orderBy?: test_report_notesOrderByWithRelationInput | test_report_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_report_notes.
     */
    cursor?: test_report_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_report_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_report_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_report_notes.
     */
    distinct?: Test_report_notesScalarFieldEnum | Test_report_notesScalarFieldEnum[]
  }

  /**
   * test_report_notes findFirstOrThrow
   */
  export type test_report_notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter, which test_report_notes to fetch.
     */
    where?: test_report_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_report_notes to fetch.
     */
    orderBy?: test_report_notesOrderByWithRelationInput | test_report_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_report_notes.
     */
    cursor?: test_report_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_report_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_report_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_report_notes.
     */
    distinct?: Test_report_notesScalarFieldEnum | Test_report_notesScalarFieldEnum[]
  }

  /**
   * test_report_notes findMany
   */
  export type test_report_notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter, which test_report_notes to fetch.
     */
    where?: test_report_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_report_notes to fetch.
     */
    orderBy?: test_report_notesOrderByWithRelationInput | test_report_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_report_notes.
     */
    cursor?: test_report_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_report_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_report_notes.
     */
    skip?: number
    distinct?: Test_report_notesScalarFieldEnum | Test_report_notesScalarFieldEnum[]
  }

  /**
   * test_report_notes create
   */
  export type test_report_notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * The data needed to create a test_report_notes.
     */
    data: XOR<test_report_notesCreateInput, test_report_notesUncheckedCreateInput>
  }

  /**
   * test_report_notes createMany
   */
  export type test_report_notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_report_notes.
     */
    data: test_report_notesCreateManyInput | test_report_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_report_notes update
   */
  export type test_report_notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * The data needed to update a test_report_notes.
     */
    data: XOR<test_report_notesUpdateInput, test_report_notesUncheckedUpdateInput>
    /**
     * Choose, which test_report_notes to update.
     */
    where: test_report_notesWhereUniqueInput
  }

  /**
   * test_report_notes updateMany
   */
  export type test_report_notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_report_notes.
     */
    data: XOR<test_report_notesUpdateManyMutationInput, test_report_notesUncheckedUpdateManyInput>
    /**
     * Filter which test_report_notes to update
     */
    where?: test_report_notesWhereInput
  }

  /**
   * test_report_notes upsert
   */
  export type test_report_notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * The filter to search for the test_report_notes to update in case it exists.
     */
    where: test_report_notesWhereUniqueInput
    /**
     * In case the test_report_notes found by the `where` argument doesn't exist, create a new test_report_notes with this data.
     */
    create: XOR<test_report_notesCreateInput, test_report_notesUncheckedCreateInput>
    /**
     * In case the test_report_notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_report_notesUpdateInput, test_report_notesUncheckedUpdateInput>
  }

  /**
   * test_report_notes delete
   */
  export type test_report_notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
    /**
     * Filter which test_report_notes to delete.
     */
    where: test_report_notesWhereUniqueInput
  }

  /**
   * test_report_notes deleteMany
   */
  export type test_report_notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_report_notes to delete
     */
    where?: test_report_notesWhereInput
  }

  /**
   * test_report_notes without action
   */
  export type test_report_notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_report_notes
     */
    select?: test_report_notesSelect<ExtArgs> | null
  }


  /**
   * Model update_labs
   */

  export type AggregateUpdate_labs = {
    _count: Update_labsCountAggregateOutputType | null
    _avg: Update_labsAvgAggregateOutputType | null
    _sum: Update_labsSumAggregateOutputType | null
    _min: Update_labsMinAggregateOutputType | null
    _max: Update_labsMaxAggregateOutputType | null
  }

  export type Update_labsAvgAggregateOutputType = {
    update_labid: number | null
    laboratory_id: number | null
    phonenum_doesnt_exist: number | null
    print_billing: number | null
    collection_report: number | null
    test_report: number | null
    active: number | null
  }

  export type Update_labsSumAggregateOutputType = {
    update_labid: number | null
    laboratory_id: number | null
    phonenum_doesnt_exist: number | null
    print_billing: number | null
    collection_report: number | null
    test_report: number | null
    active: number | null
  }

  export type Update_labsMinAggregateOutputType = {
    update_labid: number | null
    laboratory_id: number | null
    phonenum_doesnt_exist: number | null
    print_billing: number | null
    collection_report: number | null
    test_report: number | null
    active: number | null
  }

  export type Update_labsMaxAggregateOutputType = {
    update_labid: number | null
    laboratory_id: number | null
    phonenum_doesnt_exist: number | null
    print_billing: number | null
    collection_report: number | null
    test_report: number | null
    active: number | null
  }

  export type Update_labsCountAggregateOutputType = {
    update_labid: number
    laboratory_id: number
    phonenum_doesnt_exist: number
    print_billing: number
    collection_report: number
    test_report: number
    active: number
    _all: number
  }


  export type Update_labsAvgAggregateInputType = {
    update_labid?: true
    laboratory_id?: true
    phonenum_doesnt_exist?: true
    print_billing?: true
    collection_report?: true
    test_report?: true
    active?: true
  }

  export type Update_labsSumAggregateInputType = {
    update_labid?: true
    laboratory_id?: true
    phonenum_doesnt_exist?: true
    print_billing?: true
    collection_report?: true
    test_report?: true
    active?: true
  }

  export type Update_labsMinAggregateInputType = {
    update_labid?: true
    laboratory_id?: true
    phonenum_doesnt_exist?: true
    print_billing?: true
    collection_report?: true
    test_report?: true
    active?: true
  }

  export type Update_labsMaxAggregateInputType = {
    update_labid?: true
    laboratory_id?: true
    phonenum_doesnt_exist?: true
    print_billing?: true
    collection_report?: true
    test_report?: true
    active?: true
  }

  export type Update_labsCountAggregateInputType = {
    update_labid?: true
    laboratory_id?: true
    phonenum_doesnt_exist?: true
    print_billing?: true
    collection_report?: true
    test_report?: true
    active?: true
    _all?: true
  }

  export type Update_labsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which update_labs to aggregate.
     */
    where?: update_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of update_labs to fetch.
     */
    orderBy?: update_labsOrderByWithRelationInput | update_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: update_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` update_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` update_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned update_labs
    **/
    _count?: true | Update_labsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Update_labsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Update_labsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Update_labsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Update_labsMaxAggregateInputType
  }

  export type GetUpdate_labsAggregateType<T extends Update_labsAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdate_labs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdate_labs[P]>
      : GetScalarType<T[P], AggregateUpdate_labs[P]>
  }




  export type update_labsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: update_labsWhereInput
    orderBy?: update_labsOrderByWithAggregationInput | update_labsOrderByWithAggregationInput[]
    by: Update_labsScalarFieldEnum[] | Update_labsScalarFieldEnum
    having?: update_labsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Update_labsCountAggregateInputType | true
    _avg?: Update_labsAvgAggregateInputType
    _sum?: Update_labsSumAggregateInputType
    _min?: Update_labsMinAggregateInputType
    _max?: Update_labsMaxAggregateInputType
  }

  export type Update_labsGroupByOutputType = {
    update_labid: number
    laboratory_id: number
    phonenum_doesnt_exist: number
    print_billing: number
    collection_report: number
    test_report: number
    active: number
    _count: Update_labsCountAggregateOutputType | null
    _avg: Update_labsAvgAggregateOutputType | null
    _sum: Update_labsSumAggregateOutputType | null
    _min: Update_labsMinAggregateOutputType | null
    _max: Update_labsMaxAggregateOutputType | null
  }

  type GetUpdate_labsGroupByPayload<T extends update_labsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Update_labsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Update_labsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Update_labsGroupByOutputType[P]>
            : GetScalarType<T[P], Update_labsGroupByOutputType[P]>
        }
      >
    >


  export type update_labsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    update_labid?: boolean
    laboratory_id?: boolean
    phonenum_doesnt_exist?: boolean
    print_billing?: boolean
    collection_report?: boolean
    test_report?: boolean
    active?: boolean
  }, ExtArgs["result"]["update_labs"]>


  export type update_labsSelectScalar = {
    update_labid?: boolean
    laboratory_id?: boolean
    phonenum_doesnt_exist?: boolean
    print_billing?: boolean
    collection_report?: boolean
    test_report?: boolean
    active?: boolean
  }


  export type $update_labsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "update_labs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      update_labid: number
      laboratory_id: number
      phonenum_doesnt_exist: number
      print_billing: number
      collection_report: number
      test_report: number
      active: number
    }, ExtArgs["result"]["update_labs"]>
    composites: {}
  }

  type update_labsGetPayload<S extends boolean | null | undefined | update_labsDefaultArgs> = $Result.GetResult<Prisma.$update_labsPayload, S>

  type update_labsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<update_labsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Update_labsCountAggregateInputType | true
    }

  export interface update_labsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['update_labs'], meta: { name: 'update_labs' } }
    /**
     * Find zero or one Update_labs that matches the filter.
     * @param {update_labsFindUniqueArgs} args - Arguments to find a Update_labs
     * @example
     * // Get one Update_labs
     * const update_labs = await prisma.update_labs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends update_labsFindUniqueArgs>(args: SelectSubset<T, update_labsFindUniqueArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Update_labs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {update_labsFindUniqueOrThrowArgs} args - Arguments to find a Update_labs
     * @example
     * // Get one Update_labs
     * const update_labs = await prisma.update_labs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends update_labsFindUniqueOrThrowArgs>(args: SelectSubset<T, update_labsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Update_labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsFindFirstArgs} args - Arguments to find a Update_labs
     * @example
     * // Get one Update_labs
     * const update_labs = await prisma.update_labs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends update_labsFindFirstArgs>(args?: SelectSubset<T, update_labsFindFirstArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Update_labs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsFindFirstOrThrowArgs} args - Arguments to find a Update_labs
     * @example
     * // Get one Update_labs
     * const update_labs = await prisma.update_labs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends update_labsFindFirstOrThrowArgs>(args?: SelectSubset<T, update_labsFindFirstOrThrowArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Update_labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Update_labs
     * const update_labs = await prisma.update_labs.findMany()
     * 
     * // Get first 10 Update_labs
     * const update_labs = await prisma.update_labs.findMany({ take: 10 })
     * 
     * // Only select the `update_labid`
     * const update_labsWithUpdate_labidOnly = await prisma.update_labs.findMany({ select: { update_labid: true } })
     * 
     */
    findMany<T extends update_labsFindManyArgs>(args?: SelectSubset<T, update_labsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Update_labs.
     * @param {update_labsCreateArgs} args - Arguments to create a Update_labs.
     * @example
     * // Create one Update_labs
     * const Update_labs = await prisma.update_labs.create({
     *   data: {
     *     // ... data to create a Update_labs
     *   }
     * })
     * 
     */
    create<T extends update_labsCreateArgs>(args: SelectSubset<T, update_labsCreateArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Update_labs.
     * @param {update_labsCreateManyArgs} args - Arguments to create many Update_labs.
     * @example
     * // Create many Update_labs
     * const update_labs = await prisma.update_labs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends update_labsCreateManyArgs>(args?: SelectSubset<T, update_labsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Update_labs.
     * @param {update_labsDeleteArgs} args - Arguments to delete one Update_labs.
     * @example
     * // Delete one Update_labs
     * const Update_labs = await prisma.update_labs.delete({
     *   where: {
     *     // ... filter to delete one Update_labs
     *   }
     * })
     * 
     */
    delete<T extends update_labsDeleteArgs>(args: SelectSubset<T, update_labsDeleteArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Update_labs.
     * @param {update_labsUpdateArgs} args - Arguments to update one Update_labs.
     * @example
     * // Update one Update_labs
     * const update_labs = await prisma.update_labs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends update_labsUpdateArgs>(args: SelectSubset<T, update_labsUpdateArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Update_labs.
     * @param {update_labsDeleteManyArgs} args - Arguments to filter Update_labs to delete.
     * @example
     * // Delete a few Update_labs
     * const { count } = await prisma.update_labs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends update_labsDeleteManyArgs>(args?: SelectSubset<T, update_labsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Update_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Update_labs
     * const update_labs = await prisma.update_labs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends update_labsUpdateManyArgs>(args: SelectSubset<T, update_labsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Update_labs.
     * @param {update_labsUpsertArgs} args - Arguments to update or create a Update_labs.
     * @example
     * // Update or create a Update_labs
     * const update_labs = await prisma.update_labs.upsert({
     *   create: {
     *     // ... data to create a Update_labs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Update_labs we want to update
     *   }
     * })
     */
    upsert<T extends update_labsUpsertArgs>(args: SelectSubset<T, update_labsUpsertArgs<ExtArgs>>): Prisma__update_labsClient<$Result.GetResult<Prisma.$update_labsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Update_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsCountArgs} args - Arguments to filter Update_labs to count.
     * @example
     * // Count the number of Update_labs
     * const count = await prisma.update_labs.count({
     *   where: {
     *     // ... the filter for the Update_labs we want to count
     *   }
     * })
    **/
    count<T extends update_labsCountArgs>(
      args?: Subset<T, update_labsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Update_labsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Update_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Update_labsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Update_labsAggregateArgs>(args: Subset<T, Update_labsAggregateArgs>): Prisma.PrismaPromise<GetUpdate_labsAggregateType<T>>

    /**
     * Group by Update_labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {update_labsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends update_labsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: update_labsGroupByArgs['orderBy'] }
        : { orderBy?: update_labsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, update_labsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdate_labsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the update_labs model
   */
  readonly fields: update_labsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for update_labs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__update_labsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the update_labs model
   */ 
  interface update_labsFieldRefs {
    readonly update_labid: FieldRef<"update_labs", 'Int'>
    readonly laboratory_id: FieldRef<"update_labs", 'Int'>
    readonly phonenum_doesnt_exist: FieldRef<"update_labs", 'Int'>
    readonly print_billing: FieldRef<"update_labs", 'Int'>
    readonly collection_report: FieldRef<"update_labs", 'Int'>
    readonly test_report: FieldRef<"update_labs", 'Int'>
    readonly active: FieldRef<"update_labs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * update_labs findUnique
   */
  export type update_labsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter, which update_labs to fetch.
     */
    where: update_labsWhereUniqueInput
  }

  /**
   * update_labs findUniqueOrThrow
   */
  export type update_labsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter, which update_labs to fetch.
     */
    where: update_labsWhereUniqueInput
  }

  /**
   * update_labs findFirst
   */
  export type update_labsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter, which update_labs to fetch.
     */
    where?: update_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of update_labs to fetch.
     */
    orderBy?: update_labsOrderByWithRelationInput | update_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for update_labs.
     */
    cursor?: update_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` update_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` update_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of update_labs.
     */
    distinct?: Update_labsScalarFieldEnum | Update_labsScalarFieldEnum[]
  }

  /**
   * update_labs findFirstOrThrow
   */
  export type update_labsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter, which update_labs to fetch.
     */
    where?: update_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of update_labs to fetch.
     */
    orderBy?: update_labsOrderByWithRelationInput | update_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for update_labs.
     */
    cursor?: update_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` update_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` update_labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of update_labs.
     */
    distinct?: Update_labsScalarFieldEnum | Update_labsScalarFieldEnum[]
  }

  /**
   * update_labs findMany
   */
  export type update_labsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter, which update_labs to fetch.
     */
    where?: update_labsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of update_labs to fetch.
     */
    orderBy?: update_labsOrderByWithRelationInput | update_labsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing update_labs.
     */
    cursor?: update_labsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` update_labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` update_labs.
     */
    skip?: number
    distinct?: Update_labsScalarFieldEnum | Update_labsScalarFieldEnum[]
  }

  /**
   * update_labs create
   */
  export type update_labsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * The data needed to create a update_labs.
     */
    data: XOR<update_labsCreateInput, update_labsUncheckedCreateInput>
  }

  /**
   * update_labs createMany
   */
  export type update_labsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many update_labs.
     */
    data: update_labsCreateManyInput | update_labsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * update_labs update
   */
  export type update_labsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * The data needed to update a update_labs.
     */
    data: XOR<update_labsUpdateInput, update_labsUncheckedUpdateInput>
    /**
     * Choose, which update_labs to update.
     */
    where: update_labsWhereUniqueInput
  }

  /**
   * update_labs updateMany
   */
  export type update_labsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update update_labs.
     */
    data: XOR<update_labsUpdateManyMutationInput, update_labsUncheckedUpdateManyInput>
    /**
     * Filter which update_labs to update
     */
    where?: update_labsWhereInput
  }

  /**
   * update_labs upsert
   */
  export type update_labsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * The filter to search for the update_labs to update in case it exists.
     */
    where: update_labsWhereUniqueInput
    /**
     * In case the update_labs found by the `where` argument doesn't exist, create a new update_labs with this data.
     */
    create: XOR<update_labsCreateInput, update_labsUncheckedCreateInput>
    /**
     * In case the update_labs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<update_labsUpdateInput, update_labsUncheckedUpdateInput>
  }

  /**
   * update_labs delete
   */
  export type update_labsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
    /**
     * Filter which update_labs to delete.
     */
    where: update_labsWhereUniqueInput
  }

  /**
   * update_labs deleteMany
   */
  export type update_labsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which update_labs to delete
     */
    where?: update_labsWhereInput
  }

  /**
   * update_labs without action
   */
  export type update_labsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the update_labs
     */
    select?: update_labsSelect<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    role_id: number | null
    active: number | null
  }

  export type UserSumAggregateOutputType = {
    role_id: number | null
    active: number | null
  }

  export type UserMinAggregateOutputType = {
    role_id: number | null
    name: string | null
    active: number | null
    created_on: Date | null
  }

  export type UserMaxAggregateOutputType = {
    role_id: number | null
    name: string | null
    active: number | null
    created_on: Date | null
  }

  export type UserCountAggregateOutputType = {
    role_id: number
    name: number
    active: number
    created_on: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    role_id?: true
    active?: true
  }

  export type UserSumAggregateInputType = {
    role_id?: true
    active?: true
  }

  export type UserMinAggregateInputType = {
    role_id?: true
    name?: true
    active?: true
    created_on?: true
  }

  export type UserMaxAggregateInputType = {
    role_id?: true
    name?: true
    active?: true
    created_on?: true
  }

  export type UserCountAggregateInputType = {
    role_id?: true
    name?: true
    active?: true
    created_on?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    role_id: number
    name: string
    active: number
    created_on: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    name?: boolean
    active?: boolean
    created_on?: boolean
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    role_id?: boolean
    name?: boolean
    active?: boolean
    created_on?: boolean
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      name: string
      active: number
      created_on: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const userWithRole_idOnly = await prisma.user.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly role_id: FieldRef<"user", 'Int'>
    readonly name: FieldRef<"user", 'String'>
    readonly active: FieldRef<"user", 'Int'>
    readonly created_on: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BarcodeScalarFieldEnum: {
    barcode_id: 'barcode_id',
    billing_id: 'billing_id',
    barcode: 'barcode',
    barcode_image: 'barcode_image',
    created_date: 'created_date'
  };

  export type BarcodeScalarFieldEnum = (typeof BarcodeScalarFieldEnum)[keyof typeof BarcodeScalarFieldEnum]


  export const BillingScalarFieldEnum: {
    billing_id: 'billing_id',
    laboratory_tests: 'laboratory_tests',
    medical_num: 'medical_num',
    patient_unique_id: 'patient_unique_id',
    tot_amt: 'tot_amt',
    discount: 'discount',
    discount_type: 'discount_type',
    net_amt: 'net_amt',
    adv_amt: 'adv_amt',
    balance_amt: 'balance_amt',
    balance_pymnt2: 'balance_pymnt2',
    final_balance: 'final_balance',
    lab_id: 'lab_id',
    unique_billid: 'unique_billid',
    created_on: 'created_on'
  };

  export type BillingScalarFieldEnum = (typeof BillingScalarFieldEnum)[keyof typeof BillingScalarFieldEnum]


  export const Billing_logScalarFieldEnum: {
    billing_log_id: 'billing_log_id',
    billing_id: 'billing_id',
    amt: 'amt',
    payment_method: 'payment_method',
    added_date: 'added_date'
  };

  export type Billing_logScalarFieldEnum = (typeof Billing_logScalarFieldEnum)[keyof typeof Billing_logScalarFieldEnum]


  export const Bloodgroup_detailsScalarFieldEnum: {
    bloodgroup_id: 'bloodgroup_id',
    bloodgroup_name: 'bloodgroup_name',
    active: 'active'
  };

  export type Bloodgroup_detailsScalarFieldEnum = (typeof Bloodgroup_detailsScalarFieldEnum)[keyof typeof Bloodgroup_detailsScalarFieldEnum]


  export const CityScalarFieldEnum: {
    city_id: 'city_id',
    city_name: 'city_name',
    state_id: 'state_id',
    active: 'active'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const Clinic_module_activation_requestScalarFieldEnum: {
    clinic_module_activation_request_id: 'clinic_module_activation_request_id',
    name: 'name',
    email: 'email',
    phone_num: 'phone_num',
    physicianid: 'physicianid',
    message: 'message',
    is_activated: 'is_activated',
    added_date: 'added_date'
  };

  export type Clinic_module_activation_requestScalarFieldEnum = (typeof Clinic_module_activation_requestScalarFieldEnum)[keyof typeof Clinic_module_activation_requestScalarFieldEnum]


  export const Clinical_parametersScalarFieldEnum: {
    clinical_parameterid: 'clinical_parameterid',
    blood_pressure: 'blood_pressure',
    systolic_blood_pressure: 'systolic_blood_pressure',
    diastolic_blood_pressure: 'diastolic_blood_pressure',
    sugar: 'sugar',
    pulse: 'pulse',
    height: 'height',
    weight: 'weight',
    temperature: 'temperature',
    referral_patient_id: 'referral_patient_id',
    dependent_id: 'dependent_id',
    created_on: 'created_on'
  };

  export type Clinical_parametersScalarFieldEnum = (typeof Clinical_parametersScalarFieldEnum)[keyof typeof Clinical_parametersScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    emailid: 'emailid',
    subject: 'subject',
    message: 'message',
    created_date: 'created_date'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    country_id: 'country_id',
    country_name: 'country_name',
    active: 'active'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    file_name: 'file_name',
    type: 'type',
    medical_num: 'medical_num',
    patient_unique_id: 'patient_unique_id',
    referral_id: 'referral_id',
    uploaded_on: 'uploaded_on',
    status: 'status'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const Investigation_detailsScalarFieldEnum: {
    investigation_id: 'investigation_id',
    investigation_name: 'investigation_name',
    active: 'active'
  };

  export type Investigation_detailsScalarFieldEnum = (typeof Investigation_detailsScalarFieldEnum)[keyof typeof Investigation_detailsScalarFieldEnum]


  export const Investigation_fileScalarFieldEnum: {
    file_id: 'file_id',
    investigation_file: 'investigation_file',
    referral_test_ID: 'referral_test_ID',
    uploaded_on: 'uploaded_on'
  };

  export type Investigation_fileScalarFieldEnum = (typeof Investigation_fileScalarFieldEnum)[keyof typeof Investigation_fileScalarFieldEnum]


  export const Investigation_test_detailsScalarFieldEnum: {
    parse_id: 'parse_id',
    test_name: 'test_name',
    investigation_id: 'investigation_id',
    parent_parse_id: 'parent_parse_id',
    active: 'active'
  };

  export type Investigation_test_detailsScalarFieldEnum = (typeof Investigation_test_detailsScalarFieldEnum)[keyof typeof Investigation_test_detailsScalarFieldEnum]


  export const Lab_leavesScalarFieldEnum: {
    id: 'id',
    lab_id: 'lab_id',
    dates: 'dates',
    start_time: 'start_time',
    end_time: 'end_time',
    reason: 'reason',
    created_time: 'created_time'
  };

  export type Lab_leavesScalarFieldEnum = (typeof Lab_leavesScalarFieldEnum)[keyof typeof Lab_leavesScalarFieldEnum]


  export const Lab_tests_price_updatesScalarFieldEnum: {
    id: 'id',
    lab_id: 'lab_id',
    test_id: 'test_id',
    price: 'price',
    unit: 'unit',
    reference_range: 'reference_range',
    created_date: 'created_date',
    created_by: 'created_by',
    created_by_phone_num: 'created_by_phone_num'
  };

  export type Lab_tests_price_updatesScalarFieldEnum = (typeof Lab_tests_price_updatesScalarFieldEnum)[keyof typeof Lab_tests_price_updatesScalarFieldEnum]


  export const Lab_timingsScalarFieldEnum: {
    id: 'id',
    lab_id: 'lab_id',
    theday: 'theday',
    work_type: 'work_type',
    start_time: 'start_time',
    end_time: 'end_time',
    created_time: 'created_time',
    updated_time: 'updated_time'
  };

  export type Lab_timingsScalarFieldEnum = (typeof Lab_timingsScalarFieldEnum)[keyof typeof Lab_timingsScalarFieldEnum]


  export const Laboratory_detailsScalarFieldEnum: {
    laboratory_id: 'laboratory_id',
    laboratory_name: 'laboratory_name',
    laboratory_address: 'laboratory_address',
    locality: 'locality',
    laboratory_phone: 'laboratory_phone',
    laboratory_email: 'laboratory_email',
    laboratory_password: 'laboratory_password',
    lab_state: 'lab_state',
    lab_city: 'lab_city',
    lab_pincode: 'lab_pincode',
    created_on: 'created_on',
    updated_on: 'updated_on',
    active: 'active',
    role_id: 'role_id',
    profile_filename: 'profile_filename',
    profile_fullpath: 'profile_fullpath'
  };

  export type Laboratory_detailsScalarFieldEnum = (typeof Laboratory_detailsScalarFieldEnum)[keyof typeof Laboratory_detailsScalarFieldEnum]


  export const Laboratory_doctorsScalarFieldEnum: {
    laboratory_doctors_id: 'laboratory_doctors_id',
    laboratory_id: 'laboratory_id',
    doc_firstname: 'doc_firstname',
    doc_lastname: 'doc_lastname',
    doc_password: 'doc_password',
    doc_phone_number: 'doc_phone_number',
    doc_email: 'doc_email',
    doc_dept: 'doc_dept',
    doc_signature: 'doc_signature',
    added_date: 'added_date',
    doc_designation: 'doc_designation',
    is_active: 'is_active'
  };

  export type Laboratory_doctorsScalarFieldEnum = (typeof Laboratory_doctorsScalarFieldEnum)[keyof typeof Laboratory_doctorsScalarFieldEnum]


  export const Laboratory_test_detailsScalarFieldEnum: {
    laboratory_testid: 'laboratory_testid',
    laboratory_tests: 'laboratory_tests',
    code: 'code',
    display_order: 'display_order',
    mnemonics: 'mnemonics',
    test_type: 'test_type',
    sub_department: 'sub_department',
    sample_type: 'sample_type',
    container_type: 'container_type',
    confidential: 'confidential',
    methodology: 'methodology',
    transport_temperature: 'transport_temperature',
    tat: 'tat',
    outsourcing_status: 'outsourcing_status',
    instrument: 'instrument',
    laboratory_id: 'laboratory_id',
    test_price: 'test_price',
    custom_test_name: 'custom_test_name',
    instruction: 'instruction',
    test_method: 'test_method',
    status: 'status',
    status_changed_by: 'status_changed_by',
    status_changed_on: 'status_changed_on',
    unit: 'unit',
    reference_range: 'reference_range',
    age_gender_specific: 'age_gender_specific',
    critical_alert: 'critical_alert',
    interpretation: 'interpretation',
    sort_order: 'sort_order',
    title_required: 'title_required'
  };

  export type Laboratory_test_detailsScalarFieldEnum = (typeof Laboratory_test_detailsScalarFieldEnum)[keyof typeof Laboratory_test_detailsScalarFieldEnum]


  export const LocalityScalarFieldEnum: {
    locality_id: 'locality_id',
    locality_name: 'locality_name',
    city_id: 'city_id',
    active: 'active'
  };

  export type LocalityScalarFieldEnum = (typeof LocalityScalarFieldEnum)[keyof typeof LocalityScalarFieldEnum]


  export const Login_detailsScalarFieldEnum: {
    login_id: 'login_id',
    firstname: 'firstname',
    physician_id: 'physician_id',
    laboratory_id: 'laboratory_id',
    patient_id: 'patient_id',
    phy_admin_id: 'phy_admin_id',
    username: 'username',
    password: 'password',
    phone_num: 'phone_num',
    state: 'state',
    city: 'city',
    count: 'count',
    role_id: 'role_id',
    active: 'active',
    last_login: 'last_login',
    created_on: 'created_on',
    updated_on: 'updated_on',
    otp: 'otp',
    device_id: 'device_id',
    player_id: 'player_id'
  };

  export type Login_detailsScalarFieldEnum = (typeof Login_detailsScalarFieldEnum)[keyof typeof Login_detailsScalarFieldEnum]


  export const MedicineScalarFieldEnum: {
    ID: 'ID',
    medicine_name: 'medicine_name',
    active: 'active'
  };

  export type MedicineScalarFieldEnum = (typeof MedicineScalarFieldEnum)[keyof typeof MedicineScalarFieldEnum]


  export const Notification_keysScalarFieldEnum: {
    notification_keys_id: 'notification_keys_id',
    app_id: 'app_id',
    rest_api_key: 'rest_api_key'
  };

  export type Notification_keysScalarFieldEnum = (typeof Notification_keysScalarFieldEnum)[keyof typeof Notification_keysScalarFieldEnum]


  export const NotificationattemptScalarFieldEnum: {
    notificationattempt_id: 'notificationattempt_id',
    login_id: 'login_id',
    notification_heading: 'notification_heading',
    notification_message: 'notification_message',
    notification_type: 'notification_type',
    CreatedDateTime: 'CreatedDateTime',
    notification_medium: 'notification_medium',
    SendDateTime: 'SendDateTime',
    status: 'status'
  };

  export type NotificationattemptScalarFieldEnum = (typeof NotificationattemptScalarFieldEnum)[keyof typeof NotificationattemptScalarFieldEnum]


  export const RenamedpackageScalarFieldEnum: {
    id: 'id',
    package_name: 'package_name',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type RenamedpackageScalarFieldEnum = (typeof RenamedpackageScalarFieldEnum)[keyof typeof RenamedpackageScalarFieldEnum]


  export const Package_containsScalarFieldEnum: {
    id: 'id',
    package_id: 'package_id',
    test_id: 'test_id',
    created_on: 'created_on',
    is_active: 'is_active'
  };

  export type Package_containsScalarFieldEnum = (typeof Package_containsScalarFieldEnum)[keyof typeof Package_containsScalarFieldEnum]


  export const Package_labsScalarFieldEnum: {
    id: 'id',
    package_id: 'package_id',
    lab_id: 'lab_id',
    package_price: 'package_price',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type Package_labsScalarFieldEnum = (typeof Package_labsScalarFieldEnum)[keyof typeof Package_labsScalarFieldEnum]


  export const Package_queueScalarFieldEnum: {
    id: 'id',
    medical_num: 'medical_num',
    package_id: 'package_id',
    lab_id: 'lab_id',
    patient_id: 'patient_id',
    dependent_id: 'dependent_id',
    doctor_id: 'doctor_id',
    referdate: 'referdate',
    created_by: 'created_by',
    created_on: 'created_on',
    package_status: 'package_status'
  };

  export type Package_queueScalarFieldEnum = (typeof Package_queueScalarFieldEnum)[keyof typeof Package_queueScalarFieldEnum]


  export const Patient_dep_detailsScalarFieldEnum: {
    patient_dep_id: 'patient_dep_id',
    firstname: 'firstname',
    lastname: 'lastname',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    age: 'age',
    address: 'address',
    city: 'city',
    pincode: 'pincode',
    mailid: 'mailid',
    phonenum: 'phonenum',
    alt_phonenum: 'alt_phonenum',
    relationship: 'relationship',
    main_pat_id: 'main_pat_id',
    created_on: 'created_on',
    updated_on: 'updated_on',
    active: 'active',
    role_id: 'role_id',
    patient_unique_id: 'patient_unique_id',
    physician_id: 'physician_id',
    status: 'status',
    r_count: 'r_count',
    count: 'count',
    prescribe_receipt: 'prescribe_receipt'
  };

  export type Patient_dep_detailsScalarFieldEnum = (typeof Patient_dep_detailsScalarFieldEnum)[keyof typeof Patient_dep_detailsScalarFieldEnum]


  export const Patient_doctor_mappingScalarFieldEnum: {
    patient_doctor_mapping_id: 'patient_doctor_mapping_id',
    referral_patient_id: 'referral_patient_id',
    prev_physician_id: 'prev_physician_id',
    new_physician_id: 'new_physician_id',
    patient_unique_id: 'patient_unique_id',
    added_date: 'added_date'
  };

  export type Patient_doctor_mappingScalarFieldEnum = (typeof Patient_doctor_mappingScalarFieldEnum)[keyof typeof Patient_doctor_mappingScalarFieldEnum]


  export const Patient_parameterScalarFieldEnum: {
    parameter_id: 'parameter_id',
    date_of_birth: 'date_of_birth',
    known_allergies: 'known_allergies',
    previous_medical_history: 'previous_medical_history',
    blood_group: 'blood_group',
    diabetic: 'diabetic',
    hypertension: 'hypertension',
    referral_patient_id: 'referral_patient_id',
    dependent_id: 'dependent_id',
    created_on: 'created_on'
  };

  export type Patient_parameterScalarFieldEnum = (typeof Patient_parameterScalarFieldEnum)[keyof typeof Patient_parameterScalarFieldEnum]


  export const PatientqueueScalarFieldEnum: {
    patientqueue_id: 'patientqueue_id',
    BillId: 'BillId',
    medical_num: 'medical_num',
    firstname: 'firstname',
    mailid: 'mailid',
    phonenum: 'phonenum',
    refer_date: 'refer_date',
    patient_unique_id: 'patient_unique_id',
    physician_id: 'physician_id',
    phyfname: 'phyfname',
    referred_id: 'referred_id',
    ID: 'ID',
    billing_id: 'billing_id',
    laboratory_id: 'laboratory_id',
    ref_type: 'ref_type',
    lab_test_status: 'lab_test_status',
    billing_status: 'billing_status',
    is_sync: 'is_sync',
    created_on: 'created_on'
  };

  export type PatientqueueScalarFieldEnum = (typeof PatientqueueScalarFieldEnum)[keyof typeof PatientqueueScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    ID: 'ID',
    doctor_id: 'doctor_id',
    referral_patient_id: 'referral_patient_id',
    dependent_id: 'dependent_id',
    Receipt_id: 'Receipt_id',
    prescription_num: 'prescription_num',
    reg_fee: 'reg_fee',
    con_price: 'con_price',
    med_price: 'med_price',
    inv_price: 'inv_price',
    admin_price: 'admin_price',
    total_price: 'total_price',
    mode: 'mode',
    created_on: 'created_on',
    updated_on: 'updated_on',
    submitted: 'submitted'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Phy_adminScalarFieldEnum: {
    phy_admin_id: 'phy_admin_id',
    phy_admin_name: 'phy_admin_name',
    phy_admin_phone: 'phy_admin_phone',
    phy_admin_mail_id: 'phy_admin_mail_id',
    phy_admin_password: 'phy_admin_password',
    created_on: 'created_on',
    updated_on: 'updated_on',
    created_by: 'created_by',
    physician_id: 'physician_id',
    active: 'active',
    is_visible: 'is_visible',
    role_id: 'role_id'
  };

  export type Phy_adminScalarFieldEnum = (typeof Phy_adminScalarFieldEnum)[keyof typeof Phy_adminScalarFieldEnum]


  export const Physician_appointmentScalarFieldEnum: {
    physician_id: 'physician_id',
    firstname: 'firstname',
    lastname: 'lastname',
    phone_num: 'phone_num',
    alternate_phone_number: 'alternate_phone_number',
    mail_id: 'mail_id',
    pincode: 'pincode',
    clinic_name: 'clinic_name',
    clinic_phonenum: 'clinic_phonenum',
    clinic_alternate_phonenum: 'clinic_alternate_phonenum',
    clinic_manager: 'clinic_manager',
    specialization: 'specialization',
    address: 'address',
    consultation_fee_validity: 'consultation_fee_validity',
    city: 'city',
    state: 'state',
    active: 'active',
    created_by: 'created_by',
    created_on: 'created_on',
    updated_on: 'updated_on',
    password: 'password',
    role_id: 'role_id',
    profile_filename: 'profile_filename',
    profile_fullpath: 'profile_fullpath',
    qualification_id: 'qualification_id',
    registration_number: 'registration_number',
    time_span: 'time_span',
    status: 'status',
    locality: 'locality',
    created_by_id: 'created_by_id',
    clinic_module_activated: 'clinic_module_activated',
    Signature_image: 'Signature_image'
  };

  export type Physician_appointmentScalarFieldEnum = (typeof Physician_appointmentScalarFieldEnum)[keyof typeof Physician_appointmentScalarFieldEnum]


  export const Physician_clinic_timingsScalarFieldEnum: {
    id: 'id',
    physician_id: 'physician_id',
    theday: 'theday',
    work_type: 'work_type',
    clinic: 'clinic',
    start_time: 'start_time',
    end_time: 'end_time',
    created_time: 'created_time',
    updated_time: 'updated_time'
  };

  export type Physician_clinic_timingsScalarFieldEnum = (typeof Physician_clinic_timingsScalarFieldEnum)[keyof typeof Physician_clinic_timingsScalarFieldEnum]


  export const Physician_leavesScalarFieldEnum: {
    id: 'id',
    physician_id: 'physician_id',
    dates: 'dates',
    start_time: 'start_time',
    end_time: 'end_time',
    reason: 'reason',
    created_time: 'created_time'
  };

  export type Physician_leavesScalarFieldEnum = (typeof Physician_leavesScalarFieldEnum)[keyof typeof Physician_leavesScalarFieldEnum]


  export const Physician_timingsScalarFieldEnum: {
    id: 'id',
    physician_id: 'physician_id',
    theday: 'theday',
    work_type: 'work_type',
    start_time: 'start_time',
    end_time: 'end_time',
    created_time: 'created_time',
    updated_time: 'updated_time'
  };

  export type Physician_timingsScalarFieldEnum = (typeof Physician_timingsScalarFieldEnum)[keyof typeof Physician_timingsScalarFieldEnum]


  export const PreferredlabsScalarFieldEnum: {
    preferredlabs_id: 'preferredlabs_id',
    laboratory_id: 'laboratory_id',
    physician_id: 'physician_id',
    is_active: 'is_active'
  };

  export type PreferredlabsScalarFieldEnum = (typeof PreferredlabsScalarFieldEnum)[keyof typeof PreferredlabsScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    prescription_id: 'prescription_id',
    prescription_num: 'prescription_num',
    patient_id: 'patient_id',
    dependent_id: 'dependent_id',
    doctor_id: 'doctor_id',
    symptoms: 'symptoms',
    type: 'type',
    med_name: 'med_name',
    mg: 'mg',
    dose: 'dose',
    num_days: 'num_days',
    instruction: 'instruction',
    advice: 'advice',
    created_on: 'created_on'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const Prescription_medicineScalarFieldEnum: {
    medicine_id: 'medicine_id',
    type: 'type',
    med_name: 'med_name',
    mg: 'mg',
    dose: 'dose',
    num_days: 'num_days',
    instruction: 'instruction',
    advice: 'advice',
    prescription_id: 'prescription_id'
  };

  export type Prescription_medicineScalarFieldEnum = (typeof Prescription_medicineScalarFieldEnum)[keyof typeof Prescription_medicineScalarFieldEnum]


  export const QualificationScalarFieldEnum: {
    qualification_id: 'qualification_id',
    qualification_name: 'qualification_name',
    is_active: 'is_active'
  };

  export type QualificationScalarFieldEnum = (typeof QualificationScalarFieldEnum)[keyof typeof QualificationScalarFieldEnum]


  export const Qualification_mappingScalarFieldEnum: {
    qualification_mapping_id: 'qualification_mapping_id',
    qualification_id: 'qualification_id',
    physician_id: 'physician_id'
  };

  export type Qualification_mappingScalarFieldEnum = (typeof Qualification_mappingScalarFieldEnum)[keyof typeof Qualification_mappingScalarFieldEnum]


  export const Referral_confirmation_detailsScalarFieldEnum: {
    referred_id: 'referred_id',
    medical_num: 'medical_num',
    relationship: 'relationship',
    referral_pat_id: 'referral_pat_id',
    password: 'password',
    patient_unique_id: 'patient_unique_id',
    attempts: 'attempts',
    brief_history: 'brief_history',
    phy_advice: 'phy_advice',
    refer_date: 'refer_date',
    created_by: 'created_by',
    login_id: 'login_id',
    created_on: 'created_on',
    ref_type: 'ref_type',
    lab_test_status: 'lab_test_status',
    billing_status: 'billing_status'
  };

  export type Referral_confirmation_detailsScalarFieldEnum = (typeof Referral_confirmation_detailsScalarFieldEnum)[keyof typeof Referral_confirmation_detailsScalarFieldEnum]


  export const Referral_confirmation_details1ScalarFieldEnum: {
    referred_id: 'referred_id',
    medical_num: 'medical_num',
    relationship: 'relationship',
    referral_pat_id: 'referral_pat_id',
    password: 'password',
    patient_unique_id: 'patient_unique_id',
    attempts: 'attempts',
    brief_history: 'brief_history',
    phy_advice: 'phy_advice',
    refer_date: 'refer_date',
    created_by: 'created_by',
    login_id: 'login_id',
    created_on: 'created_on',
    ref_type: 'ref_type',
    lab_test_status: 'lab_test_status'
  };

  export type Referral_confirmation_details1ScalarFieldEnum = (typeof Referral_confirmation_details1ScalarFieldEnum)[keyof typeof Referral_confirmation_details1ScalarFieldEnum]


  export const Referral_patient_detailsScalarFieldEnum: {
    referral_patient_id: 'referral_patient_id',
    firstname: 'firstname',
    lastname: 'lastname',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    age: 'age',
    address: 'address',
    state: 'state',
    city: 'city',
    pincode: 'pincode',
    mailid: 'mailid',
    phonenum: 'phonenum',
    alt_phonenum: 'alt_phonenum',
    password: 'password',
    relationship: 'relationship',
    created_on: 'created_on',
    updated_on: 'updated_on',
    active: 'active',
    role_id: 'role_id',
    patient_unique_id: 'patient_unique_id',
    physician_id: 'physician_id',
    status: 'status',
    r_count: 'r_count',
    profile_filename: 'profile_filename',
    profile_fullpath: 'profile_fullpath',
    main_pat_id: 'main_pat_id',
    patient_dep_id: 'patient_dep_id',
    count: 'count',
    prescribe_receipt: 'prescribe_receipt'
  };

  export type Referral_patient_detailsScalarFieldEnum = (typeof Referral_patient_detailsScalarFieldEnum)[keyof typeof Referral_patient_detailsScalarFieldEnum]


  export const Referral_patient_test_detailsScalarFieldEnum: {
    ID: 'ID',
    medical_num: 'medical_num',
    laboratory_tests: 'laboratory_tests',
    parse_parent_id: 'parse_parent_id',
    has_child: 'has_child',
    time: 'time',
    date: 'date',
    instruction: 'instruction',
    patient_unique_id: 'patient_unique_id',
    physician_id: 'physician_id',
    laboratory_id: 'laboratory_id',
    dependent_id: 'dependent_id',
    main_patient_id: 'main_patient_id',
    billing_id: 'billing_id',
    billing_datetime: 'billing_datetime',
    sample_collected_id: 'sample_collected_id',
    sample_datetime: 'sample_datetime',
    labapproval_id: 'labapproval_id',
    labapproval_datetime: 'labapproval_datetime',
    pat_status: 'pat_status',
    report_filename: 'report_filename',
    report_fullpath: 'report_fullpath',
    approved_lab_doc_id: 'approved_lab_doc_id',
    editor: 'editor',
    created_on: 'created_on'
  };

  export type Referral_patient_test_detailsScalarFieldEnum = (typeof Referral_patient_test_detailsScalarFieldEnum)[keyof typeof Referral_patient_test_detailsScalarFieldEnum]


  export const RelationshipScalarFieldEnum: {
    rel_id: 'rel_id',
    rel_name: 'rel_name',
    active: 'active'
  };

  export type RelationshipScalarFieldEnum = (typeof RelationshipScalarFieldEnum)[keyof typeof RelationshipScalarFieldEnum]


  export const Report_templateScalarFieldEnum: {
    template_id: 'template_id',
    header: 'header',
    footer: 'footer',
    print_size: 'print_size',
    lab_id: 'lab_id',
    created_on: 'created_on',
    status: 'status'
  };

  export type Report_templateScalarFieldEnum = (typeof Report_templateScalarFieldEnum)[keyof typeof Report_templateScalarFieldEnum]


  export const Sample_resultsScalarFieldEnum: {
    result_id: 'result_id',
    sample_value: 'sample_value',
    referral_test_ID: 'referral_test_ID',
    created_on: 'created_on'
  };

  export type Sample_resultsScalarFieldEnum = (typeof Sample_resultsScalarFieldEnum)[keyof typeof Sample_resultsScalarFieldEnum]


  export const Ssconsultation_billingScalarFieldEnum: {
    ssbilling_id: 'ssbilling_id',
    ss_id: 'ss_id',
    tot_amt: 'tot_amt',
    lab_id: 'lab_id',
    unique_billid: 'unique_billid',
    created_on: 'created_on'
  };

  export type Ssconsultation_billingScalarFieldEnum = (typeof Ssconsultation_billingScalarFieldEnum)[keyof typeof Ssconsultation_billingScalarFieldEnum]


  export const Ssconsultation_logScalarFieldEnum: {
    ssconsultation_log_id: 'ssconsultation_log_id',
    ssbilling_id: 'ssbilling_id',
    amt: 'amt',
    payment_method: 'payment_method',
    added_date: 'added_date'
  };

  export type Ssconsultation_logScalarFieldEnum = (typeof Ssconsultation_logScalarFieldEnum)[keyof typeof Ssconsultation_logScalarFieldEnum]


  export const StateScalarFieldEnum: {
    state_id: 'state_id',
    state_name: 'state_name',
    country_id: 'country_id',
    active: 'active'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const Status_masterScalarFieldEnum: {
    status_id: 'status_id',
    status: 'status'
  };

  export type Status_masterScalarFieldEnum = (typeof Status_masterScalarFieldEnum)[keyof typeof Status_masterScalarFieldEnum]


  export const Super_specialityScalarFieldEnum: {
    superspeciality_id: 'superspeciality_id',
    superspeciality_name: 'superspeciality_name',
    created_on: 'created_on',
    active: 'active'
  };

  export type Super_specialityScalarFieldEnum = (typeof Super_specialityScalarFieldEnum)[keyof typeof Super_specialityScalarFieldEnum]


  export const Superspeciality_consultationScalarFieldEnum: {
    ss_id: 'ss_id',
    laboratory_id: 'laboratory_id',
    referral_patient_id: 'referral_patient_id',
    patient_dep_id: 'patient_dep_id',
    superspeciality_id: 'superspeciality_id',
    comments: 'comments',
    by_assign: 'by_assign',
    to_assign: 'to_assign',
    referdate: 'referdate',
    refertime: 'refertime',
    referclinic_name: 'referclinic_name',
    consultationId: 'consultationId',
    consultationDate: 'consultationDate',
    consultationAmount: 'consultationAmount',
    miscellaneousAmount: 'miscellaneousAmount',
    totalAmount: 'totalAmount',
    status: 'status'
  };

  export type Superspeciality_consultationScalarFieldEnum = (typeof Superspeciality_consultationScalarFieldEnum)[keyof typeof Superspeciality_consultationScalarFieldEnum]


  export const Superspeciality_detailsScalarFieldEnum: {
    speciality_id: 'speciality_id',
    referral_patient_id: 'referral_patient_id',
    patient_dep_id: 'patient_dep_id',
    superspeciality_id: 'superspeciality_id',
    comments: 'comments',
    by_assign: 'by_assign',
    to_assign: 'to_assign',
    referdate: 'referdate',
    refertime: 'refertime',
    referclinic_name: 'referclinic_name',
    created_on: 'created_on',
    active: 'active',
    laboratory_id: 'laboratory_id'
  };

  export type Superspeciality_detailsScalarFieldEnum = (typeof Superspeciality_detailsScalarFieldEnum)[keyof typeof Superspeciality_detailsScalarFieldEnum]


  export const Test_report_notesScalarFieldEnum: {
    test_report_notes_id: 'test_report_notes_id',
    laboratory_tests: 'laboratory_tests',
    medical_num: 'medical_num',
    referral_patient_test_details_id: 'referral_patient_test_details_id',
    title: 'title',
    description: 'description',
    added_date: 'added_date'
  };

  export type Test_report_notesScalarFieldEnum = (typeof Test_report_notesScalarFieldEnum)[keyof typeof Test_report_notesScalarFieldEnum]


  export const Update_labsScalarFieldEnum: {
    update_labid: 'update_labid',
    laboratory_id: 'laboratory_id',
    phonenum_doesnt_exist: 'phonenum_doesnt_exist',
    print_billing: 'print_billing',
    collection_report: 'collection_report',
    test_report: 'test_report',
    active: 'active'
  };

  export type Update_labsScalarFieldEnum = (typeof Update_labsScalarFieldEnum)[keyof typeof Update_labsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    role_id: 'role_id',
    name: 'name',
    active: 'active',
    created_on: 'created_on'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'files_status'
   */
  export type Enumfiles_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'files_status'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'lab_timings_work_type'
   */
  export type Enumlab_timings_work_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'lab_timings_work_type'>
    


  /**
   * Reference to a field of type 'laboratory_test_details_status'
   */
  export type Enumlaboratory_test_details_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'laboratory_test_details_status'>
    


  /**
   * Reference to a field of type 'physician_clinic_timings_work_type'
   */
  export type Enumphysician_clinic_timings_work_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'physician_clinic_timings_work_type'>
    


  /**
   * Reference to a field of type 'physician_timings_work_type'
   */
  export type Enumphysician_timings_work_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'physician_timings_work_type'>
    


  /**
   * Reference to a field of type 'referral_confirmation_details_ref_type'
   */
  export type Enumreferral_confirmation_details_ref_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'referral_confirmation_details_ref_type'>
    


  /**
   * Reference to a field of type 'referral_confirmation_details1_ref_type'
   */
  export type Enumreferral_confirmation_details1_ref_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'referral_confirmation_details1_ref_type'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type barcodeWhereInput = {
    AND?: barcodeWhereInput | barcodeWhereInput[]
    OR?: barcodeWhereInput[]
    NOT?: barcodeWhereInput | barcodeWhereInput[]
    barcode_id?: IntFilter<"barcode"> | number
    billing_id?: IntFilter<"barcode"> | number
    barcode?: StringFilter<"barcode"> | string
    barcode_image?: StringFilter<"barcode"> | string
    created_date?: DateTimeFilter<"barcode"> | Date | string
  }

  export type barcodeOrderByWithRelationInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
    barcode?: SortOrder
    barcode_image?: SortOrder
    created_date?: SortOrder
  }

  export type barcodeWhereUniqueInput = Prisma.AtLeast<{
    barcode_id?: number
    AND?: barcodeWhereInput | barcodeWhereInput[]
    OR?: barcodeWhereInput[]
    NOT?: barcodeWhereInput | barcodeWhereInput[]
    billing_id?: IntFilter<"barcode"> | number
    barcode?: StringFilter<"barcode"> | string
    barcode_image?: StringFilter<"barcode"> | string
    created_date?: DateTimeFilter<"barcode"> | Date | string
  }, "barcode_id">

  export type barcodeOrderByWithAggregationInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
    barcode?: SortOrder
    barcode_image?: SortOrder
    created_date?: SortOrder
    _count?: barcodeCountOrderByAggregateInput
    _avg?: barcodeAvgOrderByAggregateInput
    _max?: barcodeMaxOrderByAggregateInput
    _min?: barcodeMinOrderByAggregateInput
    _sum?: barcodeSumOrderByAggregateInput
  }

  export type barcodeScalarWhereWithAggregatesInput = {
    AND?: barcodeScalarWhereWithAggregatesInput | barcodeScalarWhereWithAggregatesInput[]
    OR?: barcodeScalarWhereWithAggregatesInput[]
    NOT?: barcodeScalarWhereWithAggregatesInput | barcodeScalarWhereWithAggregatesInput[]
    barcode_id?: IntWithAggregatesFilter<"barcode"> | number
    billing_id?: IntWithAggregatesFilter<"barcode"> | number
    barcode?: StringWithAggregatesFilter<"barcode"> | string
    barcode_image?: StringWithAggregatesFilter<"barcode"> | string
    created_date?: DateTimeWithAggregatesFilter<"barcode"> | Date | string
  }

  export type billingWhereInput = {
    AND?: billingWhereInput | billingWhereInput[]
    OR?: billingWhereInput[]
    NOT?: billingWhereInput | billingWhereInput[]
    billing_id?: IntFilter<"billing"> | number
    laboratory_tests?: StringFilter<"billing"> | string
    medical_num?: StringNullableFilter<"billing"> | string | null
    patient_unique_id?: StringNullableFilter<"billing"> | string | null
    tot_amt?: StringNullableFilter<"billing"> | string | null
    discount?: StringNullableFilter<"billing"> | string | null
    discount_type?: IntFilter<"billing"> | number
    net_amt?: StringNullableFilter<"billing"> | string | null
    adv_amt?: StringFilter<"billing"> | string
    balance_amt?: StringFilter<"billing"> | string
    balance_pymnt2?: StringFilter<"billing"> | string
    final_balance?: StringFilter<"billing"> | string
    lab_id?: IntFilter<"billing"> | number
    unique_billid?: StringFilter<"billing"> | string
    created_on?: StringNullableFilter<"billing"> | string | null
  }

  export type billingOrderByWithRelationInput = {
    billing_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    tot_amt?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    discount_type?: SortOrder
    net_amt?: SortOrderInput | SortOrder
    adv_amt?: SortOrder
    balance_amt?: SortOrder
    balance_pymnt2?: SortOrder
    final_balance?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrderInput | SortOrder
  }

  export type billingWhereUniqueInput = Prisma.AtLeast<{
    billing_id?: number
    AND?: billingWhereInput | billingWhereInput[]
    OR?: billingWhereInput[]
    NOT?: billingWhereInput | billingWhereInput[]
    laboratory_tests?: StringFilter<"billing"> | string
    medical_num?: StringNullableFilter<"billing"> | string | null
    patient_unique_id?: StringNullableFilter<"billing"> | string | null
    tot_amt?: StringNullableFilter<"billing"> | string | null
    discount?: StringNullableFilter<"billing"> | string | null
    discount_type?: IntFilter<"billing"> | number
    net_amt?: StringNullableFilter<"billing"> | string | null
    adv_amt?: StringFilter<"billing"> | string
    balance_amt?: StringFilter<"billing"> | string
    balance_pymnt2?: StringFilter<"billing"> | string
    final_balance?: StringFilter<"billing"> | string
    lab_id?: IntFilter<"billing"> | number
    unique_billid?: StringFilter<"billing"> | string
    created_on?: StringNullableFilter<"billing"> | string | null
  }, "billing_id">

  export type billingOrderByWithAggregationInput = {
    billing_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    tot_amt?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    discount_type?: SortOrder
    net_amt?: SortOrderInput | SortOrder
    adv_amt?: SortOrder
    balance_amt?: SortOrder
    balance_pymnt2?: SortOrder
    final_balance?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrderInput | SortOrder
    _count?: billingCountOrderByAggregateInput
    _avg?: billingAvgOrderByAggregateInput
    _max?: billingMaxOrderByAggregateInput
    _min?: billingMinOrderByAggregateInput
    _sum?: billingSumOrderByAggregateInput
  }

  export type billingScalarWhereWithAggregatesInput = {
    AND?: billingScalarWhereWithAggregatesInput | billingScalarWhereWithAggregatesInput[]
    OR?: billingScalarWhereWithAggregatesInput[]
    NOT?: billingScalarWhereWithAggregatesInput | billingScalarWhereWithAggregatesInput[]
    billing_id?: IntWithAggregatesFilter<"billing"> | number
    laboratory_tests?: StringWithAggregatesFilter<"billing"> | string
    medical_num?: StringNullableWithAggregatesFilter<"billing"> | string | null
    patient_unique_id?: StringNullableWithAggregatesFilter<"billing"> | string | null
    tot_amt?: StringNullableWithAggregatesFilter<"billing"> | string | null
    discount?: StringNullableWithAggregatesFilter<"billing"> | string | null
    discount_type?: IntWithAggregatesFilter<"billing"> | number
    net_amt?: StringNullableWithAggregatesFilter<"billing"> | string | null
    adv_amt?: StringWithAggregatesFilter<"billing"> | string
    balance_amt?: StringWithAggregatesFilter<"billing"> | string
    balance_pymnt2?: StringWithAggregatesFilter<"billing"> | string
    final_balance?: StringWithAggregatesFilter<"billing"> | string
    lab_id?: IntWithAggregatesFilter<"billing"> | number
    unique_billid?: StringWithAggregatesFilter<"billing"> | string
    created_on?: StringNullableWithAggregatesFilter<"billing"> | string | null
  }

  export type billing_logWhereInput = {
    AND?: billing_logWhereInput | billing_logWhereInput[]
    OR?: billing_logWhereInput[]
    NOT?: billing_logWhereInput | billing_logWhereInput[]
    billing_log_id?: IntFilter<"billing_log"> | number
    billing_id?: IntFilter<"billing_log"> | number
    amt?: StringFilter<"billing_log"> | string
    payment_method?: IntFilter<"billing_log"> | number
    added_date?: DateTimeFilter<"billing_log"> | Date | string
  }

  export type billing_logOrderByWithRelationInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type billing_logWhereUniqueInput = Prisma.AtLeast<{
    billing_log_id?: number
    AND?: billing_logWhereInput | billing_logWhereInput[]
    OR?: billing_logWhereInput[]
    NOT?: billing_logWhereInput | billing_logWhereInput[]
    billing_id?: IntFilter<"billing_log"> | number
    amt?: StringFilter<"billing_log"> | string
    payment_method?: IntFilter<"billing_log"> | number
    added_date?: DateTimeFilter<"billing_log"> | Date | string
  }, "billing_log_id">

  export type billing_logOrderByWithAggregationInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
    _count?: billing_logCountOrderByAggregateInput
    _avg?: billing_logAvgOrderByAggregateInput
    _max?: billing_logMaxOrderByAggregateInput
    _min?: billing_logMinOrderByAggregateInput
    _sum?: billing_logSumOrderByAggregateInput
  }

  export type billing_logScalarWhereWithAggregatesInput = {
    AND?: billing_logScalarWhereWithAggregatesInput | billing_logScalarWhereWithAggregatesInput[]
    OR?: billing_logScalarWhereWithAggregatesInput[]
    NOT?: billing_logScalarWhereWithAggregatesInput | billing_logScalarWhereWithAggregatesInput[]
    billing_log_id?: IntWithAggregatesFilter<"billing_log"> | number
    billing_id?: IntWithAggregatesFilter<"billing_log"> | number
    amt?: StringWithAggregatesFilter<"billing_log"> | string
    payment_method?: IntWithAggregatesFilter<"billing_log"> | number
    added_date?: DateTimeWithAggregatesFilter<"billing_log"> | Date | string
  }

  export type bloodgroup_detailsWhereInput = {
    AND?: bloodgroup_detailsWhereInput | bloodgroup_detailsWhereInput[]
    OR?: bloodgroup_detailsWhereInput[]
    NOT?: bloodgroup_detailsWhereInput | bloodgroup_detailsWhereInput[]
    bloodgroup_id?: IntFilter<"bloodgroup_details"> | number
    bloodgroup_name?: StringNullableFilter<"bloodgroup_details"> | string | null
    active?: IntNullableFilter<"bloodgroup_details"> | number | null
  }

  export type bloodgroup_detailsOrderByWithRelationInput = {
    bloodgroup_id?: SortOrder
    bloodgroup_name?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
  }

  export type bloodgroup_detailsWhereUniqueInput = Prisma.AtLeast<{
    bloodgroup_id?: number
    AND?: bloodgroup_detailsWhereInput | bloodgroup_detailsWhereInput[]
    OR?: bloodgroup_detailsWhereInput[]
    NOT?: bloodgroup_detailsWhereInput | bloodgroup_detailsWhereInput[]
    bloodgroup_name?: StringNullableFilter<"bloodgroup_details"> | string | null
    active?: IntNullableFilter<"bloodgroup_details"> | number | null
  }, "bloodgroup_id">

  export type bloodgroup_detailsOrderByWithAggregationInput = {
    bloodgroup_id?: SortOrder
    bloodgroup_name?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    _count?: bloodgroup_detailsCountOrderByAggregateInput
    _avg?: bloodgroup_detailsAvgOrderByAggregateInput
    _max?: bloodgroup_detailsMaxOrderByAggregateInput
    _min?: bloodgroup_detailsMinOrderByAggregateInput
    _sum?: bloodgroup_detailsSumOrderByAggregateInput
  }

  export type bloodgroup_detailsScalarWhereWithAggregatesInput = {
    AND?: bloodgroup_detailsScalarWhereWithAggregatesInput | bloodgroup_detailsScalarWhereWithAggregatesInput[]
    OR?: bloodgroup_detailsScalarWhereWithAggregatesInput[]
    NOT?: bloodgroup_detailsScalarWhereWithAggregatesInput | bloodgroup_detailsScalarWhereWithAggregatesInput[]
    bloodgroup_id?: IntWithAggregatesFilter<"bloodgroup_details"> | number
    bloodgroup_name?: StringNullableWithAggregatesFilter<"bloodgroup_details"> | string | null
    active?: IntNullableWithAggregatesFilter<"bloodgroup_details"> | number | null
  }

  export type cityWhereInput = {
    AND?: cityWhereInput | cityWhereInput[]
    OR?: cityWhereInput[]
    NOT?: cityWhereInput | cityWhereInput[]
    city_id?: IntFilter<"city"> | number
    city_name?: StringFilter<"city"> | string
    state_id?: IntFilter<"city"> | number
    active?: BoolFilter<"city"> | boolean
  }

  export type cityOrderByWithRelationInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    active?: SortOrder
  }

  export type cityWhereUniqueInput = Prisma.AtLeast<{
    city_id?: number
    AND?: cityWhereInput | cityWhereInput[]
    OR?: cityWhereInput[]
    NOT?: cityWhereInput | cityWhereInput[]
    city_name?: StringFilter<"city"> | string
    state_id?: IntFilter<"city"> | number
    active?: BoolFilter<"city"> | boolean
  }, "city_id">

  export type cityOrderByWithAggregationInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    active?: SortOrder
    _count?: cityCountOrderByAggregateInput
    _avg?: cityAvgOrderByAggregateInput
    _max?: cityMaxOrderByAggregateInput
    _min?: cityMinOrderByAggregateInput
    _sum?: citySumOrderByAggregateInput
  }

  export type cityScalarWhereWithAggregatesInput = {
    AND?: cityScalarWhereWithAggregatesInput | cityScalarWhereWithAggregatesInput[]
    OR?: cityScalarWhereWithAggregatesInput[]
    NOT?: cityScalarWhereWithAggregatesInput | cityScalarWhereWithAggregatesInput[]
    city_id?: IntWithAggregatesFilter<"city"> | number
    city_name?: StringWithAggregatesFilter<"city"> | string
    state_id?: IntWithAggregatesFilter<"city"> | number
    active?: BoolWithAggregatesFilter<"city"> | boolean
  }

  export type clinic_module_activation_requestWhereInput = {
    AND?: clinic_module_activation_requestWhereInput | clinic_module_activation_requestWhereInput[]
    OR?: clinic_module_activation_requestWhereInput[]
    NOT?: clinic_module_activation_requestWhereInput | clinic_module_activation_requestWhereInput[]
    clinic_module_activation_request_id?: IntFilter<"clinic_module_activation_request"> | number
    name?: StringFilter<"clinic_module_activation_request"> | string
    email?: StringFilter<"clinic_module_activation_request"> | string
    phone_num?: StringFilter<"clinic_module_activation_request"> | string
    physicianid?: IntFilter<"clinic_module_activation_request"> | number
    message?: StringFilter<"clinic_module_activation_request"> | string
    is_activated?: IntFilter<"clinic_module_activation_request"> | number
    added_date?: DateTimeFilter<"clinic_module_activation_request"> | Date | string
  }

  export type clinic_module_activation_requestOrderByWithRelationInput = {
    clinic_module_activation_request_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_num?: SortOrder
    physicianid?: SortOrder
    message?: SortOrder
    is_activated?: SortOrder
    added_date?: SortOrder
  }

  export type clinic_module_activation_requestWhereUniqueInput = Prisma.AtLeast<{
    clinic_module_activation_request_id?: number
    AND?: clinic_module_activation_requestWhereInput | clinic_module_activation_requestWhereInput[]
    OR?: clinic_module_activation_requestWhereInput[]
    NOT?: clinic_module_activation_requestWhereInput | clinic_module_activation_requestWhereInput[]
    name?: StringFilter<"clinic_module_activation_request"> | string
    email?: StringFilter<"clinic_module_activation_request"> | string
    phone_num?: StringFilter<"clinic_module_activation_request"> | string
    physicianid?: IntFilter<"clinic_module_activation_request"> | number
    message?: StringFilter<"clinic_module_activation_request"> | string
    is_activated?: IntFilter<"clinic_module_activation_request"> | number
    added_date?: DateTimeFilter<"clinic_module_activation_request"> | Date | string
  }, "clinic_module_activation_request_id">

  export type clinic_module_activation_requestOrderByWithAggregationInput = {
    clinic_module_activation_request_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_num?: SortOrder
    physicianid?: SortOrder
    message?: SortOrder
    is_activated?: SortOrder
    added_date?: SortOrder
    _count?: clinic_module_activation_requestCountOrderByAggregateInput
    _avg?: clinic_module_activation_requestAvgOrderByAggregateInput
    _max?: clinic_module_activation_requestMaxOrderByAggregateInput
    _min?: clinic_module_activation_requestMinOrderByAggregateInput
    _sum?: clinic_module_activation_requestSumOrderByAggregateInput
  }

  export type clinic_module_activation_requestScalarWhereWithAggregatesInput = {
    AND?: clinic_module_activation_requestScalarWhereWithAggregatesInput | clinic_module_activation_requestScalarWhereWithAggregatesInput[]
    OR?: clinic_module_activation_requestScalarWhereWithAggregatesInput[]
    NOT?: clinic_module_activation_requestScalarWhereWithAggregatesInput | clinic_module_activation_requestScalarWhereWithAggregatesInput[]
    clinic_module_activation_request_id?: IntWithAggregatesFilter<"clinic_module_activation_request"> | number
    name?: StringWithAggregatesFilter<"clinic_module_activation_request"> | string
    email?: StringWithAggregatesFilter<"clinic_module_activation_request"> | string
    phone_num?: StringWithAggregatesFilter<"clinic_module_activation_request"> | string
    physicianid?: IntWithAggregatesFilter<"clinic_module_activation_request"> | number
    message?: StringWithAggregatesFilter<"clinic_module_activation_request"> | string
    is_activated?: IntWithAggregatesFilter<"clinic_module_activation_request"> | number
    added_date?: DateTimeWithAggregatesFilter<"clinic_module_activation_request"> | Date | string
  }

  export type clinical_parametersWhereInput = {
    AND?: clinical_parametersWhereInput | clinical_parametersWhereInput[]
    OR?: clinical_parametersWhereInput[]
    NOT?: clinical_parametersWhereInput | clinical_parametersWhereInput[]
    clinical_parameterid?: IntFilter<"clinical_parameters"> | number
    blood_pressure?: StringFilter<"clinical_parameters"> | string
    systolic_blood_pressure?: StringFilter<"clinical_parameters"> | string
    diastolic_blood_pressure?: StringFilter<"clinical_parameters"> | string
    sugar?: StringFilter<"clinical_parameters"> | string
    pulse?: StringFilter<"clinical_parameters"> | string
    height?: StringFilter<"clinical_parameters"> | string
    weight?: StringFilter<"clinical_parameters"> | string
    temperature?: StringFilter<"clinical_parameters"> | string
    referral_patient_id?: IntFilter<"clinical_parameters"> | number
    dependent_id?: IntFilter<"clinical_parameters"> | number
    created_on?: StringNullableFilter<"clinical_parameters"> | string | null
  }

  export type clinical_parametersOrderByWithRelationInput = {
    clinical_parameterid?: SortOrder
    blood_pressure?: SortOrder
    systolic_blood_pressure?: SortOrder
    diastolic_blood_pressure?: SortOrder
    sugar?: SortOrder
    pulse?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    temperature?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
  }

  export type clinical_parametersWhereUniqueInput = Prisma.AtLeast<{
    clinical_parameterid?: number
    AND?: clinical_parametersWhereInput | clinical_parametersWhereInput[]
    OR?: clinical_parametersWhereInput[]
    NOT?: clinical_parametersWhereInput | clinical_parametersWhereInput[]
    blood_pressure?: StringFilter<"clinical_parameters"> | string
    systolic_blood_pressure?: StringFilter<"clinical_parameters"> | string
    diastolic_blood_pressure?: StringFilter<"clinical_parameters"> | string
    sugar?: StringFilter<"clinical_parameters"> | string
    pulse?: StringFilter<"clinical_parameters"> | string
    height?: StringFilter<"clinical_parameters"> | string
    weight?: StringFilter<"clinical_parameters"> | string
    temperature?: StringFilter<"clinical_parameters"> | string
    referral_patient_id?: IntFilter<"clinical_parameters"> | number
    dependent_id?: IntFilter<"clinical_parameters"> | number
    created_on?: StringNullableFilter<"clinical_parameters"> | string | null
  }, "clinical_parameterid">

  export type clinical_parametersOrderByWithAggregationInput = {
    clinical_parameterid?: SortOrder
    blood_pressure?: SortOrder
    systolic_blood_pressure?: SortOrder
    diastolic_blood_pressure?: SortOrder
    sugar?: SortOrder
    pulse?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    temperature?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    _count?: clinical_parametersCountOrderByAggregateInput
    _avg?: clinical_parametersAvgOrderByAggregateInput
    _max?: clinical_parametersMaxOrderByAggregateInput
    _min?: clinical_parametersMinOrderByAggregateInput
    _sum?: clinical_parametersSumOrderByAggregateInput
  }

  export type clinical_parametersScalarWhereWithAggregatesInput = {
    AND?: clinical_parametersScalarWhereWithAggregatesInput | clinical_parametersScalarWhereWithAggregatesInput[]
    OR?: clinical_parametersScalarWhereWithAggregatesInput[]
    NOT?: clinical_parametersScalarWhereWithAggregatesInput | clinical_parametersScalarWhereWithAggregatesInput[]
    clinical_parameterid?: IntWithAggregatesFilter<"clinical_parameters"> | number
    blood_pressure?: StringWithAggregatesFilter<"clinical_parameters"> | string
    systolic_blood_pressure?: StringWithAggregatesFilter<"clinical_parameters"> | string
    diastolic_blood_pressure?: StringWithAggregatesFilter<"clinical_parameters"> | string
    sugar?: StringWithAggregatesFilter<"clinical_parameters"> | string
    pulse?: StringWithAggregatesFilter<"clinical_parameters"> | string
    height?: StringWithAggregatesFilter<"clinical_parameters"> | string
    weight?: StringWithAggregatesFilter<"clinical_parameters"> | string
    temperature?: StringWithAggregatesFilter<"clinical_parameters"> | string
    referral_patient_id?: IntWithAggregatesFilter<"clinical_parameters"> | number
    dependent_id?: IntWithAggregatesFilter<"clinical_parameters"> | number
    created_on?: StringNullableWithAggregatesFilter<"clinical_parameters"> | string | null
  }

  export type contactWhereInput = {
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    id?: IntFilter<"contact"> | number
    name?: StringFilter<"contact"> | string
    emailid?: StringFilter<"contact"> | string
    subject?: StringFilter<"contact"> | string
    message?: StringFilter<"contact"> | string
    created_date?: DateTimeFilter<"contact"> | Date | string
  }

  export type contactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    emailid?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_date?: SortOrder
  }

  export type contactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    name?: StringFilter<"contact"> | string
    emailid?: StringFilter<"contact"> | string
    subject?: StringFilter<"contact"> | string
    message?: StringFilter<"contact"> | string
    created_date?: DateTimeFilter<"contact"> | Date | string
  }, "id">

  export type contactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    emailid?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_date?: SortOrder
    _count?: contactCountOrderByAggregateInput
    _avg?: contactAvgOrderByAggregateInput
    _max?: contactMaxOrderByAggregateInput
    _min?: contactMinOrderByAggregateInput
    _sum?: contactSumOrderByAggregateInput
  }

  export type contactScalarWhereWithAggregatesInput = {
    AND?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    OR?: contactScalarWhereWithAggregatesInput[]
    NOT?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"contact"> | number
    name?: StringWithAggregatesFilter<"contact"> | string
    emailid?: StringWithAggregatesFilter<"contact"> | string
    subject?: StringWithAggregatesFilter<"contact"> | string
    message?: StringWithAggregatesFilter<"contact"> | string
    created_date?: DateTimeWithAggregatesFilter<"contact"> | Date | string
  }

  export type countryWhereInput = {
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    country_id?: IntFilter<"country"> | number
    country_name?: StringNullableFilter<"country"> | string | null
    active?: BoolFilter<"country"> | boolean
  }

  export type countryOrderByWithRelationInput = {
    country_id?: SortOrder
    country_name?: SortOrderInput | SortOrder
    active?: SortOrder
  }

  export type countryWhereUniqueInput = Prisma.AtLeast<{
    country_id?: number
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    country_name?: StringNullableFilter<"country"> | string | null
    active?: BoolFilter<"country"> | boolean
  }, "country_id">

  export type countryOrderByWithAggregationInput = {
    country_id?: SortOrder
    country_name?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: countryCountOrderByAggregateInput
    _avg?: countryAvgOrderByAggregateInput
    _max?: countryMaxOrderByAggregateInput
    _min?: countryMinOrderByAggregateInput
    _sum?: countrySumOrderByAggregateInput
  }

  export type countryScalarWhereWithAggregatesInput = {
    AND?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    OR?: countryScalarWhereWithAggregatesInput[]
    NOT?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    country_id?: IntWithAggregatesFilter<"country"> | number
    country_name?: StringNullableWithAggregatesFilter<"country"> | string | null
    active?: BoolWithAggregatesFilter<"country"> | boolean
  }

  export type filesWhereInput = {
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    id?: IntFilter<"files"> | number
    file_name?: StringFilter<"files"> | string
    type?: StringFilter<"files"> | string
    medical_num?: StringFilter<"files"> | string
    patient_unique_id?: StringFilter<"files"> | string
    referral_id?: StringFilter<"files"> | string
    uploaded_on?: DateTimeFilter<"files"> | Date | string
    status?: Enumfiles_statusFilter<"files"> | $Enums.files_status
  }

  export type filesOrderByWithRelationInput = {
    id?: SortOrder
    file_name?: SortOrder
    type?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    referral_id?: SortOrder
    uploaded_on?: SortOrder
    status?: SortOrder
  }

  export type filesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    file_name?: StringFilter<"files"> | string
    type?: StringFilter<"files"> | string
    medical_num?: StringFilter<"files"> | string
    patient_unique_id?: StringFilter<"files"> | string
    referral_id?: StringFilter<"files"> | string
    uploaded_on?: DateTimeFilter<"files"> | Date | string
    status?: Enumfiles_statusFilter<"files"> | $Enums.files_status
  }, "id">

  export type filesOrderByWithAggregationInput = {
    id?: SortOrder
    file_name?: SortOrder
    type?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    referral_id?: SortOrder
    uploaded_on?: SortOrder
    status?: SortOrder
    _count?: filesCountOrderByAggregateInput
    _avg?: filesAvgOrderByAggregateInput
    _max?: filesMaxOrderByAggregateInput
    _min?: filesMinOrderByAggregateInput
    _sum?: filesSumOrderByAggregateInput
  }

  export type filesScalarWhereWithAggregatesInput = {
    AND?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    OR?: filesScalarWhereWithAggregatesInput[]
    NOT?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"files"> | number
    file_name?: StringWithAggregatesFilter<"files"> | string
    type?: StringWithAggregatesFilter<"files"> | string
    medical_num?: StringWithAggregatesFilter<"files"> | string
    patient_unique_id?: StringWithAggregatesFilter<"files"> | string
    referral_id?: StringWithAggregatesFilter<"files"> | string
    uploaded_on?: DateTimeWithAggregatesFilter<"files"> | Date | string
    status?: Enumfiles_statusWithAggregatesFilter<"files"> | $Enums.files_status
  }

  export type investigation_detailsWhereInput = {
    AND?: investigation_detailsWhereInput | investigation_detailsWhereInput[]
    OR?: investigation_detailsWhereInput[]
    NOT?: investigation_detailsWhereInput | investigation_detailsWhereInput[]
    investigation_id?: IntFilter<"investigation_details"> | number
    investigation_name?: StringNullableFilter<"investigation_details"> | string | null
    active?: IntNullableFilter<"investigation_details"> | number | null
    investigation_test_details?: Investigation_test_detailsListRelationFilter
  }

  export type investigation_detailsOrderByWithRelationInput = {
    investigation_id?: SortOrder
    investigation_name?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    investigation_test_details?: investigation_test_detailsOrderByRelationAggregateInput
  }

  export type investigation_detailsWhereUniqueInput = Prisma.AtLeast<{
    investigation_id?: number
    AND?: investigation_detailsWhereInput | investigation_detailsWhereInput[]
    OR?: investigation_detailsWhereInput[]
    NOT?: investigation_detailsWhereInput | investigation_detailsWhereInput[]
    investigation_name?: StringNullableFilter<"investigation_details"> | string | null
    active?: IntNullableFilter<"investigation_details"> | number | null
    investigation_test_details?: Investigation_test_detailsListRelationFilter
  }, "investigation_id">

  export type investigation_detailsOrderByWithAggregationInput = {
    investigation_id?: SortOrder
    investigation_name?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    _count?: investigation_detailsCountOrderByAggregateInput
    _avg?: investigation_detailsAvgOrderByAggregateInput
    _max?: investigation_detailsMaxOrderByAggregateInput
    _min?: investigation_detailsMinOrderByAggregateInput
    _sum?: investigation_detailsSumOrderByAggregateInput
  }

  export type investigation_detailsScalarWhereWithAggregatesInput = {
    AND?: investigation_detailsScalarWhereWithAggregatesInput | investigation_detailsScalarWhereWithAggregatesInput[]
    OR?: investigation_detailsScalarWhereWithAggregatesInput[]
    NOT?: investigation_detailsScalarWhereWithAggregatesInput | investigation_detailsScalarWhereWithAggregatesInput[]
    investigation_id?: IntWithAggregatesFilter<"investigation_details"> | number
    investigation_name?: StringNullableWithAggregatesFilter<"investigation_details"> | string | null
    active?: IntNullableWithAggregatesFilter<"investigation_details"> | number | null
  }

  export type investigation_fileWhereInput = {
    AND?: investigation_fileWhereInput | investigation_fileWhereInput[]
    OR?: investigation_fileWhereInput[]
    NOT?: investigation_fileWhereInput | investigation_fileWhereInput[]
    file_id?: IntFilter<"investigation_file"> | number
    investigation_file?: StringFilter<"investigation_file"> | string
    referral_test_ID?: IntFilter<"investigation_file"> | number
    uploaded_on?: DateTimeFilter<"investigation_file"> | Date | string
  }

  export type investigation_fileOrderByWithRelationInput = {
    file_id?: SortOrder
    investigation_file?: SortOrder
    referral_test_ID?: SortOrder
    uploaded_on?: SortOrder
  }

  export type investigation_fileWhereUniqueInput = Prisma.AtLeast<{
    file_id?: number
    AND?: investigation_fileWhereInput | investigation_fileWhereInput[]
    OR?: investigation_fileWhereInput[]
    NOT?: investigation_fileWhereInput | investigation_fileWhereInput[]
    investigation_file?: StringFilter<"investigation_file"> | string
    referral_test_ID?: IntFilter<"investigation_file"> | number
    uploaded_on?: DateTimeFilter<"investigation_file"> | Date | string
  }, "file_id">

  export type investigation_fileOrderByWithAggregationInput = {
    file_id?: SortOrder
    investigation_file?: SortOrder
    referral_test_ID?: SortOrder
    uploaded_on?: SortOrder
    _count?: investigation_fileCountOrderByAggregateInput
    _avg?: investigation_fileAvgOrderByAggregateInput
    _max?: investigation_fileMaxOrderByAggregateInput
    _min?: investigation_fileMinOrderByAggregateInput
    _sum?: investigation_fileSumOrderByAggregateInput
  }

  export type investigation_fileScalarWhereWithAggregatesInput = {
    AND?: investigation_fileScalarWhereWithAggregatesInput | investigation_fileScalarWhereWithAggregatesInput[]
    OR?: investigation_fileScalarWhereWithAggregatesInput[]
    NOT?: investigation_fileScalarWhereWithAggregatesInput | investigation_fileScalarWhereWithAggregatesInput[]
    file_id?: IntWithAggregatesFilter<"investigation_file"> | number
    investigation_file?: StringWithAggregatesFilter<"investigation_file"> | string
    referral_test_ID?: IntWithAggregatesFilter<"investigation_file"> | number
    uploaded_on?: DateTimeWithAggregatesFilter<"investigation_file"> | Date | string
  }

  export type investigation_test_detailsWhereInput = {
    AND?: investigation_test_detailsWhereInput | investigation_test_detailsWhereInput[]
    OR?: investigation_test_detailsWhereInput[]
    NOT?: investigation_test_detailsWhereInput | investigation_test_detailsWhereInput[]
    parse_id?: IntFilter<"investigation_test_details"> | number
    test_name?: StringFilter<"investigation_test_details"> | string
    investigation_id?: IntFilter<"investigation_test_details"> | number
    parent_parse_id?: IntFilter<"investigation_test_details"> | number
    active?: IntFilter<"investigation_test_details"> | number
    investigation_details?: XOR<Investigation_detailsRelationFilter, investigation_detailsWhereInput>
  }

  export type investigation_test_detailsOrderByWithRelationInput = {
    parse_id?: SortOrder
    test_name?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
    investigation_details?: investigation_detailsOrderByWithRelationInput
  }

  export type investigation_test_detailsWhereUniqueInput = Prisma.AtLeast<{
    parse_id?: number
    AND?: investigation_test_detailsWhereInput | investigation_test_detailsWhereInput[]
    OR?: investigation_test_detailsWhereInput[]
    NOT?: investigation_test_detailsWhereInput | investigation_test_detailsWhereInput[]
    test_name?: StringFilter<"investigation_test_details"> | string
    investigation_id?: IntFilter<"investigation_test_details"> | number
    parent_parse_id?: IntFilter<"investigation_test_details"> | number
    active?: IntFilter<"investigation_test_details"> | number
    investigation_details?: XOR<Investigation_detailsRelationFilter, investigation_detailsWhereInput>
  }, "parse_id">

  export type investigation_test_detailsOrderByWithAggregationInput = {
    parse_id?: SortOrder
    test_name?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
    _count?: investigation_test_detailsCountOrderByAggregateInput
    _avg?: investigation_test_detailsAvgOrderByAggregateInput
    _max?: investigation_test_detailsMaxOrderByAggregateInput
    _min?: investigation_test_detailsMinOrderByAggregateInput
    _sum?: investigation_test_detailsSumOrderByAggregateInput
  }

  export type investigation_test_detailsScalarWhereWithAggregatesInput = {
    AND?: investigation_test_detailsScalarWhereWithAggregatesInput | investigation_test_detailsScalarWhereWithAggregatesInput[]
    OR?: investigation_test_detailsScalarWhereWithAggregatesInput[]
    NOT?: investigation_test_detailsScalarWhereWithAggregatesInput | investigation_test_detailsScalarWhereWithAggregatesInput[]
    parse_id?: IntWithAggregatesFilter<"investigation_test_details"> | number
    test_name?: StringWithAggregatesFilter<"investigation_test_details"> | string
    investigation_id?: IntWithAggregatesFilter<"investigation_test_details"> | number
    parent_parse_id?: IntWithAggregatesFilter<"investigation_test_details"> | number
    active?: IntWithAggregatesFilter<"investigation_test_details"> | number
  }

  export type lab_leavesWhereInput = {
    AND?: lab_leavesWhereInput | lab_leavesWhereInput[]
    OR?: lab_leavesWhereInput[]
    NOT?: lab_leavesWhereInput | lab_leavesWhereInput[]
    id?: IntFilter<"lab_leaves"> | number
    lab_id?: BigIntFilter<"lab_leaves"> | bigint | number
    dates?: StringFilter<"lab_leaves"> | string
    start_time?: StringNullableFilter<"lab_leaves"> | string | null
    end_time?: StringNullableFilter<"lab_leaves"> | string | null
    reason?: StringNullableFilter<"lab_leaves"> | string | null
    created_time?: StringFilter<"lab_leaves"> | string
  }

  export type lab_leavesOrderByWithRelationInput = {
    id?: SortOrder
    lab_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_time?: SortOrder
  }

  export type lab_leavesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: lab_leavesWhereInput | lab_leavesWhereInput[]
    OR?: lab_leavesWhereInput[]
    NOT?: lab_leavesWhereInput | lab_leavesWhereInput[]
    lab_id?: BigIntFilter<"lab_leaves"> | bigint | number
    dates?: StringFilter<"lab_leaves"> | string
    start_time?: StringNullableFilter<"lab_leaves"> | string | null
    end_time?: StringNullableFilter<"lab_leaves"> | string | null
    reason?: StringNullableFilter<"lab_leaves"> | string | null
    created_time?: StringFilter<"lab_leaves"> | string
  }, "id">

  export type lab_leavesOrderByWithAggregationInput = {
    id?: SortOrder
    lab_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_time?: SortOrder
    _count?: lab_leavesCountOrderByAggregateInput
    _avg?: lab_leavesAvgOrderByAggregateInput
    _max?: lab_leavesMaxOrderByAggregateInput
    _min?: lab_leavesMinOrderByAggregateInput
    _sum?: lab_leavesSumOrderByAggregateInput
  }

  export type lab_leavesScalarWhereWithAggregatesInput = {
    AND?: lab_leavesScalarWhereWithAggregatesInput | lab_leavesScalarWhereWithAggregatesInput[]
    OR?: lab_leavesScalarWhereWithAggregatesInput[]
    NOT?: lab_leavesScalarWhereWithAggregatesInput | lab_leavesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lab_leaves"> | number
    lab_id?: BigIntWithAggregatesFilter<"lab_leaves"> | bigint | number
    dates?: StringWithAggregatesFilter<"lab_leaves"> | string
    start_time?: StringNullableWithAggregatesFilter<"lab_leaves"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"lab_leaves"> | string | null
    reason?: StringNullableWithAggregatesFilter<"lab_leaves"> | string | null
    created_time?: StringWithAggregatesFilter<"lab_leaves"> | string
  }

  export type lab_tests_price_updatesWhereInput = {
    AND?: lab_tests_price_updatesWhereInput | lab_tests_price_updatesWhereInput[]
    OR?: lab_tests_price_updatesWhereInput[]
    NOT?: lab_tests_price_updatesWhereInput | lab_tests_price_updatesWhereInput[]
    id?: IntFilter<"lab_tests_price_updates"> | number
    lab_id?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    test_id?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    price?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    unit?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    reference_range?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_date?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_by?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_by_phone_num?: StringNullableFilter<"lab_tests_price_updates"> | string | null
  }

  export type lab_tests_price_updatesOrderByWithRelationInput = {
    id?: SortOrder
    lab_id?: SortOrderInput | SortOrder
    test_id?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    reference_range?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_by_phone_num?: SortOrderInput | SortOrder
  }

  export type lab_tests_price_updatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: lab_tests_price_updatesWhereInput | lab_tests_price_updatesWhereInput[]
    OR?: lab_tests_price_updatesWhereInput[]
    NOT?: lab_tests_price_updatesWhereInput | lab_tests_price_updatesWhereInput[]
    lab_id?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    test_id?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    price?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    unit?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    reference_range?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_date?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_by?: StringNullableFilter<"lab_tests_price_updates"> | string | null
    created_by_phone_num?: StringNullableFilter<"lab_tests_price_updates"> | string | null
  }, "id">

  export type lab_tests_price_updatesOrderByWithAggregationInput = {
    id?: SortOrder
    lab_id?: SortOrderInput | SortOrder
    test_id?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    reference_range?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_by_phone_num?: SortOrderInput | SortOrder
    _count?: lab_tests_price_updatesCountOrderByAggregateInput
    _avg?: lab_tests_price_updatesAvgOrderByAggregateInput
    _max?: lab_tests_price_updatesMaxOrderByAggregateInput
    _min?: lab_tests_price_updatesMinOrderByAggregateInput
    _sum?: lab_tests_price_updatesSumOrderByAggregateInput
  }

  export type lab_tests_price_updatesScalarWhereWithAggregatesInput = {
    AND?: lab_tests_price_updatesScalarWhereWithAggregatesInput | lab_tests_price_updatesScalarWhereWithAggregatesInput[]
    OR?: lab_tests_price_updatesScalarWhereWithAggregatesInput[]
    NOT?: lab_tests_price_updatesScalarWhereWithAggregatesInput | lab_tests_price_updatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lab_tests_price_updates"> | number
    lab_id?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    test_id?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    price?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    unit?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    reference_range?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    created_date?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
    created_by_phone_num?: StringNullableWithAggregatesFilter<"lab_tests_price_updates"> | string | null
  }

  export type lab_timingsWhereInput = {
    AND?: lab_timingsWhereInput | lab_timingsWhereInput[]
    OR?: lab_timingsWhereInput[]
    NOT?: lab_timingsWhereInput | lab_timingsWhereInput[]
    id?: IntFilter<"lab_timings"> | number
    lab_id?: IntFilter<"lab_timings"> | number
    theday?: StringFilter<"lab_timings"> | string
    work_type?: Enumlab_timings_work_typeFilter<"lab_timings"> | $Enums.lab_timings_work_type
    start_time?: StringNullableFilter<"lab_timings"> | string | null
    end_time?: StringNullableFilter<"lab_timings"> | string | null
    created_time?: StringNullableFilter<"lab_timings"> | string | null
    updated_time?: StringNullableFilter<"lab_timings"> | string | null
  }

  export type lab_timingsOrderByWithRelationInput = {
    id?: SortOrder
    lab_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
  }

  export type lab_timingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: lab_timingsWhereInput | lab_timingsWhereInput[]
    OR?: lab_timingsWhereInput[]
    NOT?: lab_timingsWhereInput | lab_timingsWhereInput[]
    lab_id?: IntFilter<"lab_timings"> | number
    theday?: StringFilter<"lab_timings"> | string
    work_type?: Enumlab_timings_work_typeFilter<"lab_timings"> | $Enums.lab_timings_work_type
    start_time?: StringNullableFilter<"lab_timings"> | string | null
    end_time?: StringNullableFilter<"lab_timings"> | string | null
    created_time?: StringNullableFilter<"lab_timings"> | string | null
    updated_time?: StringNullableFilter<"lab_timings"> | string | null
  }, "id">

  export type lab_timingsOrderByWithAggregationInput = {
    id?: SortOrder
    lab_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
    _count?: lab_timingsCountOrderByAggregateInput
    _avg?: lab_timingsAvgOrderByAggregateInput
    _max?: lab_timingsMaxOrderByAggregateInput
    _min?: lab_timingsMinOrderByAggregateInput
    _sum?: lab_timingsSumOrderByAggregateInput
  }

  export type lab_timingsScalarWhereWithAggregatesInput = {
    AND?: lab_timingsScalarWhereWithAggregatesInput | lab_timingsScalarWhereWithAggregatesInput[]
    OR?: lab_timingsScalarWhereWithAggregatesInput[]
    NOT?: lab_timingsScalarWhereWithAggregatesInput | lab_timingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lab_timings"> | number
    lab_id?: IntWithAggregatesFilter<"lab_timings"> | number
    theday?: StringWithAggregatesFilter<"lab_timings"> | string
    work_type?: Enumlab_timings_work_typeWithAggregatesFilter<"lab_timings"> | $Enums.lab_timings_work_type
    start_time?: StringNullableWithAggregatesFilter<"lab_timings"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"lab_timings"> | string | null
    created_time?: StringNullableWithAggregatesFilter<"lab_timings"> | string | null
    updated_time?: StringNullableWithAggregatesFilter<"lab_timings"> | string | null
  }

  export type laboratory_detailsWhereInput = {
    AND?: laboratory_detailsWhereInput | laboratory_detailsWhereInput[]
    OR?: laboratory_detailsWhereInput[]
    NOT?: laboratory_detailsWhereInput | laboratory_detailsWhereInput[]
    laboratory_id?: IntFilter<"laboratory_details"> | number
    laboratory_name?: StringFilter<"laboratory_details"> | string
    laboratory_address?: StringFilter<"laboratory_details"> | string
    locality?: StringFilter<"laboratory_details"> | string
    laboratory_phone?: StringFilter<"laboratory_details"> | string
    laboratory_email?: StringFilter<"laboratory_details"> | string
    laboratory_password?: StringFilter<"laboratory_details"> | string
    lab_state?: StringFilter<"laboratory_details"> | string
    lab_city?: StringFilter<"laboratory_details"> | string
    lab_pincode?: StringFilter<"laboratory_details"> | string
    created_on?: DateTimeFilter<"laboratory_details"> | Date | string
    updated_on?: DateTimeFilter<"laboratory_details"> | Date | string
    active?: IntFilter<"laboratory_details"> | number
    role_id?: IntFilter<"laboratory_details"> | number
    profile_filename?: StringFilter<"laboratory_details"> | string
    profile_fullpath?: StringFilter<"laboratory_details"> | string
    laboratory_test_details?: Laboratory_test_detailsListRelationFilter
  }

  export type laboratory_detailsOrderByWithRelationInput = {
    laboratory_id?: SortOrder
    laboratory_name?: SortOrder
    laboratory_address?: SortOrder
    locality?: SortOrder
    laboratory_phone?: SortOrder
    laboratory_email?: SortOrder
    laboratory_password?: SortOrder
    lab_state?: SortOrder
    lab_city?: SortOrder
    lab_pincode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    laboratory_test_details?: laboratory_test_detailsOrderByRelationAggregateInput
  }

  export type laboratory_detailsWhereUniqueInput = Prisma.AtLeast<{
    laboratory_id?: number
    laboratory_phone_laboratory_email?: laboratory_detailsLaboratory_phoneLaboratory_emailCompoundUniqueInput
    AND?: laboratory_detailsWhereInput | laboratory_detailsWhereInput[]
    OR?: laboratory_detailsWhereInput[]
    NOT?: laboratory_detailsWhereInput | laboratory_detailsWhereInput[]
    laboratory_name?: StringFilter<"laboratory_details"> | string
    laboratory_address?: StringFilter<"laboratory_details"> | string
    locality?: StringFilter<"laboratory_details"> | string
    laboratory_phone?: StringFilter<"laboratory_details"> | string
    laboratory_email?: StringFilter<"laboratory_details"> | string
    laboratory_password?: StringFilter<"laboratory_details"> | string
    lab_state?: StringFilter<"laboratory_details"> | string
    lab_city?: StringFilter<"laboratory_details"> | string
    lab_pincode?: StringFilter<"laboratory_details"> | string
    created_on?: DateTimeFilter<"laboratory_details"> | Date | string
    updated_on?: DateTimeFilter<"laboratory_details"> | Date | string
    active?: IntFilter<"laboratory_details"> | number
    role_id?: IntFilter<"laboratory_details"> | number
    profile_filename?: StringFilter<"laboratory_details"> | string
    profile_fullpath?: StringFilter<"laboratory_details"> | string
    laboratory_test_details?: Laboratory_test_detailsListRelationFilter
  }, "laboratory_phone_laboratory_email" | "laboratory_id">

  export type laboratory_detailsOrderByWithAggregationInput = {
    laboratory_id?: SortOrder
    laboratory_name?: SortOrder
    laboratory_address?: SortOrder
    locality?: SortOrder
    laboratory_phone?: SortOrder
    laboratory_email?: SortOrder
    laboratory_password?: SortOrder
    lab_state?: SortOrder
    lab_city?: SortOrder
    lab_pincode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    _count?: laboratory_detailsCountOrderByAggregateInput
    _avg?: laboratory_detailsAvgOrderByAggregateInput
    _max?: laboratory_detailsMaxOrderByAggregateInput
    _min?: laboratory_detailsMinOrderByAggregateInput
    _sum?: laboratory_detailsSumOrderByAggregateInput
  }

  export type laboratory_detailsScalarWhereWithAggregatesInput = {
    AND?: laboratory_detailsScalarWhereWithAggregatesInput | laboratory_detailsScalarWhereWithAggregatesInput[]
    OR?: laboratory_detailsScalarWhereWithAggregatesInput[]
    NOT?: laboratory_detailsScalarWhereWithAggregatesInput | laboratory_detailsScalarWhereWithAggregatesInput[]
    laboratory_id?: IntWithAggregatesFilter<"laboratory_details"> | number
    laboratory_name?: StringWithAggregatesFilter<"laboratory_details"> | string
    laboratory_address?: StringWithAggregatesFilter<"laboratory_details"> | string
    locality?: StringWithAggregatesFilter<"laboratory_details"> | string
    laboratory_phone?: StringWithAggregatesFilter<"laboratory_details"> | string
    laboratory_email?: StringWithAggregatesFilter<"laboratory_details"> | string
    laboratory_password?: StringWithAggregatesFilter<"laboratory_details"> | string
    lab_state?: StringWithAggregatesFilter<"laboratory_details"> | string
    lab_city?: StringWithAggregatesFilter<"laboratory_details"> | string
    lab_pincode?: StringWithAggregatesFilter<"laboratory_details"> | string
    created_on?: DateTimeWithAggregatesFilter<"laboratory_details"> | Date | string
    updated_on?: DateTimeWithAggregatesFilter<"laboratory_details"> | Date | string
    active?: IntWithAggregatesFilter<"laboratory_details"> | number
    role_id?: IntWithAggregatesFilter<"laboratory_details"> | number
    profile_filename?: StringWithAggregatesFilter<"laboratory_details"> | string
    profile_fullpath?: StringWithAggregatesFilter<"laboratory_details"> | string
  }

  export type laboratory_doctorsWhereInput = {
    AND?: laboratory_doctorsWhereInput | laboratory_doctorsWhereInput[]
    OR?: laboratory_doctorsWhereInput[]
    NOT?: laboratory_doctorsWhereInput | laboratory_doctorsWhereInput[]
    laboratory_doctors_id?: IntFilter<"laboratory_doctors"> | number
    laboratory_id?: IntFilter<"laboratory_doctors"> | number
    doc_firstname?: StringFilter<"laboratory_doctors"> | string
    doc_lastname?: StringFilter<"laboratory_doctors"> | string
    doc_password?: StringFilter<"laboratory_doctors"> | string
    doc_phone_number?: StringFilter<"laboratory_doctors"> | string
    doc_email?: StringFilter<"laboratory_doctors"> | string
    doc_dept?: IntFilter<"laboratory_doctors"> | number
    doc_signature?: StringFilter<"laboratory_doctors"> | string
    added_date?: DateTimeFilter<"laboratory_doctors"> | Date | string
    doc_designation?: StringFilter<"laboratory_doctors"> | string
    is_active?: IntFilter<"laboratory_doctors"> | number
  }

  export type laboratory_doctorsOrderByWithRelationInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_firstname?: SortOrder
    doc_lastname?: SortOrder
    doc_password?: SortOrder
    doc_phone_number?: SortOrder
    doc_email?: SortOrder
    doc_dept?: SortOrder
    doc_signature?: SortOrder
    added_date?: SortOrder
    doc_designation?: SortOrder
    is_active?: SortOrder
  }

  export type laboratory_doctorsWhereUniqueInput = Prisma.AtLeast<{
    laboratory_doctors_id?: number
    AND?: laboratory_doctorsWhereInput | laboratory_doctorsWhereInput[]
    OR?: laboratory_doctorsWhereInput[]
    NOT?: laboratory_doctorsWhereInput | laboratory_doctorsWhereInput[]
    laboratory_id?: IntFilter<"laboratory_doctors"> | number
    doc_firstname?: StringFilter<"laboratory_doctors"> | string
    doc_lastname?: StringFilter<"laboratory_doctors"> | string
    doc_password?: StringFilter<"laboratory_doctors"> | string
    doc_phone_number?: StringFilter<"laboratory_doctors"> | string
    doc_email?: StringFilter<"laboratory_doctors"> | string
    doc_dept?: IntFilter<"laboratory_doctors"> | number
    doc_signature?: StringFilter<"laboratory_doctors"> | string
    added_date?: DateTimeFilter<"laboratory_doctors"> | Date | string
    doc_designation?: StringFilter<"laboratory_doctors"> | string
    is_active?: IntFilter<"laboratory_doctors"> | number
  }, "laboratory_doctors_id">

  export type laboratory_doctorsOrderByWithAggregationInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_firstname?: SortOrder
    doc_lastname?: SortOrder
    doc_password?: SortOrder
    doc_phone_number?: SortOrder
    doc_email?: SortOrder
    doc_dept?: SortOrder
    doc_signature?: SortOrder
    added_date?: SortOrder
    doc_designation?: SortOrder
    is_active?: SortOrder
    _count?: laboratory_doctorsCountOrderByAggregateInput
    _avg?: laboratory_doctorsAvgOrderByAggregateInput
    _max?: laboratory_doctorsMaxOrderByAggregateInput
    _min?: laboratory_doctorsMinOrderByAggregateInput
    _sum?: laboratory_doctorsSumOrderByAggregateInput
  }

  export type laboratory_doctorsScalarWhereWithAggregatesInput = {
    AND?: laboratory_doctorsScalarWhereWithAggregatesInput | laboratory_doctorsScalarWhereWithAggregatesInput[]
    OR?: laboratory_doctorsScalarWhereWithAggregatesInput[]
    NOT?: laboratory_doctorsScalarWhereWithAggregatesInput | laboratory_doctorsScalarWhereWithAggregatesInput[]
    laboratory_doctors_id?: IntWithAggregatesFilter<"laboratory_doctors"> | number
    laboratory_id?: IntWithAggregatesFilter<"laboratory_doctors"> | number
    doc_firstname?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    doc_lastname?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    doc_password?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    doc_phone_number?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    doc_email?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    doc_dept?: IntWithAggregatesFilter<"laboratory_doctors"> | number
    doc_signature?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    added_date?: DateTimeWithAggregatesFilter<"laboratory_doctors"> | Date | string
    doc_designation?: StringWithAggregatesFilter<"laboratory_doctors"> | string
    is_active?: IntWithAggregatesFilter<"laboratory_doctors"> | number
  }

  export type laboratory_test_detailsWhereInput = {
    AND?: laboratory_test_detailsWhereInput | laboratory_test_detailsWhereInput[]
    OR?: laboratory_test_detailsWhereInput[]
    NOT?: laboratory_test_detailsWhereInput | laboratory_test_detailsWhereInput[]
    laboratory_testid?: IntFilter<"laboratory_test_details"> | number
    laboratory_tests?: StringFilter<"laboratory_test_details"> | string
    code?: StringFilter<"laboratory_test_details"> | string
    display_order?: IntNullableFilter<"laboratory_test_details"> | number | null
    mnemonics?: StringNullableFilter<"laboratory_test_details"> | string | null
    test_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    sub_department?: StringNullableFilter<"laboratory_test_details"> | string | null
    sample_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    container_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    confidential?: StringNullableFilter<"laboratory_test_details"> | string | null
    methodology?: StringNullableFilter<"laboratory_test_details"> | string | null
    transport_temperature?: StringNullableFilter<"laboratory_test_details"> | string | null
    tat?: StringNullableFilter<"laboratory_test_details"> | string | null
    outsourcing_status?: StringNullableFilter<"laboratory_test_details"> | string | null
    instrument?: StringNullableFilter<"laboratory_test_details"> | string | null
    laboratory_id?: IntFilter<"laboratory_test_details"> | number
    test_price?: BigIntFilter<"laboratory_test_details"> | bigint | number
    custom_test_name?: StringFilter<"laboratory_test_details"> | string
    instruction?: StringFilter<"laboratory_test_details"> | string
    test_method?: StringFilter<"laboratory_test_details"> | string
    status?: Enumlaboratory_test_details_statusFilter<"laboratory_test_details"> | $Enums.laboratory_test_details_status
    status_changed_by?: StringFilter<"laboratory_test_details"> | string
    status_changed_on?: StringFilter<"laboratory_test_details"> | string
    unit?: StringFilter<"laboratory_test_details"> | string
    reference_range?: StringFilter<"laboratory_test_details"> | string
    age_gender_specific?: StringNullableFilter<"laboratory_test_details"> | string | null
    critical_alert?: StringNullableFilter<"laboratory_test_details"> | string | null
    interpretation?: StringNullableFilter<"laboratory_test_details"> | string | null
    sort_order?: IntFilter<"laboratory_test_details"> | number
    title_required?: IntFilter<"laboratory_test_details"> | number
    laboratory_details?: XOR<Laboratory_detailsRelationFilter, laboratory_detailsWhereInput>
  }

  export type laboratory_test_detailsOrderByWithRelationInput = {
    laboratory_testid?: SortOrder
    laboratory_tests?: SortOrder
    code?: SortOrder
    display_order?: SortOrderInput | SortOrder
    mnemonics?: SortOrderInput | SortOrder
    test_type?: SortOrderInput | SortOrder
    sub_department?: SortOrderInput | SortOrder
    sample_type?: SortOrderInput | SortOrder
    container_type?: SortOrderInput | SortOrder
    confidential?: SortOrderInput | SortOrder
    methodology?: SortOrderInput | SortOrder
    transport_temperature?: SortOrderInput | SortOrder
    tat?: SortOrderInput | SortOrder
    outsourcing_status?: SortOrderInput | SortOrder
    instrument?: SortOrderInput | SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    custom_test_name?: SortOrder
    instruction?: SortOrder
    test_method?: SortOrder
    status?: SortOrder
    status_changed_by?: SortOrder
    status_changed_on?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    age_gender_specific?: SortOrderInput | SortOrder
    critical_alert?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
    laboratory_details?: laboratory_detailsOrderByWithRelationInput
  }

  export type laboratory_test_detailsWhereUniqueInput = Prisma.AtLeast<{
    laboratory_testid?: number
    AND?: laboratory_test_detailsWhereInput | laboratory_test_detailsWhereInput[]
    OR?: laboratory_test_detailsWhereInput[]
    NOT?: laboratory_test_detailsWhereInput | laboratory_test_detailsWhereInput[]
    laboratory_tests?: StringFilter<"laboratory_test_details"> | string
    code?: StringFilter<"laboratory_test_details"> | string
    display_order?: IntNullableFilter<"laboratory_test_details"> | number | null
    mnemonics?: StringNullableFilter<"laboratory_test_details"> | string | null
    test_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    sub_department?: StringNullableFilter<"laboratory_test_details"> | string | null
    sample_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    container_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    confidential?: StringNullableFilter<"laboratory_test_details"> | string | null
    methodology?: StringNullableFilter<"laboratory_test_details"> | string | null
    transport_temperature?: StringNullableFilter<"laboratory_test_details"> | string | null
    tat?: StringNullableFilter<"laboratory_test_details"> | string | null
    outsourcing_status?: StringNullableFilter<"laboratory_test_details"> | string | null
    instrument?: StringNullableFilter<"laboratory_test_details"> | string | null
    laboratory_id?: IntFilter<"laboratory_test_details"> | number
    test_price?: BigIntFilter<"laboratory_test_details"> | bigint | number
    custom_test_name?: StringFilter<"laboratory_test_details"> | string
    instruction?: StringFilter<"laboratory_test_details"> | string
    test_method?: StringFilter<"laboratory_test_details"> | string
    status?: Enumlaboratory_test_details_statusFilter<"laboratory_test_details"> | $Enums.laboratory_test_details_status
    status_changed_by?: StringFilter<"laboratory_test_details"> | string
    status_changed_on?: StringFilter<"laboratory_test_details"> | string
    unit?: StringFilter<"laboratory_test_details"> | string
    reference_range?: StringFilter<"laboratory_test_details"> | string
    age_gender_specific?: StringNullableFilter<"laboratory_test_details"> | string | null
    critical_alert?: StringNullableFilter<"laboratory_test_details"> | string | null
    interpretation?: StringNullableFilter<"laboratory_test_details"> | string | null
    sort_order?: IntFilter<"laboratory_test_details"> | number
    title_required?: IntFilter<"laboratory_test_details"> | number
    laboratory_details?: XOR<Laboratory_detailsRelationFilter, laboratory_detailsWhereInput>
  }, "laboratory_testid">

  export type laboratory_test_detailsOrderByWithAggregationInput = {
    laboratory_testid?: SortOrder
    laboratory_tests?: SortOrder
    code?: SortOrder
    display_order?: SortOrderInput | SortOrder
    mnemonics?: SortOrderInput | SortOrder
    test_type?: SortOrderInput | SortOrder
    sub_department?: SortOrderInput | SortOrder
    sample_type?: SortOrderInput | SortOrder
    container_type?: SortOrderInput | SortOrder
    confidential?: SortOrderInput | SortOrder
    methodology?: SortOrderInput | SortOrder
    transport_temperature?: SortOrderInput | SortOrder
    tat?: SortOrderInput | SortOrder
    outsourcing_status?: SortOrderInput | SortOrder
    instrument?: SortOrderInput | SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    custom_test_name?: SortOrder
    instruction?: SortOrder
    test_method?: SortOrder
    status?: SortOrder
    status_changed_by?: SortOrder
    status_changed_on?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    age_gender_specific?: SortOrderInput | SortOrder
    critical_alert?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
    _count?: laboratory_test_detailsCountOrderByAggregateInput
    _avg?: laboratory_test_detailsAvgOrderByAggregateInput
    _max?: laboratory_test_detailsMaxOrderByAggregateInput
    _min?: laboratory_test_detailsMinOrderByAggregateInput
    _sum?: laboratory_test_detailsSumOrderByAggregateInput
  }

  export type laboratory_test_detailsScalarWhereWithAggregatesInput = {
    AND?: laboratory_test_detailsScalarWhereWithAggregatesInput | laboratory_test_detailsScalarWhereWithAggregatesInput[]
    OR?: laboratory_test_detailsScalarWhereWithAggregatesInput[]
    NOT?: laboratory_test_detailsScalarWhereWithAggregatesInput | laboratory_test_detailsScalarWhereWithAggregatesInput[]
    laboratory_testid?: IntWithAggregatesFilter<"laboratory_test_details"> | number
    laboratory_tests?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    code?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    display_order?: IntNullableWithAggregatesFilter<"laboratory_test_details"> | number | null
    mnemonics?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    test_type?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    sub_department?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    sample_type?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    container_type?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    confidential?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    methodology?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    transport_temperature?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    tat?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    outsourcing_status?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    instrument?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    laboratory_id?: IntWithAggregatesFilter<"laboratory_test_details"> | number
    test_price?: BigIntWithAggregatesFilter<"laboratory_test_details"> | bigint | number
    custom_test_name?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    instruction?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    test_method?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    status?: Enumlaboratory_test_details_statusWithAggregatesFilter<"laboratory_test_details"> | $Enums.laboratory_test_details_status
    status_changed_by?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    status_changed_on?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    unit?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    reference_range?: StringWithAggregatesFilter<"laboratory_test_details"> | string
    age_gender_specific?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    critical_alert?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    interpretation?: StringNullableWithAggregatesFilter<"laboratory_test_details"> | string | null
    sort_order?: IntWithAggregatesFilter<"laboratory_test_details"> | number
    title_required?: IntWithAggregatesFilter<"laboratory_test_details"> | number
  }

  export type localityWhereInput = {
    AND?: localityWhereInput | localityWhereInput[]
    OR?: localityWhereInput[]
    NOT?: localityWhereInput | localityWhereInput[]
    locality_id?: IntFilter<"locality"> | number
    locality_name?: StringFilter<"locality"> | string
    city_id?: IntFilter<"locality"> | number
    active?: IntFilter<"locality"> | number
  }

  export type localityOrderByWithRelationInput = {
    locality_id?: SortOrder
    locality_name?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type localityWhereUniqueInput = Prisma.AtLeast<{
    locality_id?: number
    AND?: localityWhereInput | localityWhereInput[]
    OR?: localityWhereInput[]
    NOT?: localityWhereInput | localityWhereInput[]
    locality_name?: StringFilter<"locality"> | string
    city_id?: IntFilter<"locality"> | number
    active?: IntFilter<"locality"> | number
  }, "locality_id">

  export type localityOrderByWithAggregationInput = {
    locality_id?: SortOrder
    locality_name?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
    _count?: localityCountOrderByAggregateInput
    _avg?: localityAvgOrderByAggregateInput
    _max?: localityMaxOrderByAggregateInput
    _min?: localityMinOrderByAggregateInput
    _sum?: localitySumOrderByAggregateInput
  }

  export type localityScalarWhereWithAggregatesInput = {
    AND?: localityScalarWhereWithAggregatesInput | localityScalarWhereWithAggregatesInput[]
    OR?: localityScalarWhereWithAggregatesInput[]
    NOT?: localityScalarWhereWithAggregatesInput | localityScalarWhereWithAggregatesInput[]
    locality_id?: IntWithAggregatesFilter<"locality"> | number
    locality_name?: StringWithAggregatesFilter<"locality"> | string
    city_id?: IntWithAggregatesFilter<"locality"> | number
    active?: IntWithAggregatesFilter<"locality"> | number
  }

  export type login_detailsWhereInput = {
    AND?: login_detailsWhereInput | login_detailsWhereInput[]
    OR?: login_detailsWhereInput[]
    NOT?: login_detailsWhereInput | login_detailsWhereInput[]
    login_id?: IntFilter<"login_details"> | number
    firstname?: StringFilter<"login_details"> | string
    physician_id?: IntNullableFilter<"login_details"> | number | null
    laboratory_id?: IntNullableFilter<"login_details"> | number | null
    patient_id?: IntNullableFilter<"login_details"> | number | null
    phy_admin_id?: IntNullableFilter<"login_details"> | number | null
    username?: StringFilter<"login_details"> | string
    password?: StringFilter<"login_details"> | string
    phone_num?: StringFilter<"login_details"> | string
    state?: IntFilter<"login_details"> | number
    city?: IntFilter<"login_details"> | number
    count?: IntFilter<"login_details"> | number
    role_id?: IntFilter<"login_details"> | number
    active?: IntFilter<"login_details"> | number
    last_login?: DateTimeNullableFilter<"login_details"> | Date | string | null
    created_on?: DateTimeFilter<"login_details"> | Date | string
    updated_on?: DateTimeFilter<"login_details"> | Date | string
    otp?: IntFilter<"login_details"> | number
    device_id?: StringFilter<"login_details"> | string
    player_id?: StringFilter<"login_details"> | string
  }

  export type login_detailsOrderByWithRelationInput = {
    login_id?: SortOrder
    firstname?: SortOrder
    physician_id?: SortOrderInput | SortOrder
    laboratory_id?: SortOrderInput | SortOrder
    patient_id?: SortOrderInput | SortOrder
    phy_admin_id?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    phone_num?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    last_login?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    otp?: SortOrder
    device_id?: SortOrder
    player_id?: SortOrder
  }

  export type login_detailsWhereUniqueInput = Prisma.AtLeast<{
    login_id?: number
    phone_num?: string
    AND?: login_detailsWhereInput | login_detailsWhereInput[]
    OR?: login_detailsWhereInput[]
    NOT?: login_detailsWhereInput | login_detailsWhereInput[]
    firstname?: StringFilter<"login_details"> | string
    physician_id?: IntNullableFilter<"login_details"> | number | null
    laboratory_id?: IntNullableFilter<"login_details"> | number | null
    patient_id?: IntNullableFilter<"login_details"> | number | null
    phy_admin_id?: IntNullableFilter<"login_details"> | number | null
    username?: StringFilter<"login_details"> | string
    password?: StringFilter<"login_details"> | string
    state?: IntFilter<"login_details"> | number
    city?: IntFilter<"login_details"> | number
    count?: IntFilter<"login_details"> | number
    role_id?: IntFilter<"login_details"> | number
    active?: IntFilter<"login_details"> | number
    last_login?: DateTimeNullableFilter<"login_details"> | Date | string | null
    created_on?: DateTimeFilter<"login_details"> | Date | string
    updated_on?: DateTimeFilter<"login_details"> | Date | string
    otp?: IntFilter<"login_details"> | number
    device_id?: StringFilter<"login_details"> | string
    player_id?: StringFilter<"login_details"> | string
  }, "phone_num" | "login_id">

  export type login_detailsOrderByWithAggregationInput = {
    login_id?: SortOrder
    firstname?: SortOrder
    physician_id?: SortOrderInput | SortOrder
    laboratory_id?: SortOrderInput | SortOrder
    patient_id?: SortOrderInput | SortOrder
    phy_admin_id?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    phone_num?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    last_login?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    otp?: SortOrder
    device_id?: SortOrder
    player_id?: SortOrder
    _count?: login_detailsCountOrderByAggregateInput
    _avg?: login_detailsAvgOrderByAggregateInput
    _max?: login_detailsMaxOrderByAggregateInput
    _min?: login_detailsMinOrderByAggregateInput
    _sum?: login_detailsSumOrderByAggregateInput
  }

  export type login_detailsScalarWhereWithAggregatesInput = {
    AND?: login_detailsScalarWhereWithAggregatesInput | login_detailsScalarWhereWithAggregatesInput[]
    OR?: login_detailsScalarWhereWithAggregatesInput[]
    NOT?: login_detailsScalarWhereWithAggregatesInput | login_detailsScalarWhereWithAggregatesInput[]
    login_id?: IntWithAggregatesFilter<"login_details"> | number
    firstname?: StringWithAggregatesFilter<"login_details"> | string
    physician_id?: IntNullableWithAggregatesFilter<"login_details"> | number | null
    laboratory_id?: IntNullableWithAggregatesFilter<"login_details"> | number | null
    patient_id?: IntNullableWithAggregatesFilter<"login_details"> | number | null
    phy_admin_id?: IntNullableWithAggregatesFilter<"login_details"> | number | null
    username?: StringWithAggregatesFilter<"login_details"> | string
    password?: StringWithAggregatesFilter<"login_details"> | string
    phone_num?: StringWithAggregatesFilter<"login_details"> | string
    state?: IntWithAggregatesFilter<"login_details"> | number
    city?: IntWithAggregatesFilter<"login_details"> | number
    count?: IntWithAggregatesFilter<"login_details"> | number
    role_id?: IntWithAggregatesFilter<"login_details"> | number
    active?: IntWithAggregatesFilter<"login_details"> | number
    last_login?: DateTimeNullableWithAggregatesFilter<"login_details"> | Date | string | null
    created_on?: DateTimeWithAggregatesFilter<"login_details"> | Date | string
    updated_on?: DateTimeWithAggregatesFilter<"login_details"> | Date | string
    otp?: IntWithAggregatesFilter<"login_details"> | number
    device_id?: StringWithAggregatesFilter<"login_details"> | string
    player_id?: StringWithAggregatesFilter<"login_details"> | string
  }

  export type medicineWhereInput = {
    AND?: medicineWhereInput | medicineWhereInput[]
    OR?: medicineWhereInput[]
    NOT?: medicineWhereInput | medicineWhereInput[]
    ID?: IntFilter<"medicine"> | number
    medicine_name?: StringFilter<"medicine"> | string
    active?: IntFilter<"medicine"> | number
  }

  export type medicineOrderByWithRelationInput = {
    ID?: SortOrder
    medicine_name?: SortOrder
    active?: SortOrder
  }

  export type medicineWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: medicineWhereInput | medicineWhereInput[]
    OR?: medicineWhereInput[]
    NOT?: medicineWhereInput | medicineWhereInput[]
    medicine_name?: StringFilter<"medicine"> | string
    active?: IntFilter<"medicine"> | number
  }, "ID">

  export type medicineOrderByWithAggregationInput = {
    ID?: SortOrder
    medicine_name?: SortOrder
    active?: SortOrder
    _count?: medicineCountOrderByAggregateInput
    _avg?: medicineAvgOrderByAggregateInput
    _max?: medicineMaxOrderByAggregateInput
    _min?: medicineMinOrderByAggregateInput
    _sum?: medicineSumOrderByAggregateInput
  }

  export type medicineScalarWhereWithAggregatesInput = {
    AND?: medicineScalarWhereWithAggregatesInput | medicineScalarWhereWithAggregatesInput[]
    OR?: medicineScalarWhereWithAggregatesInput[]
    NOT?: medicineScalarWhereWithAggregatesInput | medicineScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"medicine"> | number
    medicine_name?: StringWithAggregatesFilter<"medicine"> | string
    active?: IntWithAggregatesFilter<"medicine"> | number
  }

  export type notification_keysWhereInput = {
    AND?: notification_keysWhereInput | notification_keysWhereInput[]
    OR?: notification_keysWhereInput[]
    NOT?: notification_keysWhereInput | notification_keysWhereInput[]
    notification_keys_id?: IntFilter<"notification_keys"> | number
    app_id?: StringFilter<"notification_keys"> | string
    rest_api_key?: StringFilter<"notification_keys"> | string
  }

  export type notification_keysOrderByWithRelationInput = {
    notification_keys_id?: SortOrder
    app_id?: SortOrder
    rest_api_key?: SortOrder
  }

  export type notification_keysWhereUniqueInput = Prisma.AtLeast<{
    notification_keys_id?: number
    AND?: notification_keysWhereInput | notification_keysWhereInput[]
    OR?: notification_keysWhereInput[]
    NOT?: notification_keysWhereInput | notification_keysWhereInput[]
    app_id?: StringFilter<"notification_keys"> | string
    rest_api_key?: StringFilter<"notification_keys"> | string
  }, "notification_keys_id">

  export type notification_keysOrderByWithAggregationInput = {
    notification_keys_id?: SortOrder
    app_id?: SortOrder
    rest_api_key?: SortOrder
    _count?: notification_keysCountOrderByAggregateInput
    _avg?: notification_keysAvgOrderByAggregateInput
    _max?: notification_keysMaxOrderByAggregateInput
    _min?: notification_keysMinOrderByAggregateInput
    _sum?: notification_keysSumOrderByAggregateInput
  }

  export type notification_keysScalarWhereWithAggregatesInput = {
    AND?: notification_keysScalarWhereWithAggregatesInput | notification_keysScalarWhereWithAggregatesInput[]
    OR?: notification_keysScalarWhereWithAggregatesInput[]
    NOT?: notification_keysScalarWhereWithAggregatesInput | notification_keysScalarWhereWithAggregatesInput[]
    notification_keys_id?: IntWithAggregatesFilter<"notification_keys"> | number
    app_id?: StringWithAggregatesFilter<"notification_keys"> | string
    rest_api_key?: StringWithAggregatesFilter<"notification_keys"> | string
  }

  export type notificationattemptWhereInput = {
    AND?: notificationattemptWhereInput | notificationattemptWhereInput[]
    OR?: notificationattemptWhereInput[]
    NOT?: notificationattemptWhereInput | notificationattemptWhereInput[]
    notificationattempt_id?: IntFilter<"notificationattempt"> | number
    login_id?: IntFilter<"notificationattempt"> | number
    notification_heading?: StringFilter<"notificationattempt"> | string
    notification_message?: StringFilter<"notificationattempt"> | string
    notification_type?: StringFilter<"notificationattempt"> | string
    CreatedDateTime?: DateTimeFilter<"notificationattempt"> | Date | string
    notification_medium?: IntFilter<"notificationattempt"> | number
    SendDateTime?: DateTimeFilter<"notificationattempt"> | Date | string
    status?: IntFilter<"notificationattempt"> | number
  }

  export type notificationattemptOrderByWithRelationInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_heading?: SortOrder
    notification_message?: SortOrder
    notification_type?: SortOrder
    CreatedDateTime?: SortOrder
    notification_medium?: SortOrder
    SendDateTime?: SortOrder
    status?: SortOrder
  }

  export type notificationattemptWhereUniqueInput = Prisma.AtLeast<{
    notificationattempt_id?: number
    AND?: notificationattemptWhereInput | notificationattemptWhereInput[]
    OR?: notificationattemptWhereInput[]
    NOT?: notificationattemptWhereInput | notificationattemptWhereInput[]
    login_id?: IntFilter<"notificationattempt"> | number
    notification_heading?: StringFilter<"notificationattempt"> | string
    notification_message?: StringFilter<"notificationattempt"> | string
    notification_type?: StringFilter<"notificationattempt"> | string
    CreatedDateTime?: DateTimeFilter<"notificationattempt"> | Date | string
    notification_medium?: IntFilter<"notificationattempt"> | number
    SendDateTime?: DateTimeFilter<"notificationattempt"> | Date | string
    status?: IntFilter<"notificationattempt"> | number
  }, "notificationattempt_id">

  export type notificationattemptOrderByWithAggregationInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_heading?: SortOrder
    notification_message?: SortOrder
    notification_type?: SortOrder
    CreatedDateTime?: SortOrder
    notification_medium?: SortOrder
    SendDateTime?: SortOrder
    status?: SortOrder
    _count?: notificationattemptCountOrderByAggregateInput
    _avg?: notificationattemptAvgOrderByAggregateInput
    _max?: notificationattemptMaxOrderByAggregateInput
    _min?: notificationattemptMinOrderByAggregateInput
    _sum?: notificationattemptSumOrderByAggregateInput
  }

  export type notificationattemptScalarWhereWithAggregatesInput = {
    AND?: notificationattemptScalarWhereWithAggregatesInput | notificationattemptScalarWhereWithAggregatesInput[]
    OR?: notificationattemptScalarWhereWithAggregatesInput[]
    NOT?: notificationattemptScalarWhereWithAggregatesInput | notificationattemptScalarWhereWithAggregatesInput[]
    notificationattempt_id?: IntWithAggregatesFilter<"notificationattempt"> | number
    login_id?: IntWithAggregatesFilter<"notificationattempt"> | number
    notification_heading?: StringWithAggregatesFilter<"notificationattempt"> | string
    notification_message?: StringWithAggregatesFilter<"notificationattempt"> | string
    notification_type?: StringWithAggregatesFilter<"notificationattempt"> | string
    CreatedDateTime?: DateTimeWithAggregatesFilter<"notificationattempt"> | Date | string
    notification_medium?: IntWithAggregatesFilter<"notificationattempt"> | number
    SendDateTime?: DateTimeWithAggregatesFilter<"notificationattempt"> | Date | string
    status?: IntWithAggregatesFilter<"notificationattempt"> | number
  }

  export type RenamedpackageWhereInput = {
    AND?: RenamedpackageWhereInput | RenamedpackageWhereInput[]
    OR?: RenamedpackageWhereInput[]
    NOT?: RenamedpackageWhereInput | RenamedpackageWhereInput[]
    id?: IntFilter<"Renamedpackage"> | number
    package_name?: StringFilter<"Renamedpackage"> | string
    created_on?: StringNullableFilter<"Renamedpackage"> | string | null
    created_by?: StringNullableFilter<"Renamedpackage"> | string | null
  }

  export type RenamedpackageOrderByWithRelationInput = {
    id?: SortOrder
    package_name?: SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type RenamedpackageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RenamedpackageWhereInput | RenamedpackageWhereInput[]
    OR?: RenamedpackageWhereInput[]
    NOT?: RenamedpackageWhereInput | RenamedpackageWhereInput[]
    package_name?: StringFilter<"Renamedpackage"> | string
    created_on?: StringNullableFilter<"Renamedpackage"> | string | null
    created_by?: StringNullableFilter<"Renamedpackage"> | string | null
  }, "id">

  export type RenamedpackageOrderByWithAggregationInput = {
    id?: SortOrder
    package_name?: SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: RenamedpackageCountOrderByAggregateInput
    _avg?: RenamedpackageAvgOrderByAggregateInput
    _max?: RenamedpackageMaxOrderByAggregateInput
    _min?: RenamedpackageMinOrderByAggregateInput
    _sum?: RenamedpackageSumOrderByAggregateInput
  }

  export type RenamedpackageScalarWhereWithAggregatesInput = {
    AND?: RenamedpackageScalarWhereWithAggregatesInput | RenamedpackageScalarWhereWithAggregatesInput[]
    OR?: RenamedpackageScalarWhereWithAggregatesInput[]
    NOT?: RenamedpackageScalarWhereWithAggregatesInput | RenamedpackageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Renamedpackage"> | number
    package_name?: StringWithAggregatesFilter<"Renamedpackage"> | string
    created_on?: StringNullableWithAggregatesFilter<"Renamedpackage"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"Renamedpackage"> | string | null
  }

  export type package_containsWhereInput = {
    AND?: package_containsWhereInput | package_containsWhereInput[]
    OR?: package_containsWhereInput[]
    NOT?: package_containsWhereInput | package_containsWhereInput[]
    id?: IntFilter<"package_contains"> | number
    package_id?: StringFilter<"package_contains"> | string
    test_id?: StringFilter<"package_contains"> | string
    created_on?: StringNullableFilter<"package_contains"> | string | null
    is_active?: IntFilter<"package_contains"> | number
  }

  export type package_containsOrderByWithRelationInput = {
    id?: SortOrder
    package_id?: SortOrder
    test_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    is_active?: SortOrder
  }

  export type package_containsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: package_containsWhereInput | package_containsWhereInput[]
    OR?: package_containsWhereInput[]
    NOT?: package_containsWhereInput | package_containsWhereInput[]
    package_id?: StringFilter<"package_contains"> | string
    test_id?: StringFilter<"package_contains"> | string
    created_on?: StringNullableFilter<"package_contains"> | string | null
    is_active?: IntFilter<"package_contains"> | number
  }, "id">

  export type package_containsOrderByWithAggregationInput = {
    id?: SortOrder
    package_id?: SortOrder
    test_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    is_active?: SortOrder
    _count?: package_containsCountOrderByAggregateInput
    _avg?: package_containsAvgOrderByAggregateInput
    _max?: package_containsMaxOrderByAggregateInput
    _min?: package_containsMinOrderByAggregateInput
    _sum?: package_containsSumOrderByAggregateInput
  }

  export type package_containsScalarWhereWithAggregatesInput = {
    AND?: package_containsScalarWhereWithAggregatesInput | package_containsScalarWhereWithAggregatesInput[]
    OR?: package_containsScalarWhereWithAggregatesInput[]
    NOT?: package_containsScalarWhereWithAggregatesInput | package_containsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"package_contains"> | number
    package_id?: StringWithAggregatesFilter<"package_contains"> | string
    test_id?: StringWithAggregatesFilter<"package_contains"> | string
    created_on?: StringNullableWithAggregatesFilter<"package_contains"> | string | null
    is_active?: IntWithAggregatesFilter<"package_contains"> | number
  }

  export type package_labsWhereInput = {
    AND?: package_labsWhereInput | package_labsWhereInput[]
    OR?: package_labsWhereInput[]
    NOT?: package_labsWhereInput | package_labsWhereInput[]
    id?: IntFilter<"package_labs"> | number
    package_id?: StringFilter<"package_labs"> | string
    lab_id?: StringFilter<"package_labs"> | string
    package_price?: StringFilter<"package_labs"> | string
    created_on?: StringNullableFilter<"package_labs"> | string | null
    created_by?: StringNullableFilter<"package_labs"> | string | null
  }

  export type package_labsOrderByWithRelationInput = {
    id?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    package_price?: SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type package_labsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: package_labsWhereInput | package_labsWhereInput[]
    OR?: package_labsWhereInput[]
    NOT?: package_labsWhereInput | package_labsWhereInput[]
    package_id?: StringFilter<"package_labs"> | string
    lab_id?: StringFilter<"package_labs"> | string
    package_price?: StringFilter<"package_labs"> | string
    created_on?: StringNullableFilter<"package_labs"> | string | null
    created_by?: StringNullableFilter<"package_labs"> | string | null
  }, "id">

  export type package_labsOrderByWithAggregationInput = {
    id?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    package_price?: SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: package_labsCountOrderByAggregateInput
    _avg?: package_labsAvgOrderByAggregateInput
    _max?: package_labsMaxOrderByAggregateInput
    _min?: package_labsMinOrderByAggregateInput
    _sum?: package_labsSumOrderByAggregateInput
  }

  export type package_labsScalarWhereWithAggregatesInput = {
    AND?: package_labsScalarWhereWithAggregatesInput | package_labsScalarWhereWithAggregatesInput[]
    OR?: package_labsScalarWhereWithAggregatesInput[]
    NOT?: package_labsScalarWhereWithAggregatesInput | package_labsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"package_labs"> | number
    package_id?: StringWithAggregatesFilter<"package_labs"> | string
    lab_id?: StringWithAggregatesFilter<"package_labs"> | string
    package_price?: StringWithAggregatesFilter<"package_labs"> | string
    created_on?: StringNullableWithAggregatesFilter<"package_labs"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"package_labs"> | string | null
  }

  export type package_queueWhereInput = {
    AND?: package_queueWhereInput | package_queueWhereInput[]
    OR?: package_queueWhereInput[]
    NOT?: package_queueWhereInput | package_queueWhereInput[]
    id?: BigIntFilter<"package_queue"> | bigint | number
    medical_num?: StringNullableFilter<"package_queue"> | string | null
    package_id?: StringNullableFilter<"package_queue"> | string | null
    lab_id?: StringNullableFilter<"package_queue"> | string | null
    patient_id?: StringNullableFilter<"package_queue"> | string | null
    dependent_id?: StringFilter<"package_queue"> | string
    doctor_id?: StringNullableFilter<"package_queue"> | string | null
    referdate?: StringNullableFilter<"package_queue"> | string | null
    created_by?: StringNullableFilter<"package_queue"> | string | null
    created_on?: StringNullableFilter<"package_queue"> | string | null
    package_status?: StringNullableFilter<"package_queue"> | string | null
  }

  export type package_queueOrderByWithRelationInput = {
    id?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    package_id?: SortOrderInput | SortOrder
    lab_id?: SortOrderInput | SortOrder
    patient_id?: SortOrderInput | SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrderInput | SortOrder
    referdate?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    package_status?: SortOrderInput | SortOrder
  }

  export type package_queueWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: package_queueWhereInput | package_queueWhereInput[]
    OR?: package_queueWhereInput[]
    NOT?: package_queueWhereInput | package_queueWhereInput[]
    medical_num?: StringNullableFilter<"package_queue"> | string | null
    package_id?: StringNullableFilter<"package_queue"> | string | null
    lab_id?: StringNullableFilter<"package_queue"> | string | null
    patient_id?: StringNullableFilter<"package_queue"> | string | null
    dependent_id?: StringFilter<"package_queue"> | string
    doctor_id?: StringNullableFilter<"package_queue"> | string | null
    referdate?: StringNullableFilter<"package_queue"> | string | null
    created_by?: StringNullableFilter<"package_queue"> | string | null
    created_on?: StringNullableFilter<"package_queue"> | string | null
    package_status?: StringNullableFilter<"package_queue"> | string | null
  }, "id">

  export type package_queueOrderByWithAggregationInput = {
    id?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    package_id?: SortOrderInput | SortOrder
    lab_id?: SortOrderInput | SortOrder
    patient_id?: SortOrderInput | SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrderInput | SortOrder
    referdate?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    package_status?: SortOrderInput | SortOrder
    _count?: package_queueCountOrderByAggregateInput
    _avg?: package_queueAvgOrderByAggregateInput
    _max?: package_queueMaxOrderByAggregateInput
    _min?: package_queueMinOrderByAggregateInput
    _sum?: package_queueSumOrderByAggregateInput
  }

  export type package_queueScalarWhereWithAggregatesInput = {
    AND?: package_queueScalarWhereWithAggregatesInput | package_queueScalarWhereWithAggregatesInput[]
    OR?: package_queueScalarWhereWithAggregatesInput[]
    NOT?: package_queueScalarWhereWithAggregatesInput | package_queueScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"package_queue"> | bigint | number
    medical_num?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    package_id?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    lab_id?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    patient_id?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    dependent_id?: StringWithAggregatesFilter<"package_queue"> | string
    doctor_id?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    referdate?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    created_on?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
    package_status?: StringNullableWithAggregatesFilter<"package_queue"> | string | null
  }

  export type patient_dep_detailsWhereInput = {
    AND?: patient_dep_detailsWhereInput | patient_dep_detailsWhereInput[]
    OR?: patient_dep_detailsWhereInput[]
    NOT?: patient_dep_detailsWhereInput | patient_dep_detailsWhereInput[]
    patient_dep_id?: IntFilter<"patient_dep_details"> | number
    firstname?: StringNullableFilter<"patient_dep_details"> | string | null
    lastname?: StringFilter<"patient_dep_details"> | string
    gender?: StringNullableFilter<"patient_dep_details"> | string | null
    date_of_birth?: DateTimeFilter<"patient_dep_details"> | Date | string
    age?: StringNullableFilter<"patient_dep_details"> | string | null
    address?: StringNullableFilter<"patient_dep_details"> | string | null
    city?: StringNullableFilter<"patient_dep_details"> | string | null
    pincode?: StringFilter<"patient_dep_details"> | string
    mailid?: StringNullableFilter<"patient_dep_details"> | string | null
    phonenum?: StringNullableFilter<"patient_dep_details"> | string | null
    alt_phonenum?: StringFilter<"patient_dep_details"> | string
    relationship?: StringFilter<"patient_dep_details"> | string
    main_pat_id?: IntFilter<"patient_dep_details"> | number
    created_on?: DateTimeNullableFilter<"patient_dep_details"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"patient_dep_details"> | Date | string | null
    active?: IntNullableFilter<"patient_dep_details"> | number | null
    role_id?: IntFilter<"patient_dep_details"> | number
    patient_unique_id?: StringFilter<"patient_dep_details"> | string
    physician_id?: StringFilter<"patient_dep_details"> | string
    status?: StringFilter<"patient_dep_details"> | string
    r_count?: IntFilter<"patient_dep_details"> | number
    count?: IntFilter<"patient_dep_details"> | number
    prescribe_receipt?: IntFilter<"patient_dep_details"> | number
  }

  export type patient_dep_detailsOrderByWithRelationInput = {
    patient_dep_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrder
    age?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    pincode?: SortOrder
    mailid?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    alt_phonenum?: SortOrder
    relationship?: SortOrder
    main_pat_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_dep_detailsWhereUniqueInput = Prisma.AtLeast<{
    patient_dep_id?: number
    AND?: patient_dep_detailsWhereInput | patient_dep_detailsWhereInput[]
    OR?: patient_dep_detailsWhereInput[]
    NOT?: patient_dep_detailsWhereInput | patient_dep_detailsWhereInput[]
    firstname?: StringNullableFilter<"patient_dep_details"> | string | null
    lastname?: StringFilter<"patient_dep_details"> | string
    gender?: StringNullableFilter<"patient_dep_details"> | string | null
    date_of_birth?: DateTimeFilter<"patient_dep_details"> | Date | string
    age?: StringNullableFilter<"patient_dep_details"> | string | null
    address?: StringNullableFilter<"patient_dep_details"> | string | null
    city?: StringNullableFilter<"patient_dep_details"> | string | null
    pincode?: StringFilter<"patient_dep_details"> | string
    mailid?: StringNullableFilter<"patient_dep_details"> | string | null
    phonenum?: StringNullableFilter<"patient_dep_details"> | string | null
    alt_phonenum?: StringFilter<"patient_dep_details"> | string
    relationship?: StringFilter<"patient_dep_details"> | string
    main_pat_id?: IntFilter<"patient_dep_details"> | number
    created_on?: DateTimeNullableFilter<"patient_dep_details"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"patient_dep_details"> | Date | string | null
    active?: IntNullableFilter<"patient_dep_details"> | number | null
    role_id?: IntFilter<"patient_dep_details"> | number
    patient_unique_id?: StringFilter<"patient_dep_details"> | string
    physician_id?: StringFilter<"patient_dep_details"> | string
    status?: StringFilter<"patient_dep_details"> | string
    r_count?: IntFilter<"patient_dep_details"> | number
    count?: IntFilter<"patient_dep_details"> | number
    prescribe_receipt?: IntFilter<"patient_dep_details"> | number
  }, "patient_dep_id">

  export type patient_dep_detailsOrderByWithAggregationInput = {
    patient_dep_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrder
    age?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    pincode?: SortOrder
    mailid?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    alt_phonenum?: SortOrder
    relationship?: SortOrder
    main_pat_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
    _count?: patient_dep_detailsCountOrderByAggregateInput
    _avg?: patient_dep_detailsAvgOrderByAggregateInput
    _max?: patient_dep_detailsMaxOrderByAggregateInput
    _min?: patient_dep_detailsMinOrderByAggregateInput
    _sum?: patient_dep_detailsSumOrderByAggregateInput
  }

  export type patient_dep_detailsScalarWhereWithAggregatesInput = {
    AND?: patient_dep_detailsScalarWhereWithAggregatesInput | patient_dep_detailsScalarWhereWithAggregatesInput[]
    OR?: patient_dep_detailsScalarWhereWithAggregatesInput[]
    NOT?: patient_dep_detailsScalarWhereWithAggregatesInput | patient_dep_detailsScalarWhereWithAggregatesInput[]
    patient_dep_id?: IntWithAggregatesFilter<"patient_dep_details"> | number
    firstname?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    lastname?: StringWithAggregatesFilter<"patient_dep_details"> | string
    gender?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    date_of_birth?: DateTimeWithAggregatesFilter<"patient_dep_details"> | Date | string
    age?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    address?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    city?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    pincode?: StringWithAggregatesFilter<"patient_dep_details"> | string
    mailid?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    phonenum?: StringNullableWithAggregatesFilter<"patient_dep_details"> | string | null
    alt_phonenum?: StringWithAggregatesFilter<"patient_dep_details"> | string
    relationship?: StringWithAggregatesFilter<"patient_dep_details"> | string
    main_pat_id?: IntWithAggregatesFilter<"patient_dep_details"> | number
    created_on?: DateTimeNullableWithAggregatesFilter<"patient_dep_details"> | Date | string | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"patient_dep_details"> | Date | string | null
    active?: IntNullableWithAggregatesFilter<"patient_dep_details"> | number | null
    role_id?: IntWithAggregatesFilter<"patient_dep_details"> | number
    patient_unique_id?: StringWithAggregatesFilter<"patient_dep_details"> | string
    physician_id?: StringWithAggregatesFilter<"patient_dep_details"> | string
    status?: StringWithAggregatesFilter<"patient_dep_details"> | string
    r_count?: IntWithAggregatesFilter<"patient_dep_details"> | number
    count?: IntWithAggregatesFilter<"patient_dep_details"> | number
    prescribe_receipt?: IntWithAggregatesFilter<"patient_dep_details"> | number
  }

  export type patient_doctor_mappingWhereInput = {
    AND?: patient_doctor_mappingWhereInput | patient_doctor_mappingWhereInput[]
    OR?: patient_doctor_mappingWhereInput[]
    NOT?: patient_doctor_mappingWhereInput | patient_doctor_mappingWhereInput[]
    patient_doctor_mapping_id?: IntFilter<"patient_doctor_mapping"> | number
    referral_patient_id?: IntFilter<"patient_doctor_mapping"> | number
    prev_physician_id?: IntFilter<"patient_doctor_mapping"> | number
    new_physician_id?: IntFilter<"patient_doctor_mapping"> | number
    patient_unique_id?: StringFilter<"patient_doctor_mapping"> | string
    added_date?: DateTimeFilter<"patient_doctor_mapping"> | Date | string
  }

  export type patient_doctor_mappingOrderByWithRelationInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
    patient_unique_id?: SortOrder
    added_date?: SortOrder
  }

  export type patient_doctor_mappingWhereUniqueInput = Prisma.AtLeast<{
    patient_doctor_mapping_id?: number
    AND?: patient_doctor_mappingWhereInput | patient_doctor_mappingWhereInput[]
    OR?: patient_doctor_mappingWhereInput[]
    NOT?: patient_doctor_mappingWhereInput | patient_doctor_mappingWhereInput[]
    referral_patient_id?: IntFilter<"patient_doctor_mapping"> | number
    prev_physician_id?: IntFilter<"patient_doctor_mapping"> | number
    new_physician_id?: IntFilter<"patient_doctor_mapping"> | number
    patient_unique_id?: StringFilter<"patient_doctor_mapping"> | string
    added_date?: DateTimeFilter<"patient_doctor_mapping"> | Date | string
  }, "patient_doctor_mapping_id">

  export type patient_doctor_mappingOrderByWithAggregationInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
    patient_unique_id?: SortOrder
    added_date?: SortOrder
    _count?: patient_doctor_mappingCountOrderByAggregateInput
    _avg?: patient_doctor_mappingAvgOrderByAggregateInput
    _max?: patient_doctor_mappingMaxOrderByAggregateInput
    _min?: patient_doctor_mappingMinOrderByAggregateInput
    _sum?: patient_doctor_mappingSumOrderByAggregateInput
  }

  export type patient_doctor_mappingScalarWhereWithAggregatesInput = {
    AND?: patient_doctor_mappingScalarWhereWithAggregatesInput | patient_doctor_mappingScalarWhereWithAggregatesInput[]
    OR?: patient_doctor_mappingScalarWhereWithAggregatesInput[]
    NOT?: patient_doctor_mappingScalarWhereWithAggregatesInput | patient_doctor_mappingScalarWhereWithAggregatesInput[]
    patient_doctor_mapping_id?: IntWithAggregatesFilter<"patient_doctor_mapping"> | number
    referral_patient_id?: IntWithAggregatesFilter<"patient_doctor_mapping"> | number
    prev_physician_id?: IntWithAggregatesFilter<"patient_doctor_mapping"> | number
    new_physician_id?: IntWithAggregatesFilter<"patient_doctor_mapping"> | number
    patient_unique_id?: StringWithAggregatesFilter<"patient_doctor_mapping"> | string
    added_date?: DateTimeWithAggregatesFilter<"patient_doctor_mapping"> | Date | string
  }

  export type patient_parameterWhereInput = {
    AND?: patient_parameterWhereInput | patient_parameterWhereInput[]
    OR?: patient_parameterWhereInput[]
    NOT?: patient_parameterWhereInput | patient_parameterWhereInput[]
    parameter_id?: IntFilter<"patient_parameter"> | number
    date_of_birth?: DateTimeFilter<"patient_parameter"> | Date | string
    known_allergies?: StringFilter<"patient_parameter"> | string
    previous_medical_history?: StringFilter<"patient_parameter"> | string
    blood_group?: IntNullableFilter<"patient_parameter"> | number | null
    diabetic?: StringNullableFilter<"patient_parameter"> | string | null
    hypertension?: StringNullableFilter<"patient_parameter"> | string | null
    referral_patient_id?: IntFilter<"patient_parameter"> | number
    dependent_id?: IntFilter<"patient_parameter"> | number
    created_on?: StringNullableFilter<"patient_parameter"> | string | null
  }

  export type patient_parameterOrderByWithRelationInput = {
    parameter_id?: SortOrder
    date_of_birth?: SortOrder
    known_allergies?: SortOrder
    previous_medical_history?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    diabetic?: SortOrderInput | SortOrder
    hypertension?: SortOrderInput | SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
  }

  export type patient_parameterWhereUniqueInput = Prisma.AtLeast<{
    parameter_id?: number
    AND?: patient_parameterWhereInput | patient_parameterWhereInput[]
    OR?: patient_parameterWhereInput[]
    NOT?: patient_parameterWhereInput | patient_parameterWhereInput[]
    date_of_birth?: DateTimeFilter<"patient_parameter"> | Date | string
    known_allergies?: StringFilter<"patient_parameter"> | string
    previous_medical_history?: StringFilter<"patient_parameter"> | string
    blood_group?: IntNullableFilter<"patient_parameter"> | number | null
    diabetic?: StringNullableFilter<"patient_parameter"> | string | null
    hypertension?: StringNullableFilter<"patient_parameter"> | string | null
    referral_patient_id?: IntFilter<"patient_parameter"> | number
    dependent_id?: IntFilter<"patient_parameter"> | number
    created_on?: StringNullableFilter<"patient_parameter"> | string | null
  }, "parameter_id">

  export type patient_parameterOrderByWithAggregationInput = {
    parameter_id?: SortOrder
    date_of_birth?: SortOrder
    known_allergies?: SortOrder
    previous_medical_history?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    diabetic?: SortOrderInput | SortOrder
    hypertension?: SortOrderInput | SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrderInput | SortOrder
    _count?: patient_parameterCountOrderByAggregateInput
    _avg?: patient_parameterAvgOrderByAggregateInput
    _max?: patient_parameterMaxOrderByAggregateInput
    _min?: patient_parameterMinOrderByAggregateInput
    _sum?: patient_parameterSumOrderByAggregateInput
  }

  export type patient_parameterScalarWhereWithAggregatesInput = {
    AND?: patient_parameterScalarWhereWithAggregatesInput | patient_parameterScalarWhereWithAggregatesInput[]
    OR?: patient_parameterScalarWhereWithAggregatesInput[]
    NOT?: patient_parameterScalarWhereWithAggregatesInput | patient_parameterScalarWhereWithAggregatesInput[]
    parameter_id?: IntWithAggregatesFilter<"patient_parameter"> | number
    date_of_birth?: DateTimeWithAggregatesFilter<"patient_parameter"> | Date | string
    known_allergies?: StringWithAggregatesFilter<"patient_parameter"> | string
    previous_medical_history?: StringWithAggregatesFilter<"patient_parameter"> | string
    blood_group?: IntNullableWithAggregatesFilter<"patient_parameter"> | number | null
    diabetic?: StringNullableWithAggregatesFilter<"patient_parameter"> | string | null
    hypertension?: StringNullableWithAggregatesFilter<"patient_parameter"> | string | null
    referral_patient_id?: IntWithAggregatesFilter<"patient_parameter"> | number
    dependent_id?: IntWithAggregatesFilter<"patient_parameter"> | number
    created_on?: StringNullableWithAggregatesFilter<"patient_parameter"> | string | null
  }

  export type patientqueueWhereInput = {
    AND?: patientqueueWhereInput | patientqueueWhereInput[]
    OR?: patientqueueWhereInput[]
    NOT?: patientqueueWhereInput | patientqueueWhereInput[]
    patientqueue_id?: IntFilter<"patientqueue"> | number
    BillId?: StringFilter<"patientqueue"> | string
    medical_num?: StringFilter<"patientqueue"> | string
    firstname?: StringFilter<"patientqueue"> | string
    mailid?: StringFilter<"patientqueue"> | string
    phonenum?: StringFilter<"patientqueue"> | string
    refer_date?: DateTimeFilter<"patientqueue"> | Date | string
    patient_unique_id?: StringFilter<"patientqueue"> | string
    physician_id?: IntNullableFilter<"patientqueue"> | number | null
    phyfname?: StringNullableFilter<"patientqueue"> | string | null
    referred_id?: IntFilter<"patientqueue"> | number
    ID?: IntFilter<"patientqueue"> | number
    billing_id?: IntFilter<"patientqueue"> | number
    laboratory_id?: IntFilter<"patientqueue"> | number
    ref_type?: StringFilter<"patientqueue"> | string
    lab_test_status?: IntFilter<"patientqueue"> | number
    billing_status?: IntFilter<"patientqueue"> | number
    is_sync?: IntFilter<"patientqueue"> | number
    created_on?: DateTimeFilter<"patientqueue"> | Date | string
  }

  export type patientqueueOrderByWithRelationInput = {
    patientqueue_id?: SortOrder
    BillId?: SortOrder
    medical_num?: SortOrder
    firstname?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    refer_date?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrderInput | SortOrder
    phyfname?: SortOrderInput | SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
    created_on?: SortOrder
  }

  export type patientqueueWhereUniqueInput = Prisma.AtLeast<{
    patientqueue_id?: number
    AND?: patientqueueWhereInput | patientqueueWhereInput[]
    OR?: patientqueueWhereInput[]
    NOT?: patientqueueWhereInput | patientqueueWhereInput[]
    BillId?: StringFilter<"patientqueue"> | string
    medical_num?: StringFilter<"patientqueue"> | string
    firstname?: StringFilter<"patientqueue"> | string
    mailid?: StringFilter<"patientqueue"> | string
    phonenum?: StringFilter<"patientqueue"> | string
    refer_date?: DateTimeFilter<"patientqueue"> | Date | string
    patient_unique_id?: StringFilter<"patientqueue"> | string
    physician_id?: IntNullableFilter<"patientqueue"> | number | null
    phyfname?: StringNullableFilter<"patientqueue"> | string | null
    referred_id?: IntFilter<"patientqueue"> | number
    ID?: IntFilter<"patientqueue"> | number
    billing_id?: IntFilter<"patientqueue"> | number
    laboratory_id?: IntFilter<"patientqueue"> | number
    ref_type?: StringFilter<"patientqueue"> | string
    lab_test_status?: IntFilter<"patientqueue"> | number
    billing_status?: IntFilter<"patientqueue"> | number
    is_sync?: IntFilter<"patientqueue"> | number
    created_on?: DateTimeFilter<"patientqueue"> | Date | string
  }, "patientqueue_id">

  export type patientqueueOrderByWithAggregationInput = {
    patientqueue_id?: SortOrder
    BillId?: SortOrder
    medical_num?: SortOrder
    firstname?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    refer_date?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrderInput | SortOrder
    phyfname?: SortOrderInput | SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
    created_on?: SortOrder
    _count?: patientqueueCountOrderByAggregateInput
    _avg?: patientqueueAvgOrderByAggregateInput
    _max?: patientqueueMaxOrderByAggregateInput
    _min?: patientqueueMinOrderByAggregateInput
    _sum?: patientqueueSumOrderByAggregateInput
  }

  export type patientqueueScalarWhereWithAggregatesInput = {
    AND?: patientqueueScalarWhereWithAggregatesInput | patientqueueScalarWhereWithAggregatesInput[]
    OR?: patientqueueScalarWhereWithAggregatesInput[]
    NOT?: patientqueueScalarWhereWithAggregatesInput | patientqueueScalarWhereWithAggregatesInput[]
    patientqueue_id?: IntWithAggregatesFilter<"patientqueue"> | number
    BillId?: StringWithAggregatesFilter<"patientqueue"> | string
    medical_num?: StringWithAggregatesFilter<"patientqueue"> | string
    firstname?: StringWithAggregatesFilter<"patientqueue"> | string
    mailid?: StringWithAggregatesFilter<"patientqueue"> | string
    phonenum?: StringWithAggregatesFilter<"patientqueue"> | string
    refer_date?: DateTimeWithAggregatesFilter<"patientqueue"> | Date | string
    patient_unique_id?: StringWithAggregatesFilter<"patientqueue"> | string
    physician_id?: IntNullableWithAggregatesFilter<"patientqueue"> | number | null
    phyfname?: StringNullableWithAggregatesFilter<"patientqueue"> | string | null
    referred_id?: IntWithAggregatesFilter<"patientqueue"> | number
    ID?: IntWithAggregatesFilter<"patientqueue"> | number
    billing_id?: IntWithAggregatesFilter<"patientqueue"> | number
    laboratory_id?: IntWithAggregatesFilter<"patientqueue"> | number
    ref_type?: StringWithAggregatesFilter<"patientqueue"> | string
    lab_test_status?: IntWithAggregatesFilter<"patientqueue"> | number
    billing_status?: IntWithAggregatesFilter<"patientqueue"> | number
    is_sync?: IntWithAggregatesFilter<"patientqueue"> | number
    created_on?: DateTimeWithAggregatesFilter<"patientqueue"> | Date | string
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    ID?: IntFilter<"payment"> | number
    doctor_id?: IntFilter<"payment"> | number
    referral_patient_id?: IntFilter<"payment"> | number
    dependent_id?: IntFilter<"payment"> | number
    Receipt_id?: BigIntFilter<"payment"> | bigint | number
    prescription_num?: StringFilter<"payment"> | string
    reg_fee?: StringFilter<"payment"> | string
    con_price?: IntFilter<"payment"> | number
    med_price?: IntFilter<"payment"> | number
    inv_price?: IntFilter<"payment"> | number
    admin_price?: IntFilter<"payment"> | number
    total_price?: IntFilter<"payment"> | number
    mode?: StringFilter<"payment"> | string
    created_on?: DateTimeFilter<"payment"> | Date | string
    updated_on?: DateTimeFilter<"payment"> | Date | string
    submitted?: IntNullableFilter<"payment"> | number | null
  }

  export type paymentOrderByWithRelationInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    prescription_num?: SortOrder
    reg_fee?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    mode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    submitted?: SortOrderInput | SortOrder
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    doctor_id?: IntFilter<"payment"> | number
    referral_patient_id?: IntFilter<"payment"> | number
    dependent_id?: IntFilter<"payment"> | number
    Receipt_id?: BigIntFilter<"payment"> | bigint | number
    prescription_num?: StringFilter<"payment"> | string
    reg_fee?: StringFilter<"payment"> | string
    con_price?: IntFilter<"payment"> | number
    med_price?: IntFilter<"payment"> | number
    inv_price?: IntFilter<"payment"> | number
    admin_price?: IntFilter<"payment"> | number
    total_price?: IntFilter<"payment"> | number
    mode?: StringFilter<"payment"> | string
    created_on?: DateTimeFilter<"payment"> | Date | string
    updated_on?: DateTimeFilter<"payment"> | Date | string
    submitted?: IntNullableFilter<"payment"> | number | null
  }, "ID">

  export type paymentOrderByWithAggregationInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    prescription_num?: SortOrder
    reg_fee?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    mode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    submitted?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"payment"> | number
    doctor_id?: IntWithAggregatesFilter<"payment"> | number
    referral_patient_id?: IntWithAggregatesFilter<"payment"> | number
    dependent_id?: IntWithAggregatesFilter<"payment"> | number
    Receipt_id?: BigIntWithAggregatesFilter<"payment"> | bigint | number
    prescription_num?: StringWithAggregatesFilter<"payment"> | string
    reg_fee?: StringWithAggregatesFilter<"payment"> | string
    con_price?: IntWithAggregatesFilter<"payment"> | number
    med_price?: IntWithAggregatesFilter<"payment"> | number
    inv_price?: IntWithAggregatesFilter<"payment"> | number
    admin_price?: IntWithAggregatesFilter<"payment"> | number
    total_price?: IntWithAggregatesFilter<"payment"> | number
    mode?: StringWithAggregatesFilter<"payment"> | string
    created_on?: DateTimeWithAggregatesFilter<"payment"> | Date | string
    updated_on?: DateTimeWithAggregatesFilter<"payment"> | Date | string
    submitted?: IntNullableWithAggregatesFilter<"payment"> | number | null
  }

  export type phy_adminWhereInput = {
    AND?: phy_adminWhereInput | phy_adminWhereInput[]
    OR?: phy_adminWhereInput[]
    NOT?: phy_adminWhereInput | phy_adminWhereInput[]
    phy_admin_id?: IntFilter<"phy_admin"> | number
    phy_admin_name?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_phone?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_mail_id?: StringFilter<"phy_admin"> | string
    phy_admin_password?: StringNullableFilter<"phy_admin"> | string | null
    created_on?: DateTimeFilter<"phy_admin"> | Date | string
    updated_on?: DateTimeNullableFilter<"phy_admin"> | Date | string | null
    created_by?: StringNullableFilter<"phy_admin"> | string | null
    physician_id?: IntFilter<"phy_admin"> | number
    active?: IntFilter<"phy_admin"> | number
    is_visible?: IntFilter<"phy_admin"> | number
    role_id?: IntFilter<"phy_admin"> | number
    physician_appointment?: XOR<Physician_appointmentRelationFilter, physician_appointmentWhereInput>
  }

  export type phy_adminOrderByWithRelationInput = {
    phy_admin_id?: SortOrder
    phy_admin_name?: SortOrderInput | SortOrder
    phy_admin_phone?: SortOrderInput | SortOrder
    phy_admin_mail_id?: SortOrder
    phy_admin_password?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
    physician_appointment?: physician_appointmentOrderByWithRelationInput
  }

  export type phy_adminWhereUniqueInput = Prisma.AtLeast<{
    phy_admin_id?: number
    phy_admin_mail_id?: string
    AND?: phy_adminWhereInput | phy_adminWhereInput[]
    OR?: phy_adminWhereInput[]
    NOT?: phy_adminWhereInput | phy_adminWhereInput[]
    phy_admin_name?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_phone?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_password?: StringNullableFilter<"phy_admin"> | string | null
    created_on?: DateTimeFilter<"phy_admin"> | Date | string
    updated_on?: DateTimeNullableFilter<"phy_admin"> | Date | string | null
    created_by?: StringNullableFilter<"phy_admin"> | string | null
    physician_id?: IntFilter<"phy_admin"> | number
    active?: IntFilter<"phy_admin"> | number
    is_visible?: IntFilter<"phy_admin"> | number
    role_id?: IntFilter<"phy_admin"> | number
    physician_appointment?: XOR<Physician_appointmentRelationFilter, physician_appointmentWhereInput>
  }, "phy_admin_mail_id" | "phy_admin_id">

  export type phy_adminOrderByWithAggregationInput = {
    phy_admin_id?: SortOrder
    phy_admin_name?: SortOrderInput | SortOrder
    phy_admin_phone?: SortOrderInput | SortOrder
    phy_admin_mail_id?: SortOrder
    phy_admin_password?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
    _count?: phy_adminCountOrderByAggregateInput
    _avg?: phy_adminAvgOrderByAggregateInput
    _max?: phy_adminMaxOrderByAggregateInput
    _min?: phy_adminMinOrderByAggregateInput
    _sum?: phy_adminSumOrderByAggregateInput
  }

  export type phy_adminScalarWhereWithAggregatesInput = {
    AND?: phy_adminScalarWhereWithAggregatesInput | phy_adminScalarWhereWithAggregatesInput[]
    OR?: phy_adminScalarWhereWithAggregatesInput[]
    NOT?: phy_adminScalarWhereWithAggregatesInput | phy_adminScalarWhereWithAggregatesInput[]
    phy_admin_id?: IntWithAggregatesFilter<"phy_admin"> | number
    phy_admin_name?: StringNullableWithAggregatesFilter<"phy_admin"> | string | null
    phy_admin_phone?: StringNullableWithAggregatesFilter<"phy_admin"> | string | null
    phy_admin_mail_id?: StringWithAggregatesFilter<"phy_admin"> | string
    phy_admin_password?: StringNullableWithAggregatesFilter<"phy_admin"> | string | null
    created_on?: DateTimeWithAggregatesFilter<"phy_admin"> | Date | string
    updated_on?: DateTimeNullableWithAggregatesFilter<"phy_admin"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"phy_admin"> | string | null
    physician_id?: IntWithAggregatesFilter<"phy_admin"> | number
    active?: IntWithAggregatesFilter<"phy_admin"> | number
    is_visible?: IntWithAggregatesFilter<"phy_admin"> | number
    role_id?: IntWithAggregatesFilter<"phy_admin"> | number
  }

  export type physician_appointmentWhereInput = {
    AND?: physician_appointmentWhereInput | physician_appointmentWhereInput[]
    OR?: physician_appointmentWhereInput[]
    NOT?: physician_appointmentWhereInput | physician_appointmentWhereInput[]
    physician_id?: IntFilter<"physician_appointment"> | number
    firstname?: StringNullableFilter<"physician_appointment"> | string | null
    lastname?: StringNullableFilter<"physician_appointment"> | string | null
    phone_num?: StringFilter<"physician_appointment"> | string
    alternate_phone_number?: StringFilter<"physician_appointment"> | string
    mail_id?: StringFilter<"physician_appointment"> | string
    pincode?: IntNullableFilter<"physician_appointment"> | number | null
    clinic_name?: StringNullableFilter<"physician_appointment"> | string | null
    clinic_phonenum?: StringFilter<"physician_appointment"> | string
    clinic_alternate_phonenum?: StringFilter<"physician_appointment"> | string
    clinic_manager?: StringFilter<"physician_appointment"> | string
    specialization?: StringNullableFilter<"physician_appointment"> | string | null
    address?: StringNullableFilter<"physician_appointment"> | string | null
    consultation_fee_validity?: StringFilter<"physician_appointment"> | string
    city?: StringNullableFilter<"physician_appointment"> | string | null
    state?: StringNullableFilter<"physician_appointment"> | string | null
    active?: BoolFilter<"physician_appointment"> | boolean
    created_by?: StringNullableFilter<"physician_appointment"> | string | null
    created_on?: DateTimeNullableFilter<"physician_appointment"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"physician_appointment"> | Date | string | null
    password?: StringNullableFilter<"physician_appointment"> | string | null
    role_id?: IntFilter<"physician_appointment"> | number
    profile_filename?: StringNullableFilter<"physician_appointment"> | string | null
    profile_fullpath?: StringNullableFilter<"physician_appointment"> | string | null
    qualification_id?: IntNullableFilter<"physician_appointment"> | number | null
    registration_number?: StringNullableFilter<"physician_appointment"> | string | null
    time_span?: StringNullableFilter<"physician_appointment"> | string | null
    status?: IntNullableFilter<"physician_appointment"> | number | null
    locality?: StringFilter<"physician_appointment"> | string
    created_by_id?: IntFilter<"physician_appointment"> | number
    clinic_module_activated?: IntFilter<"physician_appointment"> | number
    Signature_image?: StringFilter<"physician_appointment"> | string
    phy_admin?: Phy_adminListRelationFilter
  }

  export type physician_appointmentOrderByWithRelationInput = {
    physician_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    phone_num?: SortOrder
    alternate_phone_number?: SortOrder
    mail_id?: SortOrder
    pincode?: SortOrderInput | SortOrder
    clinic_name?: SortOrderInput | SortOrder
    clinic_phonenum?: SortOrder
    clinic_alternate_phonenum?: SortOrder
    clinic_manager?: SortOrder
    specialization?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    consultation_fee_validity?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    active?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrderInput | SortOrder
    profile_fullpath?: SortOrderInput | SortOrder
    qualification_id?: SortOrderInput | SortOrder
    registration_number?: SortOrderInput | SortOrder
    time_span?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    locality?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
    Signature_image?: SortOrder
    phy_admin?: phy_adminOrderByRelationAggregateInput
  }

  export type physician_appointmentWhereUniqueInput = Prisma.AtLeast<{
    physician_id?: number
    mail_id_phone_num?: physician_appointmentMail_idPhone_numCompoundUniqueInput
    AND?: physician_appointmentWhereInput | physician_appointmentWhereInput[]
    OR?: physician_appointmentWhereInput[]
    NOT?: physician_appointmentWhereInput | physician_appointmentWhereInput[]
    firstname?: StringNullableFilter<"physician_appointment"> | string | null
    lastname?: StringNullableFilter<"physician_appointment"> | string | null
    phone_num?: StringFilter<"physician_appointment"> | string
    alternate_phone_number?: StringFilter<"physician_appointment"> | string
    mail_id?: StringFilter<"physician_appointment"> | string
    pincode?: IntNullableFilter<"physician_appointment"> | number | null
    clinic_name?: StringNullableFilter<"physician_appointment"> | string | null
    clinic_phonenum?: StringFilter<"physician_appointment"> | string
    clinic_alternate_phonenum?: StringFilter<"physician_appointment"> | string
    clinic_manager?: StringFilter<"physician_appointment"> | string
    specialization?: StringNullableFilter<"physician_appointment"> | string | null
    address?: StringNullableFilter<"physician_appointment"> | string | null
    consultation_fee_validity?: StringFilter<"physician_appointment"> | string
    city?: StringNullableFilter<"physician_appointment"> | string | null
    state?: StringNullableFilter<"physician_appointment"> | string | null
    active?: BoolFilter<"physician_appointment"> | boolean
    created_by?: StringNullableFilter<"physician_appointment"> | string | null
    created_on?: DateTimeNullableFilter<"physician_appointment"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"physician_appointment"> | Date | string | null
    password?: StringNullableFilter<"physician_appointment"> | string | null
    role_id?: IntFilter<"physician_appointment"> | number
    profile_filename?: StringNullableFilter<"physician_appointment"> | string | null
    profile_fullpath?: StringNullableFilter<"physician_appointment"> | string | null
    qualification_id?: IntNullableFilter<"physician_appointment"> | number | null
    registration_number?: StringNullableFilter<"physician_appointment"> | string | null
    time_span?: StringNullableFilter<"physician_appointment"> | string | null
    status?: IntNullableFilter<"physician_appointment"> | number | null
    locality?: StringFilter<"physician_appointment"> | string
    created_by_id?: IntFilter<"physician_appointment"> | number
    clinic_module_activated?: IntFilter<"physician_appointment"> | number
    Signature_image?: StringFilter<"physician_appointment"> | string
    phy_admin?: Phy_adminListRelationFilter
  }, "mail_id_phone_num" | "physician_id">

  export type physician_appointmentOrderByWithAggregationInput = {
    physician_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    phone_num?: SortOrder
    alternate_phone_number?: SortOrder
    mail_id?: SortOrder
    pincode?: SortOrderInput | SortOrder
    clinic_name?: SortOrderInput | SortOrder
    clinic_phonenum?: SortOrder
    clinic_alternate_phonenum?: SortOrder
    clinic_manager?: SortOrder
    specialization?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    consultation_fee_validity?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    active?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrderInput | SortOrder
    profile_fullpath?: SortOrderInput | SortOrder
    qualification_id?: SortOrderInput | SortOrder
    registration_number?: SortOrderInput | SortOrder
    time_span?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    locality?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
    Signature_image?: SortOrder
    _count?: physician_appointmentCountOrderByAggregateInput
    _avg?: physician_appointmentAvgOrderByAggregateInput
    _max?: physician_appointmentMaxOrderByAggregateInput
    _min?: physician_appointmentMinOrderByAggregateInput
    _sum?: physician_appointmentSumOrderByAggregateInput
  }

  export type physician_appointmentScalarWhereWithAggregatesInput = {
    AND?: physician_appointmentScalarWhereWithAggregatesInput | physician_appointmentScalarWhereWithAggregatesInput[]
    OR?: physician_appointmentScalarWhereWithAggregatesInput[]
    NOT?: physician_appointmentScalarWhereWithAggregatesInput | physician_appointmentScalarWhereWithAggregatesInput[]
    physician_id?: IntWithAggregatesFilter<"physician_appointment"> | number
    firstname?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    lastname?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    phone_num?: StringWithAggregatesFilter<"physician_appointment"> | string
    alternate_phone_number?: StringWithAggregatesFilter<"physician_appointment"> | string
    mail_id?: StringWithAggregatesFilter<"physician_appointment"> | string
    pincode?: IntNullableWithAggregatesFilter<"physician_appointment"> | number | null
    clinic_name?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    clinic_phonenum?: StringWithAggregatesFilter<"physician_appointment"> | string
    clinic_alternate_phonenum?: StringWithAggregatesFilter<"physician_appointment"> | string
    clinic_manager?: StringWithAggregatesFilter<"physician_appointment"> | string
    specialization?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    address?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    consultation_fee_validity?: StringWithAggregatesFilter<"physician_appointment"> | string
    city?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    state?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    active?: BoolWithAggregatesFilter<"physician_appointment"> | boolean
    created_by?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"physician_appointment"> | Date | string | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"physician_appointment"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    role_id?: IntWithAggregatesFilter<"physician_appointment"> | number
    profile_filename?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    profile_fullpath?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    qualification_id?: IntNullableWithAggregatesFilter<"physician_appointment"> | number | null
    registration_number?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    time_span?: StringNullableWithAggregatesFilter<"physician_appointment"> | string | null
    status?: IntNullableWithAggregatesFilter<"physician_appointment"> | number | null
    locality?: StringWithAggregatesFilter<"physician_appointment"> | string
    created_by_id?: IntWithAggregatesFilter<"physician_appointment"> | number
    clinic_module_activated?: IntWithAggregatesFilter<"physician_appointment"> | number
    Signature_image?: StringWithAggregatesFilter<"physician_appointment"> | string
  }

  export type physician_clinic_timingsWhereInput = {
    AND?: physician_clinic_timingsWhereInput | physician_clinic_timingsWhereInput[]
    OR?: physician_clinic_timingsWhereInput[]
    NOT?: physician_clinic_timingsWhereInput | physician_clinic_timingsWhereInput[]
    id?: IntFilter<"physician_clinic_timings"> | number
    physician_id?: IntFilter<"physician_clinic_timings"> | number
    theday?: StringFilter<"physician_clinic_timings"> | string
    work_type?: Enumphysician_clinic_timings_work_typeFilter<"physician_clinic_timings"> | $Enums.physician_clinic_timings_work_type
    clinic?: StringNullableFilter<"physician_clinic_timings"> | string | null
    start_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    end_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    created_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    updated_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
  }

  export type physician_clinic_timingsOrderByWithRelationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    clinic?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
  }

  export type physician_clinic_timingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: physician_clinic_timingsWhereInput | physician_clinic_timingsWhereInput[]
    OR?: physician_clinic_timingsWhereInput[]
    NOT?: physician_clinic_timingsWhereInput | physician_clinic_timingsWhereInput[]
    physician_id?: IntFilter<"physician_clinic_timings"> | number
    theday?: StringFilter<"physician_clinic_timings"> | string
    work_type?: Enumphysician_clinic_timings_work_typeFilter<"physician_clinic_timings"> | $Enums.physician_clinic_timings_work_type
    clinic?: StringNullableFilter<"physician_clinic_timings"> | string | null
    start_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    end_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    created_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
    updated_time?: StringNullableFilter<"physician_clinic_timings"> | string | null
  }, "id">

  export type physician_clinic_timingsOrderByWithAggregationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    clinic?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
    _count?: physician_clinic_timingsCountOrderByAggregateInput
    _avg?: physician_clinic_timingsAvgOrderByAggregateInput
    _max?: physician_clinic_timingsMaxOrderByAggregateInput
    _min?: physician_clinic_timingsMinOrderByAggregateInput
    _sum?: physician_clinic_timingsSumOrderByAggregateInput
  }

  export type physician_clinic_timingsScalarWhereWithAggregatesInput = {
    AND?: physician_clinic_timingsScalarWhereWithAggregatesInput | physician_clinic_timingsScalarWhereWithAggregatesInput[]
    OR?: physician_clinic_timingsScalarWhereWithAggregatesInput[]
    NOT?: physician_clinic_timingsScalarWhereWithAggregatesInput | physician_clinic_timingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"physician_clinic_timings"> | number
    physician_id?: IntWithAggregatesFilter<"physician_clinic_timings"> | number
    theday?: StringWithAggregatesFilter<"physician_clinic_timings"> | string
    work_type?: Enumphysician_clinic_timings_work_typeWithAggregatesFilter<"physician_clinic_timings"> | $Enums.physician_clinic_timings_work_type
    clinic?: StringNullableWithAggregatesFilter<"physician_clinic_timings"> | string | null
    start_time?: StringNullableWithAggregatesFilter<"physician_clinic_timings"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"physician_clinic_timings"> | string | null
    created_time?: StringNullableWithAggregatesFilter<"physician_clinic_timings"> | string | null
    updated_time?: StringNullableWithAggregatesFilter<"physician_clinic_timings"> | string | null
  }

  export type physician_leavesWhereInput = {
    AND?: physician_leavesWhereInput | physician_leavesWhereInput[]
    OR?: physician_leavesWhereInput[]
    NOT?: physician_leavesWhereInput | physician_leavesWhereInput[]
    id?: IntFilter<"physician_leaves"> | number
    physician_id?: BigIntFilter<"physician_leaves"> | bigint | number
    dates?: StringFilter<"physician_leaves"> | string
    start_time?: StringNullableFilter<"physician_leaves"> | string | null
    end_time?: StringNullableFilter<"physician_leaves"> | string | null
    reason?: StringNullableFilter<"physician_leaves"> | string | null
    created_time?: StringFilter<"physician_leaves"> | string
  }

  export type physician_leavesOrderByWithRelationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_time?: SortOrder
  }

  export type physician_leavesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: physician_leavesWhereInput | physician_leavesWhereInput[]
    OR?: physician_leavesWhereInput[]
    NOT?: physician_leavesWhereInput | physician_leavesWhereInput[]
    physician_id?: BigIntFilter<"physician_leaves"> | bigint | number
    dates?: StringFilter<"physician_leaves"> | string
    start_time?: StringNullableFilter<"physician_leaves"> | string | null
    end_time?: StringNullableFilter<"physician_leaves"> | string | null
    reason?: StringNullableFilter<"physician_leaves"> | string | null
    created_time?: StringFilter<"physician_leaves"> | string
  }, "id">

  export type physician_leavesOrderByWithAggregationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_time?: SortOrder
    _count?: physician_leavesCountOrderByAggregateInput
    _avg?: physician_leavesAvgOrderByAggregateInput
    _max?: physician_leavesMaxOrderByAggregateInput
    _min?: physician_leavesMinOrderByAggregateInput
    _sum?: physician_leavesSumOrderByAggregateInput
  }

  export type physician_leavesScalarWhereWithAggregatesInput = {
    AND?: physician_leavesScalarWhereWithAggregatesInput | physician_leavesScalarWhereWithAggregatesInput[]
    OR?: physician_leavesScalarWhereWithAggregatesInput[]
    NOT?: physician_leavesScalarWhereWithAggregatesInput | physician_leavesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"physician_leaves"> | number
    physician_id?: BigIntWithAggregatesFilter<"physician_leaves"> | bigint | number
    dates?: StringWithAggregatesFilter<"physician_leaves"> | string
    start_time?: StringNullableWithAggregatesFilter<"physician_leaves"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"physician_leaves"> | string | null
    reason?: StringNullableWithAggregatesFilter<"physician_leaves"> | string | null
    created_time?: StringWithAggregatesFilter<"physician_leaves"> | string
  }

  export type physician_timingsWhereInput = {
    AND?: physician_timingsWhereInput | physician_timingsWhereInput[]
    OR?: physician_timingsWhereInput[]
    NOT?: physician_timingsWhereInput | physician_timingsWhereInput[]
    id?: IntFilter<"physician_timings"> | number
    physician_id?: IntFilter<"physician_timings"> | number
    theday?: StringFilter<"physician_timings"> | string
    work_type?: Enumphysician_timings_work_typeFilter<"physician_timings"> | $Enums.physician_timings_work_type
    start_time?: StringNullableFilter<"physician_timings"> | string | null
    end_time?: StringNullableFilter<"physician_timings"> | string | null
    created_time?: StringNullableFilter<"physician_timings"> | string | null
    updated_time?: StringNullableFilter<"physician_timings"> | string | null
  }

  export type physician_timingsOrderByWithRelationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
  }

  export type physician_timingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: physician_timingsWhereInput | physician_timingsWhereInput[]
    OR?: physician_timingsWhereInput[]
    NOT?: physician_timingsWhereInput | physician_timingsWhereInput[]
    physician_id?: IntFilter<"physician_timings"> | number
    theday?: StringFilter<"physician_timings"> | string
    work_type?: Enumphysician_timings_work_typeFilter<"physician_timings"> | $Enums.physician_timings_work_type
    start_time?: StringNullableFilter<"physician_timings"> | string | null
    end_time?: StringNullableFilter<"physician_timings"> | string | null
    created_time?: StringNullableFilter<"physician_timings"> | string | null
    updated_time?: StringNullableFilter<"physician_timings"> | string | null
  }, "id">

  export type physician_timingsOrderByWithAggregationInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_time?: SortOrderInput | SortOrder
    updated_time?: SortOrderInput | SortOrder
    _count?: physician_timingsCountOrderByAggregateInput
    _avg?: physician_timingsAvgOrderByAggregateInput
    _max?: physician_timingsMaxOrderByAggregateInput
    _min?: physician_timingsMinOrderByAggregateInput
    _sum?: physician_timingsSumOrderByAggregateInput
  }

  export type physician_timingsScalarWhereWithAggregatesInput = {
    AND?: physician_timingsScalarWhereWithAggregatesInput | physician_timingsScalarWhereWithAggregatesInput[]
    OR?: physician_timingsScalarWhereWithAggregatesInput[]
    NOT?: physician_timingsScalarWhereWithAggregatesInput | physician_timingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"physician_timings"> | number
    physician_id?: IntWithAggregatesFilter<"physician_timings"> | number
    theday?: StringWithAggregatesFilter<"physician_timings"> | string
    work_type?: Enumphysician_timings_work_typeWithAggregatesFilter<"physician_timings"> | $Enums.physician_timings_work_type
    start_time?: StringNullableWithAggregatesFilter<"physician_timings"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"physician_timings"> | string | null
    created_time?: StringNullableWithAggregatesFilter<"physician_timings"> | string | null
    updated_time?: StringNullableWithAggregatesFilter<"physician_timings"> | string | null
  }

  export type preferredlabsWhereInput = {
    AND?: preferredlabsWhereInput | preferredlabsWhereInput[]
    OR?: preferredlabsWhereInput[]
    NOT?: preferredlabsWhereInput | preferredlabsWhereInput[]
    preferredlabs_id?: IntFilter<"preferredlabs"> | number
    laboratory_id?: IntFilter<"preferredlabs"> | number
    physician_id?: IntFilter<"preferredlabs"> | number
    is_active?: IntFilter<"preferredlabs"> | number
  }

  export type preferredlabsOrderByWithRelationInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type preferredlabsWhereUniqueInput = Prisma.AtLeast<{
    preferredlabs_id?: number
    AND?: preferredlabsWhereInput | preferredlabsWhereInput[]
    OR?: preferredlabsWhereInput[]
    NOT?: preferredlabsWhereInput | preferredlabsWhereInput[]
    laboratory_id?: IntFilter<"preferredlabs"> | number
    physician_id?: IntFilter<"preferredlabs"> | number
    is_active?: IntFilter<"preferredlabs"> | number
  }, "preferredlabs_id">

  export type preferredlabsOrderByWithAggregationInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
    _count?: preferredlabsCountOrderByAggregateInput
    _avg?: preferredlabsAvgOrderByAggregateInput
    _max?: preferredlabsMaxOrderByAggregateInput
    _min?: preferredlabsMinOrderByAggregateInput
    _sum?: preferredlabsSumOrderByAggregateInput
  }

  export type preferredlabsScalarWhereWithAggregatesInput = {
    AND?: preferredlabsScalarWhereWithAggregatesInput | preferredlabsScalarWhereWithAggregatesInput[]
    OR?: preferredlabsScalarWhereWithAggregatesInput[]
    NOT?: preferredlabsScalarWhereWithAggregatesInput | preferredlabsScalarWhereWithAggregatesInput[]
    preferredlabs_id?: IntWithAggregatesFilter<"preferredlabs"> | number
    laboratory_id?: IntWithAggregatesFilter<"preferredlabs"> | number
    physician_id?: IntWithAggregatesFilter<"preferredlabs"> | number
    is_active?: IntWithAggregatesFilter<"preferredlabs"> | number
  }

  export type prescriptionWhereInput = {
    AND?: prescriptionWhereInput | prescriptionWhereInput[]
    OR?: prescriptionWhereInput[]
    NOT?: prescriptionWhereInput | prescriptionWhereInput[]
    prescription_id?: IntFilter<"prescription"> | number
    prescription_num?: StringFilter<"prescription"> | string
    patient_id?: IntFilter<"prescription"> | number
    dependent_id?: IntFilter<"prescription"> | number
    doctor_id?: IntNullableFilter<"prescription"> | number | null
    symptoms?: StringNullableFilter<"prescription"> | string | null
    type?: StringNullableFilter<"prescription"> | string | null
    med_name?: StringNullableFilter<"prescription"> | string | null
    mg?: StringNullableFilter<"prescription"> | string | null
    dose?: StringNullableFilter<"prescription"> | string | null
    num_days?: StringNullableFilter<"prescription"> | string | null
    instruction?: StringFilter<"prescription"> | string
    advice?: StringNullableFilter<"prescription"> | string | null
    created_on?: DateTimeNullableFilter<"prescription"> | Date | string | null
  }

  export type prescriptionOrderByWithRelationInput = {
    prescription_id?: SortOrder
    prescription_num?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrderInput | SortOrder
    symptoms?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    med_name?: SortOrderInput | SortOrder
    mg?: SortOrderInput | SortOrder
    dose?: SortOrderInput | SortOrder
    num_days?: SortOrderInput | SortOrder
    instruction?: SortOrder
    advice?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
  }

  export type prescriptionWhereUniqueInput = Prisma.AtLeast<{
    prescription_id?: number
    AND?: prescriptionWhereInput | prescriptionWhereInput[]
    OR?: prescriptionWhereInput[]
    NOT?: prescriptionWhereInput | prescriptionWhereInput[]
    prescription_num?: StringFilter<"prescription"> | string
    patient_id?: IntFilter<"prescription"> | number
    dependent_id?: IntFilter<"prescription"> | number
    doctor_id?: IntNullableFilter<"prescription"> | number | null
    symptoms?: StringNullableFilter<"prescription"> | string | null
    type?: StringNullableFilter<"prescription"> | string | null
    med_name?: StringNullableFilter<"prescription"> | string | null
    mg?: StringNullableFilter<"prescription"> | string | null
    dose?: StringNullableFilter<"prescription"> | string | null
    num_days?: StringNullableFilter<"prescription"> | string | null
    instruction?: StringFilter<"prescription"> | string
    advice?: StringNullableFilter<"prescription"> | string | null
    created_on?: DateTimeNullableFilter<"prescription"> | Date | string | null
  }, "prescription_id">

  export type prescriptionOrderByWithAggregationInput = {
    prescription_id?: SortOrder
    prescription_num?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrderInput | SortOrder
    symptoms?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    med_name?: SortOrderInput | SortOrder
    mg?: SortOrderInput | SortOrder
    dose?: SortOrderInput | SortOrder
    num_days?: SortOrderInput | SortOrder
    instruction?: SortOrder
    advice?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    _count?: prescriptionCountOrderByAggregateInput
    _avg?: prescriptionAvgOrderByAggregateInput
    _max?: prescriptionMaxOrderByAggregateInput
    _min?: prescriptionMinOrderByAggregateInput
    _sum?: prescriptionSumOrderByAggregateInput
  }

  export type prescriptionScalarWhereWithAggregatesInput = {
    AND?: prescriptionScalarWhereWithAggregatesInput | prescriptionScalarWhereWithAggregatesInput[]
    OR?: prescriptionScalarWhereWithAggregatesInput[]
    NOT?: prescriptionScalarWhereWithAggregatesInput | prescriptionScalarWhereWithAggregatesInput[]
    prescription_id?: IntWithAggregatesFilter<"prescription"> | number
    prescription_num?: StringWithAggregatesFilter<"prescription"> | string
    patient_id?: IntWithAggregatesFilter<"prescription"> | number
    dependent_id?: IntWithAggregatesFilter<"prescription"> | number
    doctor_id?: IntNullableWithAggregatesFilter<"prescription"> | number | null
    symptoms?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    type?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    med_name?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    mg?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    dose?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    num_days?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    instruction?: StringWithAggregatesFilter<"prescription"> | string
    advice?: StringNullableWithAggregatesFilter<"prescription"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"prescription"> | Date | string | null
  }

  export type prescription_medicineWhereInput = {
    AND?: prescription_medicineWhereInput | prescription_medicineWhereInput[]
    OR?: prescription_medicineWhereInput[]
    NOT?: prescription_medicineWhereInput | prescription_medicineWhereInput[]
    medicine_id?: IntFilter<"prescription_medicine"> | number
    type?: StringNullableFilter<"prescription_medicine"> | string | null
    med_name?: StringNullableFilter<"prescription_medicine"> | string | null
    mg?: StringFilter<"prescription_medicine"> | string
    dose?: StringFilter<"prescription_medicine"> | string
    num_days?: StringFilter<"prescription_medicine"> | string
    instruction?: StringFilter<"prescription_medicine"> | string
    advice?: StringFilter<"prescription_medicine"> | string
    prescription_id?: IntNullableFilter<"prescription_medicine"> | number | null
  }

  export type prescription_medicineOrderByWithRelationInput = {
    medicine_id?: SortOrder
    type?: SortOrderInput | SortOrder
    med_name?: SortOrderInput | SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    prescription_id?: SortOrderInput | SortOrder
  }

  export type prescription_medicineWhereUniqueInput = Prisma.AtLeast<{
    medicine_id?: number
    AND?: prescription_medicineWhereInput | prescription_medicineWhereInput[]
    OR?: prescription_medicineWhereInput[]
    NOT?: prescription_medicineWhereInput | prescription_medicineWhereInput[]
    type?: StringNullableFilter<"prescription_medicine"> | string | null
    med_name?: StringNullableFilter<"prescription_medicine"> | string | null
    mg?: StringFilter<"prescription_medicine"> | string
    dose?: StringFilter<"prescription_medicine"> | string
    num_days?: StringFilter<"prescription_medicine"> | string
    instruction?: StringFilter<"prescription_medicine"> | string
    advice?: StringFilter<"prescription_medicine"> | string
    prescription_id?: IntNullableFilter<"prescription_medicine"> | number | null
  }, "medicine_id">

  export type prescription_medicineOrderByWithAggregationInput = {
    medicine_id?: SortOrder
    type?: SortOrderInput | SortOrder
    med_name?: SortOrderInput | SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    prescription_id?: SortOrderInput | SortOrder
    _count?: prescription_medicineCountOrderByAggregateInput
    _avg?: prescription_medicineAvgOrderByAggregateInput
    _max?: prescription_medicineMaxOrderByAggregateInput
    _min?: prescription_medicineMinOrderByAggregateInput
    _sum?: prescription_medicineSumOrderByAggregateInput
  }

  export type prescription_medicineScalarWhereWithAggregatesInput = {
    AND?: prescription_medicineScalarWhereWithAggregatesInput | prescription_medicineScalarWhereWithAggregatesInput[]
    OR?: prescription_medicineScalarWhereWithAggregatesInput[]
    NOT?: prescription_medicineScalarWhereWithAggregatesInput | prescription_medicineScalarWhereWithAggregatesInput[]
    medicine_id?: IntWithAggregatesFilter<"prescription_medicine"> | number
    type?: StringNullableWithAggregatesFilter<"prescription_medicine"> | string | null
    med_name?: StringNullableWithAggregatesFilter<"prescription_medicine"> | string | null
    mg?: StringWithAggregatesFilter<"prescription_medicine"> | string
    dose?: StringWithAggregatesFilter<"prescription_medicine"> | string
    num_days?: StringWithAggregatesFilter<"prescription_medicine"> | string
    instruction?: StringWithAggregatesFilter<"prescription_medicine"> | string
    advice?: StringWithAggregatesFilter<"prescription_medicine"> | string
    prescription_id?: IntNullableWithAggregatesFilter<"prescription_medicine"> | number | null
  }

  export type qualificationWhereInput = {
    AND?: qualificationWhereInput | qualificationWhereInput[]
    OR?: qualificationWhereInput[]
    NOT?: qualificationWhereInput | qualificationWhereInput[]
    qualification_id?: IntFilter<"qualification"> | number
    qualification_name?: StringFilter<"qualification"> | string
    is_active?: IntFilter<"qualification"> | number
  }

  export type qualificationOrderByWithRelationInput = {
    qualification_id?: SortOrder
    qualification_name?: SortOrder
    is_active?: SortOrder
  }

  export type qualificationWhereUniqueInput = Prisma.AtLeast<{
    qualification_id?: number
    AND?: qualificationWhereInput | qualificationWhereInput[]
    OR?: qualificationWhereInput[]
    NOT?: qualificationWhereInput | qualificationWhereInput[]
    qualification_name?: StringFilter<"qualification"> | string
    is_active?: IntFilter<"qualification"> | number
  }, "qualification_id">

  export type qualificationOrderByWithAggregationInput = {
    qualification_id?: SortOrder
    qualification_name?: SortOrder
    is_active?: SortOrder
    _count?: qualificationCountOrderByAggregateInput
    _avg?: qualificationAvgOrderByAggregateInput
    _max?: qualificationMaxOrderByAggregateInput
    _min?: qualificationMinOrderByAggregateInput
    _sum?: qualificationSumOrderByAggregateInput
  }

  export type qualificationScalarWhereWithAggregatesInput = {
    AND?: qualificationScalarWhereWithAggregatesInput | qualificationScalarWhereWithAggregatesInput[]
    OR?: qualificationScalarWhereWithAggregatesInput[]
    NOT?: qualificationScalarWhereWithAggregatesInput | qualificationScalarWhereWithAggregatesInput[]
    qualification_id?: IntWithAggregatesFilter<"qualification"> | number
    qualification_name?: StringWithAggregatesFilter<"qualification"> | string
    is_active?: IntWithAggregatesFilter<"qualification"> | number
  }

  export type qualification_mappingWhereInput = {
    AND?: qualification_mappingWhereInput | qualification_mappingWhereInput[]
    OR?: qualification_mappingWhereInput[]
    NOT?: qualification_mappingWhereInput | qualification_mappingWhereInput[]
    qualification_mapping_id?: IntFilter<"qualification_mapping"> | number
    qualification_id?: IntFilter<"qualification_mapping"> | number
    physician_id?: IntFilter<"qualification_mapping"> | number
  }

  export type qualification_mappingOrderByWithRelationInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type qualification_mappingWhereUniqueInput = Prisma.AtLeast<{
    qualification_mapping_id?: number
    AND?: qualification_mappingWhereInput | qualification_mappingWhereInput[]
    OR?: qualification_mappingWhereInput[]
    NOT?: qualification_mappingWhereInput | qualification_mappingWhereInput[]
    qualification_id?: IntFilter<"qualification_mapping"> | number
    physician_id?: IntFilter<"qualification_mapping"> | number
  }, "qualification_mapping_id">

  export type qualification_mappingOrderByWithAggregationInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
    _count?: qualification_mappingCountOrderByAggregateInput
    _avg?: qualification_mappingAvgOrderByAggregateInput
    _max?: qualification_mappingMaxOrderByAggregateInput
    _min?: qualification_mappingMinOrderByAggregateInput
    _sum?: qualification_mappingSumOrderByAggregateInput
  }

  export type qualification_mappingScalarWhereWithAggregatesInput = {
    AND?: qualification_mappingScalarWhereWithAggregatesInput | qualification_mappingScalarWhereWithAggregatesInput[]
    OR?: qualification_mappingScalarWhereWithAggregatesInput[]
    NOT?: qualification_mappingScalarWhereWithAggregatesInput | qualification_mappingScalarWhereWithAggregatesInput[]
    qualification_mapping_id?: IntWithAggregatesFilter<"qualification_mapping"> | number
    qualification_id?: IntWithAggregatesFilter<"qualification_mapping"> | number
    physician_id?: IntWithAggregatesFilter<"qualification_mapping"> | number
  }

  export type referral_confirmation_detailsWhereInput = {
    AND?: referral_confirmation_detailsWhereInput | referral_confirmation_detailsWhereInput[]
    OR?: referral_confirmation_detailsWhereInput[]
    NOT?: referral_confirmation_detailsWhereInput | referral_confirmation_detailsWhereInput[]
    referred_id?: IntFilter<"referral_confirmation_details"> | number
    medical_num?: StringFilter<"referral_confirmation_details"> | string
    relationship?: StringNullableFilter<"referral_confirmation_details"> | string | null
    referral_pat_id?: IntNullableFilter<"referral_confirmation_details"> | number | null
    password?: StringNullableFilter<"referral_confirmation_details"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_confirmation_details"> | string | null
    attempts?: IntNullableFilter<"referral_confirmation_details"> | number | null
    brief_history?: StringNullableFilter<"referral_confirmation_details"> | string | null
    phy_advice?: StringNullableFilter<"referral_confirmation_details"> | string | null
    refer_date?: DateTimeNullableFilter<"referral_confirmation_details"> | Date | string | null
    created_by?: StringNullableFilter<"referral_confirmation_details"> | string | null
    login_id?: IntFilter<"referral_confirmation_details"> | number
    created_on?: DateTimeFilter<"referral_confirmation_details"> | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFilter<"referral_confirmation_details"> | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFilter<"referral_confirmation_details"> | number
    billing_status?: IntFilter<"referral_confirmation_details"> | number
  }

  export type referral_confirmation_detailsOrderByWithRelationInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrderInput | SortOrder
    referral_pat_id?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    brief_history?: SortOrderInput | SortOrder
    phy_advice?: SortOrderInput | SortOrder
    refer_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type referral_confirmation_detailsWhereUniqueInput = Prisma.AtLeast<{
    referred_id?: number
    medical_num?: string
    AND?: referral_confirmation_detailsWhereInput | referral_confirmation_detailsWhereInput[]
    OR?: referral_confirmation_detailsWhereInput[]
    NOT?: referral_confirmation_detailsWhereInput | referral_confirmation_detailsWhereInput[]
    relationship?: StringNullableFilter<"referral_confirmation_details"> | string | null
    referral_pat_id?: IntNullableFilter<"referral_confirmation_details"> | number | null
    password?: StringNullableFilter<"referral_confirmation_details"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_confirmation_details"> | string | null
    attempts?: IntNullableFilter<"referral_confirmation_details"> | number | null
    brief_history?: StringNullableFilter<"referral_confirmation_details"> | string | null
    phy_advice?: StringNullableFilter<"referral_confirmation_details"> | string | null
    refer_date?: DateTimeNullableFilter<"referral_confirmation_details"> | Date | string | null
    created_by?: StringNullableFilter<"referral_confirmation_details"> | string | null
    login_id?: IntFilter<"referral_confirmation_details"> | number
    created_on?: DateTimeFilter<"referral_confirmation_details"> | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFilter<"referral_confirmation_details"> | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFilter<"referral_confirmation_details"> | number
    billing_status?: IntFilter<"referral_confirmation_details"> | number
  }, "medical_num" | "referred_id">

  export type referral_confirmation_detailsOrderByWithAggregationInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrderInput | SortOrder
    referral_pat_id?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    brief_history?: SortOrderInput | SortOrder
    phy_advice?: SortOrderInput | SortOrder
    refer_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    _count?: referral_confirmation_detailsCountOrderByAggregateInput
    _avg?: referral_confirmation_detailsAvgOrderByAggregateInput
    _max?: referral_confirmation_detailsMaxOrderByAggregateInput
    _min?: referral_confirmation_detailsMinOrderByAggregateInput
    _sum?: referral_confirmation_detailsSumOrderByAggregateInput
  }

  export type referral_confirmation_detailsScalarWhereWithAggregatesInput = {
    AND?: referral_confirmation_detailsScalarWhereWithAggregatesInput | referral_confirmation_detailsScalarWhereWithAggregatesInput[]
    OR?: referral_confirmation_detailsScalarWhereWithAggregatesInput[]
    NOT?: referral_confirmation_detailsScalarWhereWithAggregatesInput | referral_confirmation_detailsScalarWhereWithAggregatesInput[]
    referred_id?: IntWithAggregatesFilter<"referral_confirmation_details"> | number
    medical_num?: StringWithAggregatesFilter<"referral_confirmation_details"> | string
    relationship?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    referral_pat_id?: IntNullableWithAggregatesFilter<"referral_confirmation_details"> | number | null
    password?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    patient_unique_id?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    attempts?: IntNullableWithAggregatesFilter<"referral_confirmation_details"> | number | null
    brief_history?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    phy_advice?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    refer_date?: DateTimeNullableWithAggregatesFilter<"referral_confirmation_details"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"referral_confirmation_details"> | string | null
    login_id?: IntWithAggregatesFilter<"referral_confirmation_details"> | number
    created_on?: DateTimeWithAggregatesFilter<"referral_confirmation_details"> | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeWithAggregatesFilter<"referral_confirmation_details"> | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntWithAggregatesFilter<"referral_confirmation_details"> | number
    billing_status?: IntWithAggregatesFilter<"referral_confirmation_details"> | number
  }

  export type referral_confirmation_details1WhereInput = {
    AND?: referral_confirmation_details1WhereInput | referral_confirmation_details1WhereInput[]
    OR?: referral_confirmation_details1WhereInput[]
    NOT?: referral_confirmation_details1WhereInput | referral_confirmation_details1WhereInput[]
    referred_id?: IntFilter<"referral_confirmation_details1"> | number
    medical_num?: StringFilter<"referral_confirmation_details1"> | string
    relationship?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    referral_pat_id?: IntNullableFilter<"referral_confirmation_details1"> | number | null
    password?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    attempts?: IntNullableFilter<"referral_confirmation_details1"> | number | null
    brief_history?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    phy_advice?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    refer_date?: DateTimeNullableFilter<"referral_confirmation_details1"> | Date | string | null
    created_by?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    login_id?: IntFilter<"referral_confirmation_details1"> | number
    created_on?: DateTimeFilter<"referral_confirmation_details1"> | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFilter<"referral_confirmation_details1"> | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFilter<"referral_confirmation_details1"> | number
  }

  export type referral_confirmation_details1OrderByWithRelationInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrderInput | SortOrder
    referral_pat_id?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    brief_history?: SortOrderInput | SortOrder
    phy_advice?: SortOrderInput | SortOrder
    refer_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
  }

  export type referral_confirmation_details1WhereUniqueInput = Prisma.AtLeast<{
    referred_id?: number
    medical_num?: string
    AND?: referral_confirmation_details1WhereInput | referral_confirmation_details1WhereInput[]
    OR?: referral_confirmation_details1WhereInput[]
    NOT?: referral_confirmation_details1WhereInput | referral_confirmation_details1WhereInput[]
    relationship?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    referral_pat_id?: IntNullableFilter<"referral_confirmation_details1"> | number | null
    password?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    attempts?: IntNullableFilter<"referral_confirmation_details1"> | number | null
    brief_history?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    phy_advice?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    refer_date?: DateTimeNullableFilter<"referral_confirmation_details1"> | Date | string | null
    created_by?: StringNullableFilter<"referral_confirmation_details1"> | string | null
    login_id?: IntFilter<"referral_confirmation_details1"> | number
    created_on?: DateTimeFilter<"referral_confirmation_details1"> | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFilter<"referral_confirmation_details1"> | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFilter<"referral_confirmation_details1"> | number
  }, "medical_num" | "referred_id">

  export type referral_confirmation_details1OrderByWithAggregationInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrderInput | SortOrder
    referral_pat_id?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    brief_history?: SortOrderInput | SortOrder
    phy_advice?: SortOrderInput | SortOrder
    refer_date?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    _count?: referral_confirmation_details1CountOrderByAggregateInput
    _avg?: referral_confirmation_details1AvgOrderByAggregateInput
    _max?: referral_confirmation_details1MaxOrderByAggregateInput
    _min?: referral_confirmation_details1MinOrderByAggregateInput
    _sum?: referral_confirmation_details1SumOrderByAggregateInput
  }

  export type referral_confirmation_details1ScalarWhereWithAggregatesInput = {
    AND?: referral_confirmation_details1ScalarWhereWithAggregatesInput | referral_confirmation_details1ScalarWhereWithAggregatesInput[]
    OR?: referral_confirmation_details1ScalarWhereWithAggregatesInput[]
    NOT?: referral_confirmation_details1ScalarWhereWithAggregatesInput | referral_confirmation_details1ScalarWhereWithAggregatesInput[]
    referred_id?: IntWithAggregatesFilter<"referral_confirmation_details1"> | number
    medical_num?: StringWithAggregatesFilter<"referral_confirmation_details1"> | string
    relationship?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    referral_pat_id?: IntNullableWithAggregatesFilter<"referral_confirmation_details1"> | number | null
    password?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    patient_unique_id?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    attempts?: IntNullableWithAggregatesFilter<"referral_confirmation_details1"> | number | null
    brief_history?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    phy_advice?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    refer_date?: DateTimeNullableWithAggregatesFilter<"referral_confirmation_details1"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"referral_confirmation_details1"> | string | null
    login_id?: IntWithAggregatesFilter<"referral_confirmation_details1"> | number
    created_on?: DateTimeWithAggregatesFilter<"referral_confirmation_details1"> | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeWithAggregatesFilter<"referral_confirmation_details1"> | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntWithAggregatesFilter<"referral_confirmation_details1"> | number
  }

  export type referral_patient_detailsWhereInput = {
    AND?: referral_patient_detailsWhereInput | referral_patient_detailsWhereInput[]
    OR?: referral_patient_detailsWhereInput[]
    NOT?: referral_patient_detailsWhereInput | referral_patient_detailsWhereInput[]
    referral_patient_id?: IntFilter<"referral_patient_details"> | number
    firstname?: StringNullableFilter<"referral_patient_details"> | string | null
    lastname?: StringNullableFilter<"referral_patient_details"> | string | null
    gender?: StringNullableFilter<"referral_patient_details"> | string | null
    date_of_birth?: DateTimeFilter<"referral_patient_details"> | Date | string
    age?: StringNullableFilter<"referral_patient_details"> | string | null
    address?: StringNullableFilter<"referral_patient_details"> | string | null
    state?: StringNullableFilter<"referral_patient_details"> | string | null
    city?: StringNullableFilter<"referral_patient_details"> | string | null
    pincode?: StringNullableFilter<"referral_patient_details"> | string | null
    mailid?: StringFilter<"referral_patient_details"> | string
    phonenum?: StringFilter<"referral_patient_details"> | string
    alt_phonenum?: StringNullableFilter<"referral_patient_details"> | string | null
    password?: StringNullableFilter<"referral_patient_details"> | string | null
    relationship?: StringFilter<"referral_patient_details"> | string
    created_on?: StringNullableFilter<"referral_patient_details"> | string | null
    updated_on?: DateTimeNullableFilter<"referral_patient_details"> | Date | string | null
    active?: IntNullableFilter<"referral_patient_details"> | number | null
    role_id?: IntFilter<"referral_patient_details"> | number
    patient_unique_id?: StringNullableFilter<"referral_patient_details"> | string | null
    physician_id?: StringFilter<"referral_patient_details"> | string
    status?: StringFilter<"referral_patient_details"> | string
    r_count?: IntFilter<"referral_patient_details"> | number
    profile_filename?: StringNullableFilter<"referral_patient_details"> | string | null
    profile_fullpath?: StringNullableFilter<"referral_patient_details"> | string | null
    main_pat_id?: StringNullableFilter<"referral_patient_details"> | string | null
    patient_dep_id?: IntNullableFilter<"referral_patient_details"> | number | null
    count?: IntFilter<"referral_patient_details"> | number
    prescribe_receipt?: IntFilter<"referral_patient_details"> | number
  }

  export type referral_patient_detailsOrderByWithRelationInput = {
    referral_patient_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrder
    age?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    relationship?: SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    profile_filename?: SortOrderInput | SortOrder
    profile_fullpath?: SortOrderInput | SortOrder
    main_pat_id?: SortOrderInput | SortOrder
    patient_dep_id?: SortOrderInput | SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_detailsWhereUniqueInput = Prisma.AtLeast<{
    referral_patient_id?: number
    phonenum?: string
    AND?: referral_patient_detailsWhereInput | referral_patient_detailsWhereInput[]
    OR?: referral_patient_detailsWhereInput[]
    NOT?: referral_patient_detailsWhereInput | referral_patient_detailsWhereInput[]
    firstname?: StringNullableFilter<"referral_patient_details"> | string | null
    lastname?: StringNullableFilter<"referral_patient_details"> | string | null
    gender?: StringNullableFilter<"referral_patient_details"> | string | null
    date_of_birth?: DateTimeFilter<"referral_patient_details"> | Date | string
    age?: StringNullableFilter<"referral_patient_details"> | string | null
    address?: StringNullableFilter<"referral_patient_details"> | string | null
    state?: StringNullableFilter<"referral_patient_details"> | string | null
    city?: StringNullableFilter<"referral_patient_details"> | string | null
    pincode?: StringNullableFilter<"referral_patient_details"> | string | null
    mailid?: StringFilter<"referral_patient_details"> | string
    alt_phonenum?: StringNullableFilter<"referral_patient_details"> | string | null
    password?: StringNullableFilter<"referral_patient_details"> | string | null
    relationship?: StringFilter<"referral_patient_details"> | string
    created_on?: StringNullableFilter<"referral_patient_details"> | string | null
    updated_on?: DateTimeNullableFilter<"referral_patient_details"> | Date | string | null
    active?: IntNullableFilter<"referral_patient_details"> | number | null
    role_id?: IntFilter<"referral_patient_details"> | number
    patient_unique_id?: StringNullableFilter<"referral_patient_details"> | string | null
    physician_id?: StringFilter<"referral_patient_details"> | string
    status?: StringFilter<"referral_patient_details"> | string
    r_count?: IntFilter<"referral_patient_details"> | number
    profile_filename?: StringNullableFilter<"referral_patient_details"> | string | null
    profile_fullpath?: StringNullableFilter<"referral_patient_details"> | string | null
    main_pat_id?: StringNullableFilter<"referral_patient_details"> | string | null
    patient_dep_id?: IntNullableFilter<"referral_patient_details"> | number | null
    count?: IntFilter<"referral_patient_details"> | number
    prescribe_receipt?: IntFilter<"referral_patient_details"> | number
  }, "phonenum" | "referral_patient_id">

  export type referral_patient_detailsOrderByWithAggregationInput = {
    referral_patient_id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrder
    age?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    relationship?: SortOrder
    created_on?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    profile_filename?: SortOrderInput | SortOrder
    profile_fullpath?: SortOrderInput | SortOrder
    main_pat_id?: SortOrderInput | SortOrder
    patient_dep_id?: SortOrderInput | SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
    _count?: referral_patient_detailsCountOrderByAggregateInput
    _avg?: referral_patient_detailsAvgOrderByAggregateInput
    _max?: referral_patient_detailsMaxOrderByAggregateInput
    _min?: referral_patient_detailsMinOrderByAggregateInput
    _sum?: referral_patient_detailsSumOrderByAggregateInput
  }

  export type referral_patient_detailsScalarWhereWithAggregatesInput = {
    AND?: referral_patient_detailsScalarWhereWithAggregatesInput | referral_patient_detailsScalarWhereWithAggregatesInput[]
    OR?: referral_patient_detailsScalarWhereWithAggregatesInput[]
    NOT?: referral_patient_detailsScalarWhereWithAggregatesInput | referral_patient_detailsScalarWhereWithAggregatesInput[]
    referral_patient_id?: IntWithAggregatesFilter<"referral_patient_details"> | number
    firstname?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    lastname?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    gender?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    date_of_birth?: DateTimeWithAggregatesFilter<"referral_patient_details"> | Date | string
    age?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    address?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    state?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    city?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    mailid?: StringWithAggregatesFilter<"referral_patient_details"> | string
    phonenum?: StringWithAggregatesFilter<"referral_patient_details"> | string
    alt_phonenum?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    password?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    relationship?: StringWithAggregatesFilter<"referral_patient_details"> | string
    created_on?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"referral_patient_details"> | Date | string | null
    active?: IntNullableWithAggregatesFilter<"referral_patient_details"> | number | null
    role_id?: IntWithAggregatesFilter<"referral_patient_details"> | number
    patient_unique_id?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    physician_id?: StringWithAggregatesFilter<"referral_patient_details"> | string
    status?: StringWithAggregatesFilter<"referral_patient_details"> | string
    r_count?: IntWithAggregatesFilter<"referral_patient_details"> | number
    profile_filename?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    profile_fullpath?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    main_pat_id?: StringNullableWithAggregatesFilter<"referral_patient_details"> | string | null
    patient_dep_id?: IntNullableWithAggregatesFilter<"referral_patient_details"> | number | null
    count?: IntWithAggregatesFilter<"referral_patient_details"> | number
    prescribe_receipt?: IntWithAggregatesFilter<"referral_patient_details"> | number
  }

  export type referral_patient_test_detailsWhereInput = {
    AND?: referral_patient_test_detailsWhereInput | referral_patient_test_detailsWhereInput[]
    OR?: referral_patient_test_detailsWhereInput[]
    NOT?: referral_patient_test_detailsWhereInput | referral_patient_test_detailsWhereInput[]
    ID?: IntFilter<"referral_patient_test_details"> | number
    medical_num?: StringNullableFilter<"referral_patient_test_details"> | string | null
    laboratory_tests?: StringNullableFilter<"referral_patient_test_details"> | string | null
    parse_parent_id?: IntFilter<"referral_patient_test_details"> | number
    has_child?: IntFilter<"referral_patient_test_details"> | number
    time?: StringNullableFilter<"referral_patient_test_details"> | string | null
    date?: DateTimeNullableFilter<"referral_patient_test_details"> | Date | string | null
    instruction?: StringNullableFilter<"referral_patient_test_details"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_patient_test_details"> | string | null
    physician_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    laboratory_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    dependent_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    main_patient_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    billing_id?: IntFilter<"referral_patient_test_details"> | number
    billing_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    sample_collected_id?: IntFilter<"referral_patient_test_details"> | number
    sample_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    labapproval_id?: IntFilter<"referral_patient_test_details"> | number
    labapproval_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    pat_status?: IntFilter<"referral_patient_test_details"> | number
    report_filename?: StringNullableFilter<"referral_patient_test_details"> | string | null
    report_fullpath?: StringNullableFilter<"referral_patient_test_details"> | string | null
    approved_lab_doc_id?: IntFilter<"referral_patient_test_details"> | number
    editor?: StringFilter<"referral_patient_test_details"> | string
    created_on?: DateTimeFilter<"referral_patient_test_details"> | Date | string
  }

  export type referral_patient_test_detailsOrderByWithRelationInput = {
    ID?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    laboratory_tests?: SortOrderInput | SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    time?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    instruction?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    physician_id?: SortOrderInput | SortOrder
    laboratory_id?: SortOrderInput | SortOrder
    dependent_id?: SortOrderInput | SortOrder
    main_patient_id?: SortOrderInput | SortOrder
    billing_id?: SortOrder
    billing_datetime?: SortOrder
    sample_collected_id?: SortOrder
    sample_datetime?: SortOrder
    labapproval_id?: SortOrder
    labapproval_datetime?: SortOrder
    pat_status?: SortOrder
    report_filename?: SortOrderInput | SortOrder
    report_fullpath?: SortOrderInput | SortOrder
    approved_lab_doc_id?: SortOrder
    editor?: SortOrder
    created_on?: SortOrder
  }

  export type referral_patient_test_detailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: referral_patient_test_detailsWhereInput | referral_patient_test_detailsWhereInput[]
    OR?: referral_patient_test_detailsWhereInput[]
    NOT?: referral_patient_test_detailsWhereInput | referral_patient_test_detailsWhereInput[]
    medical_num?: StringNullableFilter<"referral_patient_test_details"> | string | null
    laboratory_tests?: StringNullableFilter<"referral_patient_test_details"> | string | null
    parse_parent_id?: IntFilter<"referral_patient_test_details"> | number
    has_child?: IntFilter<"referral_patient_test_details"> | number
    time?: StringNullableFilter<"referral_patient_test_details"> | string | null
    date?: DateTimeNullableFilter<"referral_patient_test_details"> | Date | string | null
    instruction?: StringNullableFilter<"referral_patient_test_details"> | string | null
    patient_unique_id?: StringNullableFilter<"referral_patient_test_details"> | string | null
    physician_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    laboratory_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    dependent_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    main_patient_id?: IntNullableFilter<"referral_patient_test_details"> | number | null
    billing_id?: IntFilter<"referral_patient_test_details"> | number
    billing_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    sample_collected_id?: IntFilter<"referral_patient_test_details"> | number
    sample_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    labapproval_id?: IntFilter<"referral_patient_test_details"> | number
    labapproval_datetime?: DateTimeFilter<"referral_patient_test_details"> | Date | string
    pat_status?: IntFilter<"referral_patient_test_details"> | number
    report_filename?: StringNullableFilter<"referral_patient_test_details"> | string | null
    report_fullpath?: StringNullableFilter<"referral_patient_test_details"> | string | null
    approved_lab_doc_id?: IntFilter<"referral_patient_test_details"> | number
    editor?: StringFilter<"referral_patient_test_details"> | string
    created_on?: DateTimeFilter<"referral_patient_test_details"> | Date | string
  }, "ID">

  export type referral_patient_test_detailsOrderByWithAggregationInput = {
    ID?: SortOrder
    medical_num?: SortOrderInput | SortOrder
    laboratory_tests?: SortOrderInput | SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    time?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    instruction?: SortOrderInput | SortOrder
    patient_unique_id?: SortOrderInput | SortOrder
    physician_id?: SortOrderInput | SortOrder
    laboratory_id?: SortOrderInput | SortOrder
    dependent_id?: SortOrderInput | SortOrder
    main_patient_id?: SortOrderInput | SortOrder
    billing_id?: SortOrder
    billing_datetime?: SortOrder
    sample_collected_id?: SortOrder
    sample_datetime?: SortOrder
    labapproval_id?: SortOrder
    labapproval_datetime?: SortOrder
    pat_status?: SortOrder
    report_filename?: SortOrderInput | SortOrder
    report_fullpath?: SortOrderInput | SortOrder
    approved_lab_doc_id?: SortOrder
    editor?: SortOrder
    created_on?: SortOrder
    _count?: referral_patient_test_detailsCountOrderByAggregateInput
    _avg?: referral_patient_test_detailsAvgOrderByAggregateInput
    _max?: referral_patient_test_detailsMaxOrderByAggregateInput
    _min?: referral_patient_test_detailsMinOrderByAggregateInput
    _sum?: referral_patient_test_detailsSumOrderByAggregateInput
  }

  export type referral_patient_test_detailsScalarWhereWithAggregatesInput = {
    AND?: referral_patient_test_detailsScalarWhereWithAggregatesInput | referral_patient_test_detailsScalarWhereWithAggregatesInput[]
    OR?: referral_patient_test_detailsScalarWhereWithAggregatesInput[]
    NOT?: referral_patient_test_detailsScalarWhereWithAggregatesInput | referral_patient_test_detailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    medical_num?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    laboratory_tests?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    parse_parent_id?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    has_child?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    time?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"referral_patient_test_details"> | Date | string | null
    instruction?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    patient_unique_id?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    physician_id?: IntNullableWithAggregatesFilter<"referral_patient_test_details"> | number | null
    laboratory_id?: IntNullableWithAggregatesFilter<"referral_patient_test_details"> | number | null
    dependent_id?: IntNullableWithAggregatesFilter<"referral_patient_test_details"> | number | null
    main_patient_id?: IntNullableWithAggregatesFilter<"referral_patient_test_details"> | number | null
    billing_id?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    billing_datetime?: DateTimeWithAggregatesFilter<"referral_patient_test_details"> | Date | string
    sample_collected_id?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    sample_datetime?: DateTimeWithAggregatesFilter<"referral_patient_test_details"> | Date | string
    labapproval_id?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    labapproval_datetime?: DateTimeWithAggregatesFilter<"referral_patient_test_details"> | Date | string
    pat_status?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    report_filename?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    report_fullpath?: StringNullableWithAggregatesFilter<"referral_patient_test_details"> | string | null
    approved_lab_doc_id?: IntWithAggregatesFilter<"referral_patient_test_details"> | number
    editor?: StringWithAggregatesFilter<"referral_patient_test_details"> | string
    created_on?: DateTimeWithAggregatesFilter<"referral_patient_test_details"> | Date | string
  }

  export type relationshipWhereInput = {
    AND?: relationshipWhereInput | relationshipWhereInput[]
    OR?: relationshipWhereInput[]
    NOT?: relationshipWhereInput | relationshipWhereInput[]
    rel_id?: IntFilter<"relationship"> | number
    rel_name?: StringFilter<"relationship"> | string
    active?: IntFilter<"relationship"> | number
  }

  export type relationshipOrderByWithRelationInput = {
    rel_id?: SortOrder
    rel_name?: SortOrder
    active?: SortOrder
  }

  export type relationshipWhereUniqueInput = Prisma.AtLeast<{
    rel_id?: number
    AND?: relationshipWhereInput | relationshipWhereInput[]
    OR?: relationshipWhereInput[]
    NOT?: relationshipWhereInput | relationshipWhereInput[]
    rel_name?: StringFilter<"relationship"> | string
    active?: IntFilter<"relationship"> | number
  }, "rel_id">

  export type relationshipOrderByWithAggregationInput = {
    rel_id?: SortOrder
    rel_name?: SortOrder
    active?: SortOrder
    _count?: relationshipCountOrderByAggregateInput
    _avg?: relationshipAvgOrderByAggregateInput
    _max?: relationshipMaxOrderByAggregateInput
    _min?: relationshipMinOrderByAggregateInput
    _sum?: relationshipSumOrderByAggregateInput
  }

  export type relationshipScalarWhereWithAggregatesInput = {
    AND?: relationshipScalarWhereWithAggregatesInput | relationshipScalarWhereWithAggregatesInput[]
    OR?: relationshipScalarWhereWithAggregatesInput[]
    NOT?: relationshipScalarWhereWithAggregatesInput | relationshipScalarWhereWithAggregatesInput[]
    rel_id?: IntWithAggregatesFilter<"relationship"> | number
    rel_name?: StringWithAggregatesFilter<"relationship"> | string
    active?: IntWithAggregatesFilter<"relationship"> | number
  }

  export type report_templateWhereInput = {
    AND?: report_templateWhereInput | report_templateWhereInput[]
    OR?: report_templateWhereInput[]
    NOT?: report_templateWhereInput | report_templateWhereInput[]
    template_id?: IntFilter<"report_template"> | number
    header?: IntFilter<"report_template"> | number
    footer?: IntFilter<"report_template"> | number
    print_size?: IntFilter<"report_template"> | number
    lab_id?: IntFilter<"report_template"> | number
    created_on?: StringFilter<"report_template"> | string
    status?: StringFilter<"report_template"> | string
  }

  export type report_templateOrderByWithRelationInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
    created_on?: SortOrder
    status?: SortOrder
  }

  export type report_templateWhereUniqueInput = Prisma.AtLeast<{
    template_id?: number
    AND?: report_templateWhereInput | report_templateWhereInput[]
    OR?: report_templateWhereInput[]
    NOT?: report_templateWhereInput | report_templateWhereInput[]
    header?: IntFilter<"report_template"> | number
    footer?: IntFilter<"report_template"> | number
    print_size?: IntFilter<"report_template"> | number
    lab_id?: IntFilter<"report_template"> | number
    created_on?: StringFilter<"report_template"> | string
    status?: StringFilter<"report_template"> | string
  }, "template_id">

  export type report_templateOrderByWithAggregationInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
    created_on?: SortOrder
    status?: SortOrder
    _count?: report_templateCountOrderByAggregateInput
    _avg?: report_templateAvgOrderByAggregateInput
    _max?: report_templateMaxOrderByAggregateInput
    _min?: report_templateMinOrderByAggregateInput
    _sum?: report_templateSumOrderByAggregateInput
  }

  export type report_templateScalarWhereWithAggregatesInput = {
    AND?: report_templateScalarWhereWithAggregatesInput | report_templateScalarWhereWithAggregatesInput[]
    OR?: report_templateScalarWhereWithAggregatesInput[]
    NOT?: report_templateScalarWhereWithAggregatesInput | report_templateScalarWhereWithAggregatesInput[]
    template_id?: IntWithAggregatesFilter<"report_template"> | number
    header?: IntWithAggregatesFilter<"report_template"> | number
    footer?: IntWithAggregatesFilter<"report_template"> | number
    print_size?: IntWithAggregatesFilter<"report_template"> | number
    lab_id?: IntWithAggregatesFilter<"report_template"> | number
    created_on?: StringWithAggregatesFilter<"report_template"> | string
    status?: StringWithAggregatesFilter<"report_template"> | string
  }

  export type sample_resultsWhereInput = {
    AND?: sample_resultsWhereInput | sample_resultsWhereInput[]
    OR?: sample_resultsWhereInput[]
    NOT?: sample_resultsWhereInput | sample_resultsWhereInput[]
    result_id?: IntFilter<"sample_results"> | number
    sample_value?: StringFilter<"sample_results"> | string
    referral_test_ID?: IntFilter<"sample_results"> | number
    created_on?: DateTimeFilter<"sample_results"> | Date | string
  }

  export type sample_resultsOrderByWithRelationInput = {
    result_id?: SortOrder
    sample_value?: SortOrder
    referral_test_ID?: SortOrder
    created_on?: SortOrder
  }

  export type sample_resultsWhereUniqueInput = Prisma.AtLeast<{
    result_id?: number
    AND?: sample_resultsWhereInput | sample_resultsWhereInput[]
    OR?: sample_resultsWhereInput[]
    NOT?: sample_resultsWhereInput | sample_resultsWhereInput[]
    sample_value?: StringFilter<"sample_results"> | string
    referral_test_ID?: IntFilter<"sample_results"> | number
    created_on?: DateTimeFilter<"sample_results"> | Date | string
  }, "result_id">

  export type sample_resultsOrderByWithAggregationInput = {
    result_id?: SortOrder
    sample_value?: SortOrder
    referral_test_ID?: SortOrder
    created_on?: SortOrder
    _count?: sample_resultsCountOrderByAggregateInput
    _avg?: sample_resultsAvgOrderByAggregateInput
    _max?: sample_resultsMaxOrderByAggregateInput
    _min?: sample_resultsMinOrderByAggregateInput
    _sum?: sample_resultsSumOrderByAggregateInput
  }

  export type sample_resultsScalarWhereWithAggregatesInput = {
    AND?: sample_resultsScalarWhereWithAggregatesInput | sample_resultsScalarWhereWithAggregatesInput[]
    OR?: sample_resultsScalarWhereWithAggregatesInput[]
    NOT?: sample_resultsScalarWhereWithAggregatesInput | sample_resultsScalarWhereWithAggregatesInput[]
    result_id?: IntWithAggregatesFilter<"sample_results"> | number
    sample_value?: StringWithAggregatesFilter<"sample_results"> | string
    referral_test_ID?: IntWithAggregatesFilter<"sample_results"> | number
    created_on?: DateTimeWithAggregatesFilter<"sample_results"> | Date | string
  }

  export type ssconsultation_billingWhereInput = {
    AND?: ssconsultation_billingWhereInput | ssconsultation_billingWhereInput[]
    OR?: ssconsultation_billingWhereInput[]
    NOT?: ssconsultation_billingWhereInput | ssconsultation_billingWhereInput[]
    ssbilling_id?: IntFilter<"ssconsultation_billing"> | number
    ss_id?: IntFilter<"ssconsultation_billing"> | number
    tot_amt?: StringNullableFilter<"ssconsultation_billing"> | string | null
    lab_id?: IntFilter<"ssconsultation_billing"> | number
    unique_billid?: StringFilter<"ssconsultation_billing"> | string
    created_on?: StringNullableFilter<"ssconsultation_billing"> | string | null
  }

  export type ssconsultation_billingOrderByWithRelationInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    tot_amt?: SortOrderInput | SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrderInput | SortOrder
  }

  export type ssconsultation_billingWhereUniqueInput = Prisma.AtLeast<{
    ssbilling_id?: number
    AND?: ssconsultation_billingWhereInput | ssconsultation_billingWhereInput[]
    OR?: ssconsultation_billingWhereInput[]
    NOT?: ssconsultation_billingWhereInput | ssconsultation_billingWhereInput[]
    ss_id?: IntFilter<"ssconsultation_billing"> | number
    tot_amt?: StringNullableFilter<"ssconsultation_billing"> | string | null
    lab_id?: IntFilter<"ssconsultation_billing"> | number
    unique_billid?: StringFilter<"ssconsultation_billing"> | string
    created_on?: StringNullableFilter<"ssconsultation_billing"> | string | null
  }, "ssbilling_id">

  export type ssconsultation_billingOrderByWithAggregationInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    tot_amt?: SortOrderInput | SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrderInput | SortOrder
    _count?: ssconsultation_billingCountOrderByAggregateInput
    _avg?: ssconsultation_billingAvgOrderByAggregateInput
    _max?: ssconsultation_billingMaxOrderByAggregateInput
    _min?: ssconsultation_billingMinOrderByAggregateInput
    _sum?: ssconsultation_billingSumOrderByAggregateInput
  }

  export type ssconsultation_billingScalarWhereWithAggregatesInput = {
    AND?: ssconsultation_billingScalarWhereWithAggregatesInput | ssconsultation_billingScalarWhereWithAggregatesInput[]
    OR?: ssconsultation_billingScalarWhereWithAggregatesInput[]
    NOT?: ssconsultation_billingScalarWhereWithAggregatesInput | ssconsultation_billingScalarWhereWithAggregatesInput[]
    ssbilling_id?: IntWithAggregatesFilter<"ssconsultation_billing"> | number
    ss_id?: IntWithAggregatesFilter<"ssconsultation_billing"> | number
    tot_amt?: StringNullableWithAggregatesFilter<"ssconsultation_billing"> | string | null
    lab_id?: IntWithAggregatesFilter<"ssconsultation_billing"> | number
    unique_billid?: StringWithAggregatesFilter<"ssconsultation_billing"> | string
    created_on?: StringNullableWithAggregatesFilter<"ssconsultation_billing"> | string | null
  }

  export type ssconsultation_logWhereInput = {
    AND?: ssconsultation_logWhereInput | ssconsultation_logWhereInput[]
    OR?: ssconsultation_logWhereInput[]
    NOT?: ssconsultation_logWhereInput | ssconsultation_logWhereInput[]
    ssconsultation_log_id?: IntFilter<"ssconsultation_log"> | number
    ssbilling_id?: IntFilter<"ssconsultation_log"> | number
    amt?: StringFilter<"ssconsultation_log"> | string
    payment_method?: IntFilter<"ssconsultation_log"> | number
    added_date?: DateTimeFilter<"ssconsultation_log"> | Date | string
  }

  export type ssconsultation_logOrderByWithRelationInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type ssconsultation_logWhereUniqueInput = Prisma.AtLeast<{
    ssconsultation_log_id?: number
    AND?: ssconsultation_logWhereInput | ssconsultation_logWhereInput[]
    OR?: ssconsultation_logWhereInput[]
    NOT?: ssconsultation_logWhereInput | ssconsultation_logWhereInput[]
    ssbilling_id?: IntFilter<"ssconsultation_log"> | number
    amt?: StringFilter<"ssconsultation_log"> | string
    payment_method?: IntFilter<"ssconsultation_log"> | number
    added_date?: DateTimeFilter<"ssconsultation_log"> | Date | string
  }, "ssconsultation_log_id">

  export type ssconsultation_logOrderByWithAggregationInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
    _count?: ssconsultation_logCountOrderByAggregateInput
    _avg?: ssconsultation_logAvgOrderByAggregateInput
    _max?: ssconsultation_logMaxOrderByAggregateInput
    _min?: ssconsultation_logMinOrderByAggregateInput
    _sum?: ssconsultation_logSumOrderByAggregateInput
  }

  export type ssconsultation_logScalarWhereWithAggregatesInput = {
    AND?: ssconsultation_logScalarWhereWithAggregatesInput | ssconsultation_logScalarWhereWithAggregatesInput[]
    OR?: ssconsultation_logScalarWhereWithAggregatesInput[]
    NOT?: ssconsultation_logScalarWhereWithAggregatesInput | ssconsultation_logScalarWhereWithAggregatesInput[]
    ssconsultation_log_id?: IntWithAggregatesFilter<"ssconsultation_log"> | number
    ssbilling_id?: IntWithAggregatesFilter<"ssconsultation_log"> | number
    amt?: StringWithAggregatesFilter<"ssconsultation_log"> | string
    payment_method?: IntWithAggregatesFilter<"ssconsultation_log"> | number
    added_date?: DateTimeWithAggregatesFilter<"ssconsultation_log"> | Date | string
  }

  export type stateWhereInput = {
    AND?: stateWhereInput | stateWhereInput[]
    OR?: stateWhereInput[]
    NOT?: stateWhereInput | stateWhereInput[]
    state_id?: IntFilter<"state"> | number
    state_name?: StringFilter<"state"> | string
    country_id?: IntFilter<"state"> | number
    active?: BoolFilter<"state"> | boolean
  }

  export type stateOrderByWithRelationInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    country_id?: SortOrder
    active?: SortOrder
  }

  export type stateWhereUniqueInput = Prisma.AtLeast<{
    state_id?: number
    AND?: stateWhereInput | stateWhereInput[]
    OR?: stateWhereInput[]
    NOT?: stateWhereInput | stateWhereInput[]
    state_name?: StringFilter<"state"> | string
    country_id?: IntFilter<"state"> | number
    active?: BoolFilter<"state"> | boolean
  }, "state_id">

  export type stateOrderByWithAggregationInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    country_id?: SortOrder
    active?: SortOrder
    _count?: stateCountOrderByAggregateInput
    _avg?: stateAvgOrderByAggregateInput
    _max?: stateMaxOrderByAggregateInput
    _min?: stateMinOrderByAggregateInput
    _sum?: stateSumOrderByAggregateInput
  }

  export type stateScalarWhereWithAggregatesInput = {
    AND?: stateScalarWhereWithAggregatesInput | stateScalarWhereWithAggregatesInput[]
    OR?: stateScalarWhereWithAggregatesInput[]
    NOT?: stateScalarWhereWithAggregatesInput | stateScalarWhereWithAggregatesInput[]
    state_id?: IntWithAggregatesFilter<"state"> | number
    state_name?: StringWithAggregatesFilter<"state"> | string
    country_id?: IntWithAggregatesFilter<"state"> | number
    active?: BoolWithAggregatesFilter<"state"> | boolean
  }

  export type status_masterWhereInput = {
    AND?: status_masterWhereInput | status_masterWhereInput[]
    OR?: status_masterWhereInput[]
    NOT?: status_masterWhereInput | status_masterWhereInput[]
    status_id?: IntFilter<"status_master"> | number
    status?: StringFilter<"status_master"> | string
  }

  export type status_masterOrderByWithRelationInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type status_masterWhereUniqueInput = Prisma.AtLeast<{
    status_id?: number
    AND?: status_masterWhereInput | status_masterWhereInput[]
    OR?: status_masterWhereInput[]
    NOT?: status_masterWhereInput | status_masterWhereInput[]
    status?: StringFilter<"status_master"> | string
  }, "status_id">

  export type status_masterOrderByWithAggregationInput = {
    status_id?: SortOrder
    status?: SortOrder
    _count?: status_masterCountOrderByAggregateInput
    _avg?: status_masterAvgOrderByAggregateInput
    _max?: status_masterMaxOrderByAggregateInput
    _min?: status_masterMinOrderByAggregateInput
    _sum?: status_masterSumOrderByAggregateInput
  }

  export type status_masterScalarWhereWithAggregatesInput = {
    AND?: status_masterScalarWhereWithAggregatesInput | status_masterScalarWhereWithAggregatesInput[]
    OR?: status_masterScalarWhereWithAggregatesInput[]
    NOT?: status_masterScalarWhereWithAggregatesInput | status_masterScalarWhereWithAggregatesInput[]
    status_id?: IntWithAggregatesFilter<"status_master"> | number
    status?: StringWithAggregatesFilter<"status_master"> | string
  }

  export type super_specialityWhereInput = {
    AND?: super_specialityWhereInput | super_specialityWhereInput[]
    OR?: super_specialityWhereInput[]
    NOT?: super_specialityWhereInput | super_specialityWhereInput[]
    superspeciality_id?: IntFilter<"super_speciality"> | number
    superspeciality_name?: StringNullableFilter<"super_speciality"> | string | null
    created_on?: DateTimeNullableFilter<"super_speciality"> | Date | string | null
    active?: IntFilter<"super_speciality"> | number
  }

  export type super_specialityOrderByWithRelationInput = {
    superspeciality_id?: SortOrder
    superspeciality_name?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    active?: SortOrder
  }

  export type super_specialityWhereUniqueInput = Prisma.AtLeast<{
    superspeciality_id?: number
    AND?: super_specialityWhereInput | super_specialityWhereInput[]
    OR?: super_specialityWhereInput[]
    NOT?: super_specialityWhereInput | super_specialityWhereInput[]
    superspeciality_name?: StringNullableFilter<"super_speciality"> | string | null
    created_on?: DateTimeNullableFilter<"super_speciality"> | Date | string | null
    active?: IntFilter<"super_speciality"> | number
  }, "superspeciality_id">

  export type super_specialityOrderByWithAggregationInput = {
    superspeciality_id?: SortOrder
    superspeciality_name?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: super_specialityCountOrderByAggregateInput
    _avg?: super_specialityAvgOrderByAggregateInput
    _max?: super_specialityMaxOrderByAggregateInput
    _min?: super_specialityMinOrderByAggregateInput
    _sum?: super_specialitySumOrderByAggregateInput
  }

  export type super_specialityScalarWhereWithAggregatesInput = {
    AND?: super_specialityScalarWhereWithAggregatesInput | super_specialityScalarWhereWithAggregatesInput[]
    OR?: super_specialityScalarWhereWithAggregatesInput[]
    NOT?: super_specialityScalarWhereWithAggregatesInput | super_specialityScalarWhereWithAggregatesInput[]
    superspeciality_id?: IntWithAggregatesFilter<"super_speciality"> | number
    superspeciality_name?: StringNullableWithAggregatesFilter<"super_speciality"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"super_speciality"> | Date | string | null
    active?: IntWithAggregatesFilter<"super_speciality"> | number
  }

  export type superspeciality_consultationWhereInput = {
    AND?: superspeciality_consultationWhereInput | superspeciality_consultationWhereInput[]
    OR?: superspeciality_consultationWhereInput[]
    NOT?: superspeciality_consultationWhereInput | superspeciality_consultationWhereInput[]
    ss_id?: IntFilter<"superspeciality_consultation"> | number
    laboratory_id?: IntFilter<"superspeciality_consultation"> | number
    referral_patient_id?: IntFilter<"superspeciality_consultation"> | number
    patient_dep_id?: IntFilter<"superspeciality_consultation"> | number
    superspeciality_id?: IntFilter<"superspeciality_consultation"> | number
    comments?: StringFilter<"superspeciality_consultation"> | string
    by_assign?: IntFilter<"superspeciality_consultation"> | number
    to_assign?: IntFilter<"superspeciality_consultation"> | number
    referdate?: DateTimeFilter<"superspeciality_consultation"> | Date | string
    refertime?: StringFilter<"superspeciality_consultation"> | string
    referclinic_name?: StringFilter<"superspeciality_consultation"> | string
    consultationId?: IntFilter<"superspeciality_consultation"> | number
    consultationDate?: DateTimeNullableFilter<"superspeciality_consultation"> | Date | string | null
    consultationAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    miscellaneousAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    totalAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    status?: IntFilter<"superspeciality_consultation"> | number
  }

  export type superspeciality_consultationOrderByWithRelationInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    consultationId?: SortOrder
    consultationDate?: SortOrderInput | SortOrder
    consultationAmount?: SortOrderInput | SortOrder
    miscellaneousAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    status?: SortOrder
  }

  export type superspeciality_consultationWhereUniqueInput = Prisma.AtLeast<{
    ss_id?: number
    AND?: superspeciality_consultationWhereInput | superspeciality_consultationWhereInput[]
    OR?: superspeciality_consultationWhereInput[]
    NOT?: superspeciality_consultationWhereInput | superspeciality_consultationWhereInput[]
    laboratory_id?: IntFilter<"superspeciality_consultation"> | number
    referral_patient_id?: IntFilter<"superspeciality_consultation"> | number
    patient_dep_id?: IntFilter<"superspeciality_consultation"> | number
    superspeciality_id?: IntFilter<"superspeciality_consultation"> | number
    comments?: StringFilter<"superspeciality_consultation"> | string
    by_assign?: IntFilter<"superspeciality_consultation"> | number
    to_assign?: IntFilter<"superspeciality_consultation"> | number
    referdate?: DateTimeFilter<"superspeciality_consultation"> | Date | string
    refertime?: StringFilter<"superspeciality_consultation"> | string
    referclinic_name?: StringFilter<"superspeciality_consultation"> | string
    consultationId?: IntFilter<"superspeciality_consultation"> | number
    consultationDate?: DateTimeNullableFilter<"superspeciality_consultation"> | Date | string | null
    consultationAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    miscellaneousAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    totalAmount?: IntNullableFilter<"superspeciality_consultation"> | number | null
    status?: IntFilter<"superspeciality_consultation"> | number
  }, "ss_id">

  export type superspeciality_consultationOrderByWithAggregationInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    consultationId?: SortOrder
    consultationDate?: SortOrderInput | SortOrder
    consultationAmount?: SortOrderInput | SortOrder
    miscellaneousAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: superspeciality_consultationCountOrderByAggregateInput
    _avg?: superspeciality_consultationAvgOrderByAggregateInput
    _max?: superspeciality_consultationMaxOrderByAggregateInput
    _min?: superspeciality_consultationMinOrderByAggregateInput
    _sum?: superspeciality_consultationSumOrderByAggregateInput
  }

  export type superspeciality_consultationScalarWhereWithAggregatesInput = {
    AND?: superspeciality_consultationScalarWhereWithAggregatesInput | superspeciality_consultationScalarWhereWithAggregatesInput[]
    OR?: superspeciality_consultationScalarWhereWithAggregatesInput[]
    NOT?: superspeciality_consultationScalarWhereWithAggregatesInput | superspeciality_consultationScalarWhereWithAggregatesInput[]
    ss_id?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    laboratory_id?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    referral_patient_id?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    patient_dep_id?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    superspeciality_id?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    comments?: StringWithAggregatesFilter<"superspeciality_consultation"> | string
    by_assign?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    to_assign?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    referdate?: DateTimeWithAggregatesFilter<"superspeciality_consultation"> | Date | string
    refertime?: StringWithAggregatesFilter<"superspeciality_consultation"> | string
    referclinic_name?: StringWithAggregatesFilter<"superspeciality_consultation"> | string
    consultationId?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
    consultationDate?: DateTimeNullableWithAggregatesFilter<"superspeciality_consultation"> | Date | string | null
    consultationAmount?: IntNullableWithAggregatesFilter<"superspeciality_consultation"> | number | null
    miscellaneousAmount?: IntNullableWithAggregatesFilter<"superspeciality_consultation"> | number | null
    totalAmount?: IntNullableWithAggregatesFilter<"superspeciality_consultation"> | number | null
    status?: IntWithAggregatesFilter<"superspeciality_consultation"> | number
  }

  export type superspeciality_detailsWhereInput = {
    AND?: superspeciality_detailsWhereInput | superspeciality_detailsWhereInput[]
    OR?: superspeciality_detailsWhereInput[]
    NOT?: superspeciality_detailsWhereInput | superspeciality_detailsWhereInput[]
    speciality_id?: IntFilter<"superspeciality_details"> | number
    referral_patient_id?: IntNullableFilter<"superspeciality_details"> | number | null
    patient_dep_id?: IntNullableFilter<"superspeciality_details"> | number | null
    superspeciality_id?: IntNullableFilter<"superspeciality_details"> | number | null
    comments?: StringNullableFilter<"superspeciality_details"> | string | null
    by_assign?: IntNullableFilter<"superspeciality_details"> | number | null
    to_assign?: IntNullableFilter<"superspeciality_details"> | number | null
    referdate?: DateTimeNullableFilter<"superspeciality_details"> | Date | string | null
    refertime?: StringNullableFilter<"superspeciality_details"> | string | null
    referclinic_name?: StringNullableFilter<"superspeciality_details"> | string | null
    created_on?: DateTimeFilter<"superspeciality_details"> | Date | string
    active?: IntFilter<"superspeciality_details"> | number
    laboratory_id?: IntFilter<"superspeciality_details"> | number
  }

  export type superspeciality_detailsOrderByWithRelationInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrderInput | SortOrder
    patient_dep_id?: SortOrderInput | SortOrder
    superspeciality_id?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    by_assign?: SortOrderInput | SortOrder
    to_assign?: SortOrderInput | SortOrder
    referdate?: SortOrderInput | SortOrder
    refertime?: SortOrderInput | SortOrder
    referclinic_name?: SortOrderInput | SortOrder
    created_on?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type superspeciality_detailsWhereUniqueInput = Prisma.AtLeast<{
    speciality_id?: number
    AND?: superspeciality_detailsWhereInput | superspeciality_detailsWhereInput[]
    OR?: superspeciality_detailsWhereInput[]
    NOT?: superspeciality_detailsWhereInput | superspeciality_detailsWhereInput[]
    referral_patient_id?: IntNullableFilter<"superspeciality_details"> | number | null
    patient_dep_id?: IntNullableFilter<"superspeciality_details"> | number | null
    superspeciality_id?: IntNullableFilter<"superspeciality_details"> | number | null
    comments?: StringNullableFilter<"superspeciality_details"> | string | null
    by_assign?: IntNullableFilter<"superspeciality_details"> | number | null
    to_assign?: IntNullableFilter<"superspeciality_details"> | number | null
    referdate?: DateTimeNullableFilter<"superspeciality_details"> | Date | string | null
    refertime?: StringNullableFilter<"superspeciality_details"> | string | null
    referclinic_name?: StringNullableFilter<"superspeciality_details"> | string | null
    created_on?: DateTimeFilter<"superspeciality_details"> | Date | string
    active?: IntFilter<"superspeciality_details"> | number
    laboratory_id?: IntFilter<"superspeciality_details"> | number
  }, "speciality_id">

  export type superspeciality_detailsOrderByWithAggregationInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrderInput | SortOrder
    patient_dep_id?: SortOrderInput | SortOrder
    superspeciality_id?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    by_assign?: SortOrderInput | SortOrder
    to_assign?: SortOrderInput | SortOrder
    referdate?: SortOrderInput | SortOrder
    refertime?: SortOrderInput | SortOrder
    referclinic_name?: SortOrderInput | SortOrder
    created_on?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
    _count?: superspeciality_detailsCountOrderByAggregateInput
    _avg?: superspeciality_detailsAvgOrderByAggregateInput
    _max?: superspeciality_detailsMaxOrderByAggregateInput
    _min?: superspeciality_detailsMinOrderByAggregateInput
    _sum?: superspeciality_detailsSumOrderByAggregateInput
  }

  export type superspeciality_detailsScalarWhereWithAggregatesInput = {
    AND?: superspeciality_detailsScalarWhereWithAggregatesInput | superspeciality_detailsScalarWhereWithAggregatesInput[]
    OR?: superspeciality_detailsScalarWhereWithAggregatesInput[]
    NOT?: superspeciality_detailsScalarWhereWithAggregatesInput | superspeciality_detailsScalarWhereWithAggregatesInput[]
    speciality_id?: IntWithAggregatesFilter<"superspeciality_details"> | number
    referral_patient_id?: IntNullableWithAggregatesFilter<"superspeciality_details"> | number | null
    patient_dep_id?: IntNullableWithAggregatesFilter<"superspeciality_details"> | number | null
    superspeciality_id?: IntNullableWithAggregatesFilter<"superspeciality_details"> | number | null
    comments?: StringNullableWithAggregatesFilter<"superspeciality_details"> | string | null
    by_assign?: IntNullableWithAggregatesFilter<"superspeciality_details"> | number | null
    to_assign?: IntNullableWithAggregatesFilter<"superspeciality_details"> | number | null
    referdate?: DateTimeNullableWithAggregatesFilter<"superspeciality_details"> | Date | string | null
    refertime?: StringNullableWithAggregatesFilter<"superspeciality_details"> | string | null
    referclinic_name?: StringNullableWithAggregatesFilter<"superspeciality_details"> | string | null
    created_on?: DateTimeWithAggregatesFilter<"superspeciality_details"> | Date | string
    active?: IntWithAggregatesFilter<"superspeciality_details"> | number
    laboratory_id?: IntWithAggregatesFilter<"superspeciality_details"> | number
  }

  export type test_report_notesWhereInput = {
    AND?: test_report_notesWhereInput | test_report_notesWhereInput[]
    OR?: test_report_notesWhereInput[]
    NOT?: test_report_notesWhereInput | test_report_notesWhereInput[]
    test_report_notes_id?: IntFilter<"test_report_notes"> | number
    laboratory_tests?: StringFilter<"test_report_notes"> | string
    medical_num?: StringFilter<"test_report_notes"> | string
    referral_patient_test_details_id?: IntFilter<"test_report_notes"> | number
    title?: StringNullableFilter<"test_report_notes"> | string | null
    description?: StringFilter<"test_report_notes"> | string
    added_date?: DateTimeFilter<"test_report_notes"> | Date | string
  }

  export type test_report_notesOrderByWithRelationInput = {
    test_report_notes_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    referral_patient_test_details_id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    added_date?: SortOrder
  }

  export type test_report_notesWhereUniqueInput = Prisma.AtLeast<{
    test_report_notes_id?: number
    AND?: test_report_notesWhereInput | test_report_notesWhereInput[]
    OR?: test_report_notesWhereInput[]
    NOT?: test_report_notesWhereInput | test_report_notesWhereInput[]
    laboratory_tests?: StringFilter<"test_report_notes"> | string
    medical_num?: StringFilter<"test_report_notes"> | string
    referral_patient_test_details_id?: IntFilter<"test_report_notes"> | number
    title?: StringNullableFilter<"test_report_notes"> | string | null
    description?: StringFilter<"test_report_notes"> | string
    added_date?: DateTimeFilter<"test_report_notes"> | Date | string
  }, "test_report_notes_id">

  export type test_report_notesOrderByWithAggregationInput = {
    test_report_notes_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    referral_patient_test_details_id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    added_date?: SortOrder
    _count?: test_report_notesCountOrderByAggregateInput
    _avg?: test_report_notesAvgOrderByAggregateInput
    _max?: test_report_notesMaxOrderByAggregateInput
    _min?: test_report_notesMinOrderByAggregateInput
    _sum?: test_report_notesSumOrderByAggregateInput
  }

  export type test_report_notesScalarWhereWithAggregatesInput = {
    AND?: test_report_notesScalarWhereWithAggregatesInput | test_report_notesScalarWhereWithAggregatesInput[]
    OR?: test_report_notesScalarWhereWithAggregatesInput[]
    NOT?: test_report_notesScalarWhereWithAggregatesInput | test_report_notesScalarWhereWithAggregatesInput[]
    test_report_notes_id?: IntWithAggregatesFilter<"test_report_notes"> | number
    laboratory_tests?: StringWithAggregatesFilter<"test_report_notes"> | string
    medical_num?: StringWithAggregatesFilter<"test_report_notes"> | string
    referral_patient_test_details_id?: IntWithAggregatesFilter<"test_report_notes"> | number
    title?: StringNullableWithAggregatesFilter<"test_report_notes"> | string | null
    description?: StringWithAggregatesFilter<"test_report_notes"> | string
    added_date?: DateTimeWithAggregatesFilter<"test_report_notes"> | Date | string
  }

  export type update_labsWhereInput = {
    AND?: update_labsWhereInput | update_labsWhereInput[]
    OR?: update_labsWhereInput[]
    NOT?: update_labsWhereInput | update_labsWhereInput[]
    update_labid?: IntFilter<"update_labs"> | number
    laboratory_id?: IntFilter<"update_labs"> | number
    phonenum_doesnt_exist?: IntFilter<"update_labs"> | number
    print_billing?: IntFilter<"update_labs"> | number
    collection_report?: IntFilter<"update_labs"> | number
    test_report?: IntFilter<"update_labs"> | number
    active?: IntFilter<"update_labs"> | number
  }

  export type update_labsOrderByWithRelationInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type update_labsWhereUniqueInput = Prisma.AtLeast<{
    update_labid?: number
    AND?: update_labsWhereInput | update_labsWhereInput[]
    OR?: update_labsWhereInput[]
    NOT?: update_labsWhereInput | update_labsWhereInput[]
    laboratory_id?: IntFilter<"update_labs"> | number
    phonenum_doesnt_exist?: IntFilter<"update_labs"> | number
    print_billing?: IntFilter<"update_labs"> | number
    collection_report?: IntFilter<"update_labs"> | number
    test_report?: IntFilter<"update_labs"> | number
    active?: IntFilter<"update_labs"> | number
  }, "update_labid">

  export type update_labsOrderByWithAggregationInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
    _count?: update_labsCountOrderByAggregateInput
    _avg?: update_labsAvgOrderByAggregateInput
    _max?: update_labsMaxOrderByAggregateInput
    _min?: update_labsMinOrderByAggregateInput
    _sum?: update_labsSumOrderByAggregateInput
  }

  export type update_labsScalarWhereWithAggregatesInput = {
    AND?: update_labsScalarWhereWithAggregatesInput | update_labsScalarWhereWithAggregatesInput[]
    OR?: update_labsScalarWhereWithAggregatesInput[]
    NOT?: update_labsScalarWhereWithAggregatesInput | update_labsScalarWhereWithAggregatesInput[]
    update_labid?: IntWithAggregatesFilter<"update_labs"> | number
    laboratory_id?: IntWithAggregatesFilter<"update_labs"> | number
    phonenum_doesnt_exist?: IntWithAggregatesFilter<"update_labs"> | number
    print_billing?: IntWithAggregatesFilter<"update_labs"> | number
    collection_report?: IntWithAggregatesFilter<"update_labs"> | number
    test_report?: IntWithAggregatesFilter<"update_labs"> | number
    active?: IntWithAggregatesFilter<"update_labs"> | number
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    role_id?: IntFilter<"user"> | number
    name?: StringFilter<"user"> | string
    active?: IntFilter<"user"> | number
    created_on?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    role_id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    created_on?: SortOrder
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    active?: IntFilter<"user"> | number
    created_on?: DateTimeFilter<"user"> | Date | string
  }, "role_id">

  export type userOrderByWithAggregationInput = {
    role_id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    created_on?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"user"> | number
    name?: StringWithAggregatesFilter<"user"> | string
    active?: IntWithAggregatesFilter<"user"> | number
    created_on?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type barcodeCreateInput = {
    billing_id: number
    barcode: string
    barcode_image: string
    created_date: Date | string
  }

  export type barcodeUncheckedCreateInput = {
    barcode_id?: number
    billing_id: number
    barcode: string
    barcode_image: string
    created_date: Date | string
  }

  export type barcodeUpdateInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    barcode_image?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeUncheckedUpdateInput = {
    barcode_id?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    barcode_image?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeCreateManyInput = {
    barcode_id?: number
    billing_id: number
    barcode: string
    barcode_image: string
    created_date: Date | string
  }

  export type barcodeUpdateManyMutationInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    barcode_image?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type barcodeUncheckedUpdateManyInput = {
    barcode_id?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    barcode_image?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billingCreateInput = {
    laboratory_tests: string
    medical_num?: string | null
    patient_unique_id?: string | null
    tot_amt?: string | null
    discount?: string | null
    discount_type: number
    net_amt?: string | null
    adv_amt: string
    balance_amt: string
    balance_pymnt2: string
    final_balance: string
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type billingUncheckedCreateInput = {
    billing_id?: number
    laboratory_tests: string
    medical_num?: string | null
    patient_unique_id?: string | null
    tot_amt?: string | null
    discount?: string | null
    discount_type: number
    net_amt?: string | null
    adv_amt: string
    balance_amt: string
    balance_pymnt2: string
    final_balance: string
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type billingUpdateInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: IntFieldUpdateOperationsInput | number
    net_amt?: NullableStringFieldUpdateOperationsInput | string | null
    adv_amt?: StringFieldUpdateOperationsInput | string
    balance_amt?: StringFieldUpdateOperationsInput | string
    balance_pymnt2?: StringFieldUpdateOperationsInput | string
    final_balance?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type billingUncheckedUpdateInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: IntFieldUpdateOperationsInput | number
    net_amt?: NullableStringFieldUpdateOperationsInput | string | null
    adv_amt?: StringFieldUpdateOperationsInput | string
    balance_amt?: StringFieldUpdateOperationsInput | string
    balance_pymnt2?: StringFieldUpdateOperationsInput | string
    final_balance?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type billingCreateManyInput = {
    billing_id?: number
    laboratory_tests: string
    medical_num?: string | null
    patient_unique_id?: string | null
    tot_amt?: string | null
    discount?: string | null
    discount_type: number
    net_amt?: string | null
    adv_amt: string
    balance_amt: string
    balance_pymnt2: string
    final_balance: string
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type billingUpdateManyMutationInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: IntFieldUpdateOperationsInput | number
    net_amt?: NullableStringFieldUpdateOperationsInput | string | null
    adv_amt?: StringFieldUpdateOperationsInput | string
    balance_amt?: StringFieldUpdateOperationsInput | string
    balance_pymnt2?: StringFieldUpdateOperationsInput | string
    final_balance?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type billingUncheckedUpdateManyInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: IntFieldUpdateOperationsInput | number
    net_amt?: NullableStringFieldUpdateOperationsInput | string | null
    adv_amt?: StringFieldUpdateOperationsInput | string
    balance_amt?: StringFieldUpdateOperationsInput | string
    balance_pymnt2?: StringFieldUpdateOperationsInput | string
    final_balance?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type billing_logCreateInput = {
    billing_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type billing_logUncheckedCreateInput = {
    billing_log_id?: number
    billing_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type billing_logUpdateInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billing_logUncheckedUpdateInput = {
    billing_log_id?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billing_logCreateManyInput = {
    billing_log_id?: number
    billing_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type billing_logUpdateManyMutationInput = {
    billing_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billing_logUncheckedUpdateManyInput = {
    billing_log_id?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bloodgroup_detailsCreateInput = {
    bloodgroup_name?: string | null
    active?: number | null
  }

  export type bloodgroup_detailsUncheckedCreateInput = {
    bloodgroup_id?: number
    bloodgroup_name?: string | null
    active?: number | null
  }

  export type bloodgroup_detailsUpdateInput = {
    bloodgroup_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bloodgroup_detailsUncheckedUpdateInput = {
    bloodgroup_id?: IntFieldUpdateOperationsInput | number
    bloodgroup_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bloodgroup_detailsCreateManyInput = {
    bloodgroup_id?: number
    bloodgroup_name?: string | null
    active?: number | null
  }

  export type bloodgroup_detailsUpdateManyMutationInput = {
    bloodgroup_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bloodgroup_detailsUncheckedUpdateManyInput = {
    bloodgroup_id?: IntFieldUpdateOperationsInput | number
    bloodgroup_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cityCreateInput = {
    city_name: string
    state_id: number
    active?: boolean
  }

  export type cityUncheckedCreateInput = {
    city_id?: number
    city_name: string
    state_id: number
    active?: boolean
  }

  export type cityUpdateInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cityUncheckedUpdateInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cityCreateManyInput = {
    city_id?: number
    city_name: string
    state_id: number
    active?: boolean
  }

  export type cityUpdateManyMutationInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cityUncheckedUpdateManyInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clinic_module_activation_requestCreateInput = {
    name: string
    email: string
    phone_num: string
    physicianid: number
    message: string
    is_activated: number
    added_date?: Date | string
  }

  export type clinic_module_activation_requestUncheckedCreateInput = {
    clinic_module_activation_request_id?: number
    name: string
    email: string
    phone_num: string
    physicianid: number
    message: string
    is_activated: number
    added_date?: Date | string
  }

  export type clinic_module_activation_requestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    physicianid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    is_activated?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinic_module_activation_requestUncheckedUpdateInput = {
    clinic_module_activation_request_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    physicianid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    is_activated?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinic_module_activation_requestCreateManyInput = {
    clinic_module_activation_request_id?: number
    name: string
    email: string
    phone_num: string
    physicianid: number
    message: string
    is_activated: number
    added_date?: Date | string
  }

  export type clinic_module_activation_requestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    physicianid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    is_activated?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinic_module_activation_requestUncheckedUpdateManyInput = {
    clinic_module_activation_request_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    physicianid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    is_activated?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinical_parametersCreateInput = {
    blood_pressure: string
    systolic_blood_pressure: string
    diastolic_blood_pressure: string
    sugar: string
    pulse: string
    height: string
    weight: string
    temperature: string
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type clinical_parametersUncheckedCreateInput = {
    clinical_parameterid?: number
    blood_pressure: string
    systolic_blood_pressure: string
    diastolic_blood_pressure: string
    sugar: string
    pulse: string
    height: string
    weight: string
    temperature: string
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type clinical_parametersUpdateInput = {
    blood_pressure?: StringFieldUpdateOperationsInput | string
    systolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    diastolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    pulse?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    temperature?: StringFieldUpdateOperationsInput | string
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinical_parametersUncheckedUpdateInput = {
    clinical_parameterid?: IntFieldUpdateOperationsInput | number
    blood_pressure?: StringFieldUpdateOperationsInput | string
    systolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    diastolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    pulse?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    temperature?: StringFieldUpdateOperationsInput | string
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinical_parametersCreateManyInput = {
    clinical_parameterid?: number
    blood_pressure: string
    systolic_blood_pressure: string
    diastolic_blood_pressure: string
    sugar: string
    pulse: string
    height: string
    weight: string
    temperature: string
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type clinical_parametersUpdateManyMutationInput = {
    blood_pressure?: StringFieldUpdateOperationsInput | string
    systolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    diastolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    pulse?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    temperature?: StringFieldUpdateOperationsInput | string
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinical_parametersUncheckedUpdateManyInput = {
    clinical_parameterid?: IntFieldUpdateOperationsInput | number
    blood_pressure?: StringFieldUpdateOperationsInput | string
    systolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    diastolic_blood_pressure?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    pulse?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    temperature?: StringFieldUpdateOperationsInput | string
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactCreateInput = {
    name: string
    emailid: string
    subject: string
    message: string
    created_date?: Date | string
  }

  export type contactUncheckedCreateInput = {
    id?: number
    name: string
    emailid: string
    subject: string
    message: string
    created_date?: Date | string
  }

  export type contactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    emailid?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    emailid?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactCreateManyInput = {
    id?: number
    name: string
    emailid: string
    subject: string
    message: string
    created_date?: Date | string
  }

  export type contactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    emailid?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    emailid?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type countryCreateInput = {
    country_name?: string | null
    active?: boolean
  }

  export type countryUncheckedCreateInput = {
    country_id?: number
    country_name?: string | null
    active?: boolean
  }

  export type countryUpdateInput = {
    country_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type countryUncheckedUpdateInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type countryCreateManyInput = {
    country_id?: number
    country_name?: string | null
    active?: boolean
  }

  export type countryUpdateManyMutationInput = {
    country_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type countryUncheckedUpdateManyInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type filesCreateInput = {
    file_name: string
    type: string
    medical_num: string
    patient_unique_id: string
    referral_id: string
    uploaded_on: Date | string
    status?: $Enums.files_status
  }

  export type filesUncheckedCreateInput = {
    id?: number
    file_name: string
    type: string
    medical_num: string
    patient_unique_id: string
    referral_id: string
    uploaded_on: Date | string
    status?: $Enums.files_status
  }

  export type filesUpdateInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    referral_id?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumfiles_statusFieldUpdateOperationsInput | $Enums.files_status
  }

  export type filesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    referral_id?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumfiles_statusFieldUpdateOperationsInput | $Enums.files_status
  }

  export type filesCreateManyInput = {
    id?: number
    file_name: string
    type: string
    medical_num: string
    patient_unique_id: string
    referral_id: string
    uploaded_on: Date | string
    status?: $Enums.files_status
  }

  export type filesUpdateManyMutationInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    referral_id?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumfiles_statusFieldUpdateOperationsInput | $Enums.files_status
  }

  export type filesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    referral_id?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumfiles_statusFieldUpdateOperationsInput | $Enums.files_status
  }

  export type investigation_detailsCreateInput = {
    investigation_name?: string | null
    active?: number | null
    investigation_test_details?: investigation_test_detailsCreateNestedManyWithoutInvestigation_detailsInput
  }

  export type investigation_detailsUncheckedCreateInput = {
    investigation_id?: number
    investigation_name?: string | null
    active?: number | null
    investigation_test_details?: investigation_test_detailsUncheckedCreateNestedManyWithoutInvestigation_detailsInput
  }

  export type investigation_detailsUpdateInput = {
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    investigation_test_details?: investigation_test_detailsUpdateManyWithoutInvestigation_detailsNestedInput
  }

  export type investigation_detailsUncheckedUpdateInput = {
    investigation_id?: IntFieldUpdateOperationsInput | number
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    investigation_test_details?: investigation_test_detailsUncheckedUpdateManyWithoutInvestigation_detailsNestedInput
  }

  export type investigation_detailsCreateManyInput = {
    investigation_id?: number
    investigation_name?: string | null
    active?: number | null
  }

  export type investigation_detailsUpdateManyMutationInput = {
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type investigation_detailsUncheckedUpdateManyInput = {
    investigation_id?: IntFieldUpdateOperationsInput | number
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type investigation_fileCreateInput = {
    investigation_file: string
    referral_test_ID: number
    uploaded_on?: Date | string
  }

  export type investigation_fileUncheckedCreateInput = {
    file_id?: number
    investigation_file: string
    referral_test_ID: number
    uploaded_on?: Date | string
  }

  export type investigation_fileUpdateInput = {
    investigation_file?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investigation_fileUncheckedUpdateInput = {
    file_id?: IntFieldUpdateOperationsInput | number
    investigation_file?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investigation_fileCreateManyInput = {
    file_id?: number
    investigation_file: string
    referral_test_ID: number
    uploaded_on?: Date | string
  }

  export type investigation_fileUpdateManyMutationInput = {
    investigation_file?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investigation_fileUncheckedUpdateManyInput = {
    file_id?: IntFieldUpdateOperationsInput | number
    investigation_file?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investigation_test_detailsCreateInput = {
    parse_id?: number
    test_name: string
    parent_parse_id: number
    active?: number
    investigation_details: investigation_detailsCreateNestedOneWithoutInvestigation_test_detailsInput
  }

  export type investigation_test_detailsUncheckedCreateInput = {
    parse_id?: number
    test_name: string
    investigation_id: number
    parent_parse_id: number
    active?: number
  }

  export type investigation_test_detailsUpdateInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    investigation_details?: investigation_detailsUpdateOneRequiredWithoutInvestigation_test_detailsNestedInput
  }

  export type investigation_test_detailsUncheckedUpdateInput = {
    parse_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    investigation_id?: IntFieldUpdateOperationsInput | number
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type investigation_test_detailsCreateManyInput = {
    parse_id?: number
    test_name: string
    investigation_id: number
    parent_parse_id: number
    active?: number
  }

  export type investigation_test_detailsUpdateManyMutationInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type investigation_test_detailsUncheckedUpdateManyInput = {
    parse_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    investigation_id?: IntFieldUpdateOperationsInput | number
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type lab_leavesCreateInput = {
    lab_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type lab_leavesUncheckedCreateInput = {
    id?: number
    lab_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type lab_leavesUpdateInput = {
    lab_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type lab_leavesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type lab_leavesCreateManyInput = {
    id?: number
    lab_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type lab_leavesUpdateManyMutationInput = {
    lab_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type lab_leavesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type lab_tests_price_updatesCreateInput = {
    lab_id?: string | null
    test_id?: string | null
    price?: string | null
    unit?: string | null
    reference_range?: string | null
    created_date?: string | null
    created_by?: string | null
    created_by_phone_num?: string | null
  }

  export type lab_tests_price_updatesUncheckedCreateInput = {
    id?: number
    lab_id?: string | null
    test_id?: string | null
    price?: string | null
    unit?: string | null
    reference_range?: string | null
    created_date?: string | null
    created_by?: string | null
    created_by_phone_num?: string | null
  }

  export type lab_tests_price_updatesUpdateInput = {
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reference_range?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_phone_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_tests_price_updatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reference_range?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_phone_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_tests_price_updatesCreateManyInput = {
    id?: number
    lab_id?: string | null
    test_id?: string | null
    price?: string | null
    unit?: string | null
    reference_range?: string | null
    created_date?: string | null
    created_by?: string | null
    created_by_phone_num?: string | null
  }

  export type lab_tests_price_updatesUpdateManyMutationInput = {
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reference_range?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_phone_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_tests_price_updatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reference_range?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_phone_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_timingsCreateInput = {
    lab_id: number
    theday: string
    work_type?: $Enums.lab_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type lab_timingsUncheckedCreateInput = {
    id?: number
    lab_id: number
    theday: string
    work_type?: $Enums.lab_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type lab_timingsUpdateInput = {
    lab_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumlab_timings_work_typeFieldUpdateOperationsInput | $Enums.lab_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_timingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumlab_timings_work_typeFieldUpdateOperationsInput | $Enums.lab_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_timingsCreateManyInput = {
    id?: number
    lab_id: number
    theday: string
    work_type?: $Enums.lab_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type lab_timingsUpdateManyMutationInput = {
    lab_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumlab_timings_work_typeFieldUpdateOperationsInput | $Enums.lab_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lab_timingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumlab_timings_work_typeFieldUpdateOperationsInput | $Enums.lab_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type laboratory_detailsCreateInput = {
    laboratory_id?: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date | string
    updated_on: Date | string
    active?: number
    role_id?: number
    profile_filename: string
    profile_fullpath: string
    laboratory_test_details?: laboratory_test_detailsCreateNestedManyWithoutLaboratory_detailsInput
  }

  export type laboratory_detailsUncheckedCreateInput = {
    laboratory_id?: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date | string
    updated_on: Date | string
    active?: number
    role_id?: number
    profile_filename: string
    profile_fullpath: string
    laboratory_test_details?: laboratory_test_detailsUncheckedCreateNestedManyWithoutLaboratory_detailsInput
  }

  export type laboratory_detailsUpdateInput = {
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
    laboratory_test_details?: laboratory_test_detailsUpdateManyWithoutLaboratory_detailsNestedInput
  }

  export type laboratory_detailsUncheckedUpdateInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
    laboratory_test_details?: laboratory_test_detailsUncheckedUpdateManyWithoutLaboratory_detailsNestedInput
  }

  export type laboratory_detailsCreateManyInput = {
    laboratory_id?: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date | string
    updated_on: Date | string
    active?: number
    role_id?: number
    profile_filename: string
    profile_fullpath: string
  }

  export type laboratory_detailsUpdateManyMutationInput = {
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
  }

  export type laboratory_detailsUncheckedUpdateManyInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
  }

  export type laboratory_doctorsCreateInput = {
    laboratory_id: number
    doc_firstname: string
    doc_lastname: string
    doc_password: string
    doc_phone_number: string
    doc_email: string
    doc_dept: number
    doc_signature: string
    added_date?: Date | string
    doc_designation: string
    is_active: number
  }

  export type laboratory_doctorsUncheckedCreateInput = {
    laboratory_doctors_id?: number
    laboratory_id: number
    doc_firstname: string
    doc_lastname: string
    doc_password: string
    doc_phone_number: string
    doc_email: string
    doc_dept: number
    doc_signature: string
    added_date?: Date | string
    doc_designation: string
    is_active: number
  }

  export type laboratory_doctorsUpdateInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    doc_firstname?: StringFieldUpdateOperationsInput | string
    doc_lastname?: StringFieldUpdateOperationsInput | string
    doc_password?: StringFieldUpdateOperationsInput | string
    doc_phone_number?: StringFieldUpdateOperationsInput | string
    doc_email?: StringFieldUpdateOperationsInput | string
    doc_dept?: IntFieldUpdateOperationsInput | number
    doc_signature?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doc_designation?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_doctorsUncheckedUpdateInput = {
    laboratory_doctors_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    doc_firstname?: StringFieldUpdateOperationsInput | string
    doc_lastname?: StringFieldUpdateOperationsInput | string
    doc_password?: StringFieldUpdateOperationsInput | string
    doc_phone_number?: StringFieldUpdateOperationsInput | string
    doc_email?: StringFieldUpdateOperationsInput | string
    doc_dept?: IntFieldUpdateOperationsInput | number
    doc_signature?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doc_designation?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_doctorsCreateManyInput = {
    laboratory_doctors_id?: number
    laboratory_id: number
    doc_firstname: string
    doc_lastname: string
    doc_password: string
    doc_phone_number: string
    doc_email: string
    doc_dept: number
    doc_signature: string
    added_date?: Date | string
    doc_designation: string
    is_active: number
  }

  export type laboratory_doctorsUpdateManyMutationInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    doc_firstname?: StringFieldUpdateOperationsInput | string
    doc_lastname?: StringFieldUpdateOperationsInput | string
    doc_password?: StringFieldUpdateOperationsInput | string
    doc_phone_number?: StringFieldUpdateOperationsInput | string
    doc_email?: StringFieldUpdateOperationsInput | string
    doc_dept?: IntFieldUpdateOperationsInput | number
    doc_signature?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doc_designation?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_doctorsUncheckedUpdateManyInput = {
    laboratory_doctors_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    doc_firstname?: StringFieldUpdateOperationsInput | string
    doc_lastname?: StringFieldUpdateOperationsInput | string
    doc_password?: StringFieldUpdateOperationsInput | string
    doc_phone_number?: StringFieldUpdateOperationsInput | string
    doc_email?: StringFieldUpdateOperationsInput | string
    doc_dept?: IntFieldUpdateOperationsInput | number
    doc_signature?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doc_designation?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsCreateInput = {
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
    laboratory_details: laboratory_detailsCreateNestedOneWithoutLaboratory_test_detailsInput
  }

  export type laboratory_test_detailsUncheckedCreateInput = {
    laboratory_testid?: number
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    laboratory_id: number
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
  }

  export type laboratory_test_detailsUpdateInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
    laboratory_details?: laboratory_detailsUpdateOneRequiredWithoutLaboratory_test_detailsNestedInput
  }

  export type laboratory_test_detailsUncheckedUpdateInput = {
    laboratory_testid?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_id?: IntFieldUpdateOperationsInput | number
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsCreateManyInput = {
    laboratory_testid?: number
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    laboratory_id: number
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
  }

  export type laboratory_test_detailsUpdateManyMutationInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsUncheckedUpdateManyInput = {
    laboratory_testid?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_id?: IntFieldUpdateOperationsInput | number
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type localityCreateInput = {
    locality_name: string
    city_id: number
    active?: number
  }

  export type localityUncheckedCreateInput = {
    locality_id?: number
    locality_name: string
    city_id: number
    active?: number
  }

  export type localityUpdateInput = {
    locality_name?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type localityUncheckedUpdateInput = {
    locality_id?: IntFieldUpdateOperationsInput | number
    locality_name?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type localityCreateManyInput = {
    locality_id?: number
    locality_name: string
    city_id: number
    active?: number
  }

  export type localityUpdateManyMutationInput = {
    locality_name?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type localityUncheckedUpdateManyInput = {
    locality_id?: IntFieldUpdateOperationsInput | number
    locality_name?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type login_detailsCreateInput = {
    login_id?: number
    firstname: string
    physician_id?: number | null
    laboratory_id?: number | null
    patient_id?: number | null
    phy_admin_id?: number | null
    username: string
    password: string
    phone_num: string
    state: number
    city: number
    count?: number
    role_id: number
    active?: number
    last_login?: Date | string | null
    created_on?: Date | string
    updated_on: Date | string
    otp: number
    device_id: string
    player_id: string
  }

  export type login_detailsUncheckedCreateInput = {
    login_id?: number
    firstname: string
    physician_id?: number | null
    laboratory_id?: number | null
    patient_id?: number | null
    phy_admin_id?: number | null
    username: string
    password: string
    phone_num: string
    state: number
    city: number
    count?: number
    role_id: number
    active?: number
    last_login?: Date | string | null
    created_on?: Date | string
    updated_on: Date | string
    otp: number
    device_id: string
    player_id: string
  }

  export type login_detailsUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    phy_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
  }

  export type login_detailsUncheckedUpdateInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    phy_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
  }

  export type login_detailsCreateManyInput = {
    login_id?: number
    firstname: string
    physician_id?: number | null
    laboratory_id?: number | null
    patient_id?: number | null
    phy_admin_id?: number | null
    username: string
    password: string
    phone_num: string
    state: number
    city: number
    count?: number
    role_id: number
    active?: number
    last_login?: Date | string | null
    created_on?: Date | string
    updated_on: Date | string
    otp: number
    device_id: string
    player_id: string
  }

  export type login_detailsUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    phy_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
  }

  export type login_detailsUncheckedUpdateManyInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    phy_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_num?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    otp?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
  }

  export type medicineCreateInput = {
    medicine_name: string
    active?: number
  }

  export type medicineUncheckedCreateInput = {
    ID?: number
    medicine_name: string
    active?: number
  }

  export type medicineUpdateInput = {
    medicine_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type medicineUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    medicine_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type medicineCreateManyInput = {
    ID?: number
    medicine_name: string
    active?: number
  }

  export type medicineUpdateManyMutationInput = {
    medicine_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type medicineUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    medicine_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type notification_keysCreateInput = {
    app_id: string
    rest_api_key: string
  }

  export type notification_keysUncheckedCreateInput = {
    notification_keys_id?: number
    app_id: string
    rest_api_key: string
  }

  export type notification_keysUpdateInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    rest_api_key?: StringFieldUpdateOperationsInput | string
  }

  export type notification_keysUncheckedUpdateInput = {
    notification_keys_id?: IntFieldUpdateOperationsInput | number
    app_id?: StringFieldUpdateOperationsInput | string
    rest_api_key?: StringFieldUpdateOperationsInput | string
  }

  export type notification_keysCreateManyInput = {
    notification_keys_id?: number
    app_id: string
    rest_api_key: string
  }

  export type notification_keysUpdateManyMutationInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    rest_api_key?: StringFieldUpdateOperationsInput | string
  }

  export type notification_keysUncheckedUpdateManyInput = {
    notification_keys_id?: IntFieldUpdateOperationsInput | number
    app_id?: StringFieldUpdateOperationsInput | string
    rest_api_key?: StringFieldUpdateOperationsInput | string
  }

  export type notificationattemptCreateInput = {
    login_id: number
    notification_heading: string
    notification_message: string
    notification_type: string
    CreatedDateTime?: Date | string
    notification_medium: number
    SendDateTime: Date | string
    status: number
  }

  export type notificationattemptUncheckedCreateInput = {
    notificationattempt_id?: number
    login_id: number
    notification_heading: string
    notification_message: string
    notification_type: string
    CreatedDateTime?: Date | string
    notification_medium: number
    SendDateTime: Date | string
    status: number
  }

  export type notificationattemptUpdateInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    notification_heading?: StringFieldUpdateOperationsInput | string
    notification_message?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_medium?: IntFieldUpdateOperationsInput | number
    SendDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type notificationattemptUncheckedUpdateInput = {
    notificationattempt_id?: IntFieldUpdateOperationsInput | number
    login_id?: IntFieldUpdateOperationsInput | number
    notification_heading?: StringFieldUpdateOperationsInput | string
    notification_message?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_medium?: IntFieldUpdateOperationsInput | number
    SendDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type notificationattemptCreateManyInput = {
    notificationattempt_id?: number
    login_id: number
    notification_heading: string
    notification_message: string
    notification_type: string
    CreatedDateTime?: Date | string
    notification_medium: number
    SendDateTime: Date | string
    status: number
  }

  export type notificationattemptUpdateManyMutationInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    notification_heading?: StringFieldUpdateOperationsInput | string
    notification_message?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_medium?: IntFieldUpdateOperationsInput | number
    SendDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type notificationattemptUncheckedUpdateManyInput = {
    notificationattempt_id?: IntFieldUpdateOperationsInput | number
    login_id?: IntFieldUpdateOperationsInput | number
    notification_heading?: StringFieldUpdateOperationsInput | string
    notification_message?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_medium?: IntFieldUpdateOperationsInput | number
    SendDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RenamedpackageCreateInput = {
    package_name: string
    created_on?: string | null
    created_by?: string | null
  }

  export type RenamedpackageUncheckedCreateInput = {
    id?: number
    package_name: string
    created_on?: string | null
    created_by?: string | null
  }

  export type RenamedpackageUpdateInput = {
    package_name?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RenamedpackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_name?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RenamedpackageCreateManyInput = {
    id?: number
    package_name: string
    created_on?: string | null
    created_by?: string | null
  }

  export type RenamedpackageUpdateManyMutationInput = {
    package_name?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RenamedpackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_name?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_containsCreateInput = {
    package_id: string
    test_id: string
    created_on?: string | null
    is_active?: number
  }

  export type package_containsUncheckedCreateInput = {
    id?: number
    package_id: string
    test_id: string
    created_on?: string | null
    is_active?: number
  }

  export type package_containsUpdateInput = {
    package_id?: StringFieldUpdateOperationsInput | string
    test_id?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type package_containsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_id?: StringFieldUpdateOperationsInput | string
    test_id?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type package_containsCreateManyInput = {
    id?: number
    package_id: string
    test_id: string
    created_on?: string | null
    is_active?: number
  }

  export type package_containsUpdateManyMutationInput = {
    package_id?: StringFieldUpdateOperationsInput | string
    test_id?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type package_containsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_id?: StringFieldUpdateOperationsInput | string
    test_id?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type package_labsCreateInput = {
    package_id: string
    lab_id: string
    package_price: string
    created_on?: string | null
    created_by?: string | null
  }

  export type package_labsUncheckedCreateInput = {
    id?: number
    package_id: string
    lab_id: string
    package_price: string
    created_on?: string | null
    created_by?: string | null
  }

  export type package_labsUpdateInput = {
    package_id?: StringFieldUpdateOperationsInput | string
    lab_id?: StringFieldUpdateOperationsInput | string
    package_price?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_labsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_id?: StringFieldUpdateOperationsInput | string
    lab_id?: StringFieldUpdateOperationsInput | string
    package_price?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_labsCreateManyInput = {
    id?: number
    package_id: string
    lab_id: string
    package_price: string
    created_on?: string | null
    created_by?: string | null
  }

  export type package_labsUpdateManyMutationInput = {
    package_id?: StringFieldUpdateOperationsInput | string
    lab_id?: StringFieldUpdateOperationsInput | string
    package_price?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_labsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    package_id?: StringFieldUpdateOperationsInput | string
    lab_id?: StringFieldUpdateOperationsInput | string
    package_price?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_queueCreateInput = {
    id?: bigint | number
    medical_num?: string | null
    package_id?: string | null
    lab_id?: string | null
    patient_id?: string | null
    dependent_id?: string
    doctor_id?: string | null
    referdate?: string | null
    created_by?: string | null
    created_on?: string | null
    package_status?: string | null
  }

  export type package_queueUncheckedCreateInput = {
    id?: bigint | number
    medical_num?: string | null
    package_id?: string | null
    lab_id?: string | null
    patient_id?: string | null
    dependent_id?: string
    doctor_id?: string | null
    referdate?: string | null
    created_by?: string | null
    created_on?: string | null
    package_status?: string | null
  }

  export type package_queueUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    dependent_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referdate?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_queueUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    dependent_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referdate?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_queueCreateManyInput = {
    id?: bigint | number
    medical_num?: string | null
    package_id?: string | null
    lab_id?: string | null
    patient_id?: string | null
    dependent_id?: string
    doctor_id?: string | null
    referdate?: string | null
    created_by?: string | null
    created_on?: string | null
    package_status?: string | null
  }

  export type package_queueUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    dependent_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referdate?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type package_queueUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    dependent_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: NullableStringFieldUpdateOperationsInput | string | null
    referdate?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_dep_detailsCreateInput = {
    firstname?: string | null
    lastname: string
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    city?: string | null
    pincode: string
    mailid?: string | null
    phonenum?: string | null
    alt_phonenum: string
    relationship?: string
    main_pat_id: number
    created_on?: Date | string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id: string
    physician_id: string
    status?: string
    r_count?: number
    count: number
    prescribe_receipt: number
  }

  export type patient_dep_detailsUncheckedCreateInput = {
    patient_dep_id?: number
    firstname?: string | null
    lastname: string
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    city?: string | null
    pincode: string
    mailid?: string | null
    phonenum?: string | null
    alt_phonenum: string
    relationship?: string
    main_pat_id: number
    created_on?: Date | string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id: string
    physician_id: string
    status?: string
    r_count?: number
    count: number
    prescribe_receipt: number
  }

  export type patient_dep_detailsUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    mailid?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phonenum?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    main_pat_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type patient_dep_detailsUncheckedUpdateInput = {
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    mailid?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phonenum?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    main_pat_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type patient_dep_detailsCreateManyInput = {
    patient_dep_id?: number
    firstname?: string | null
    lastname: string
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    city?: string | null
    pincode: string
    mailid?: string | null
    phonenum?: string | null
    alt_phonenum: string
    relationship?: string
    main_pat_id: number
    created_on?: Date | string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id: string
    physician_id: string
    status?: string
    r_count?: number
    count: number
    prescribe_receipt: number
  }

  export type patient_dep_detailsUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    mailid?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phonenum?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    main_pat_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type patient_dep_detailsUncheckedUpdateManyInput = {
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    mailid?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phonenum?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    main_pat_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type patient_doctor_mappingCreateInput = {
    referral_patient_id: number
    prev_physician_id: number
    new_physician_id: number
    patient_unique_id: string
    added_date?: Date | string
  }

  export type patient_doctor_mappingUncheckedCreateInput = {
    patient_doctor_mapping_id?: number
    referral_patient_id: number
    prev_physician_id: number
    new_physician_id: number
    patient_unique_id: string
    added_date?: Date | string
  }

  export type patient_doctor_mappingUpdateInput = {
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    prev_physician_id?: IntFieldUpdateOperationsInput | number
    new_physician_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patient_doctor_mappingUncheckedUpdateInput = {
    patient_doctor_mapping_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    prev_physician_id?: IntFieldUpdateOperationsInput | number
    new_physician_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patient_doctor_mappingCreateManyInput = {
    patient_doctor_mapping_id?: number
    referral_patient_id: number
    prev_physician_id: number
    new_physician_id: number
    patient_unique_id: string
    added_date?: Date | string
  }

  export type patient_doctor_mappingUpdateManyMutationInput = {
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    prev_physician_id?: IntFieldUpdateOperationsInput | number
    new_physician_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patient_doctor_mappingUncheckedUpdateManyInput = {
    patient_doctor_mapping_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    prev_physician_id?: IntFieldUpdateOperationsInput | number
    new_physician_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patient_parameterCreateInput = {
    date_of_birth: Date | string
    known_allergies: string
    previous_medical_history: string
    blood_group?: number | null
    diabetic?: string | null
    hypertension?: string | null
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type patient_parameterUncheckedCreateInput = {
    parameter_id?: number
    date_of_birth: Date | string
    known_allergies: string
    previous_medical_history: string
    blood_group?: number | null
    diabetic?: string | null
    hypertension?: string | null
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type patient_parameterUpdateInput = {
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    known_allergies?: StringFieldUpdateOperationsInput | string
    previous_medical_history?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableIntFieldUpdateOperationsInput | number | null
    diabetic?: NullableStringFieldUpdateOperationsInput | string | null
    hypertension?: NullableStringFieldUpdateOperationsInput | string | null
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_parameterUncheckedUpdateInput = {
    parameter_id?: IntFieldUpdateOperationsInput | number
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    known_allergies?: StringFieldUpdateOperationsInput | string
    previous_medical_history?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableIntFieldUpdateOperationsInput | number | null
    diabetic?: NullableStringFieldUpdateOperationsInput | string | null
    hypertension?: NullableStringFieldUpdateOperationsInput | string | null
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_parameterCreateManyInput = {
    parameter_id?: number
    date_of_birth: Date | string
    known_allergies: string
    previous_medical_history: string
    blood_group?: number | null
    diabetic?: string | null
    hypertension?: string | null
    referral_patient_id: number
    dependent_id: number
    created_on?: string | null
  }

  export type patient_parameterUpdateManyMutationInput = {
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    known_allergies?: StringFieldUpdateOperationsInput | string
    previous_medical_history?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableIntFieldUpdateOperationsInput | number | null
    diabetic?: NullableStringFieldUpdateOperationsInput | string | null
    hypertension?: NullableStringFieldUpdateOperationsInput | string | null
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_parameterUncheckedUpdateManyInput = {
    parameter_id?: IntFieldUpdateOperationsInput | number
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    known_allergies?: StringFieldUpdateOperationsInput | string
    previous_medical_history?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableIntFieldUpdateOperationsInput | number | null
    diabetic?: NullableStringFieldUpdateOperationsInput | string | null
    hypertension?: NullableStringFieldUpdateOperationsInput | string | null
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patientqueueCreateInput = {
    BillId: string
    medical_num: string
    firstname: string
    mailid: string
    phonenum: string
    refer_date: Date | string
    patient_unique_id: string
    physician_id?: number | null
    phyfname?: string | null
    referred_id: number
    ID: number
    billing_id: number
    laboratory_id: number
    ref_type: string
    lab_test_status: number
    billing_status: number
    is_sync: number
    created_on?: Date | string
  }

  export type patientqueueUncheckedCreateInput = {
    patientqueue_id?: number
    BillId: string
    medical_num: string
    firstname: string
    mailid: string
    phonenum: string
    refer_date: Date | string
    patient_unique_id: string
    physician_id?: number | null
    phyfname?: string | null
    referred_id: number
    ID: number
    billing_id: number
    laboratory_id: number
    ref_type: string
    lab_test_status: number
    billing_status: number
    is_sync: number
    created_on?: Date | string
  }

  export type patientqueueUpdateInput = {
    BillId?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    refer_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    phyfname?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: IntFieldUpdateOperationsInput | number
    ID?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    ref_type?: StringFieldUpdateOperationsInput | string
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
    is_sync?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientqueueUncheckedUpdateInput = {
    patientqueue_id?: IntFieldUpdateOperationsInput | number
    BillId?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    refer_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    phyfname?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: IntFieldUpdateOperationsInput | number
    ID?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    ref_type?: StringFieldUpdateOperationsInput | string
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
    is_sync?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientqueueCreateManyInput = {
    patientqueue_id?: number
    BillId: string
    medical_num: string
    firstname: string
    mailid: string
    phonenum: string
    refer_date: Date | string
    patient_unique_id: string
    physician_id?: number | null
    phyfname?: string | null
    referred_id: number
    ID: number
    billing_id: number
    laboratory_id: number
    ref_type: string
    lab_test_status: number
    billing_status: number
    is_sync: number
    created_on?: Date | string
  }

  export type patientqueueUpdateManyMutationInput = {
    BillId?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    refer_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    phyfname?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: IntFieldUpdateOperationsInput | number
    ID?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    ref_type?: StringFieldUpdateOperationsInput | string
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
    is_sync?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientqueueUncheckedUpdateManyInput = {
    patientqueue_id?: IntFieldUpdateOperationsInput | number
    BillId?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    refer_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient_unique_id?: StringFieldUpdateOperationsInput | string
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    phyfname?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: IntFieldUpdateOperationsInput | number
    ID?: IntFieldUpdateOperationsInput | number
    billing_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    ref_type?: StringFieldUpdateOperationsInput | string
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
    is_sync?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateInput = {
    doctor_id: number
    referral_patient_id: number
    dependent_id: number
    Receipt_id: bigint | number
    prescription_num: string
    reg_fee: string
    con_price: number
    med_price: number
    inv_price: number
    admin_price: number
    total_price: number
    mode: string
    created_on?: Date | string
    updated_on?: Date | string
    submitted?: number | null
  }

  export type paymentUncheckedCreateInput = {
    ID?: number
    doctor_id: number
    referral_patient_id: number
    dependent_id: number
    Receipt_id: bigint | number
    prescription_num: string
    reg_fee: string
    con_price: number
    med_price: number
    inv_price: number
    admin_price: number
    total_price: number
    mode: string
    created_on?: Date | string
    updated_on?: Date | string
    submitted?: number | null
  }

  export type paymentUpdateInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    Receipt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    reg_fee?: StringFieldUpdateOperationsInput | string
    con_price?: IntFieldUpdateOperationsInput | number
    med_price?: IntFieldUpdateOperationsInput | number
    inv_price?: IntFieldUpdateOperationsInput | number
    admin_price?: IntFieldUpdateOperationsInput | number
    total_price?: IntFieldUpdateOperationsInput | number
    mode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paymentUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    Receipt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    reg_fee?: StringFieldUpdateOperationsInput | string
    con_price?: IntFieldUpdateOperationsInput | number
    med_price?: IntFieldUpdateOperationsInput | number
    inv_price?: IntFieldUpdateOperationsInput | number
    admin_price?: IntFieldUpdateOperationsInput | number
    total_price?: IntFieldUpdateOperationsInput | number
    mode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paymentCreateManyInput = {
    ID?: number
    doctor_id: number
    referral_patient_id: number
    dependent_id: number
    Receipt_id: bigint | number
    prescription_num: string
    reg_fee: string
    con_price: number
    med_price: number
    inv_price: number
    admin_price: number
    total_price: number
    mode: string
    created_on?: Date | string
    updated_on?: Date | string
    submitted?: number | null
  }

  export type paymentUpdateManyMutationInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    Receipt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    reg_fee?: StringFieldUpdateOperationsInput | string
    con_price?: IntFieldUpdateOperationsInput | number
    med_price?: IntFieldUpdateOperationsInput | number
    inv_price?: IntFieldUpdateOperationsInput | number
    admin_price?: IntFieldUpdateOperationsInput | number
    total_price?: IntFieldUpdateOperationsInput | number
    mode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paymentUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    Receipt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    reg_fee?: StringFieldUpdateOperationsInput | string
    con_price?: IntFieldUpdateOperationsInput | number
    med_price?: IntFieldUpdateOperationsInput | number
    inv_price?: IntFieldUpdateOperationsInput | number
    admin_price?: IntFieldUpdateOperationsInput | number
    total_price?: IntFieldUpdateOperationsInput | number
    mode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type phy_adminCreateInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    active?: number
    is_visible?: number
    role_id?: number
    physician_appointment: physician_appointmentCreateNestedOneWithoutPhy_adminInput
  }

  export type phy_adminUncheckedCreateInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    physician_id: number
    active?: number
    is_visible?: number
    role_id?: number
  }

  export type phy_adminUpdateInput = {
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    physician_appointment?: physician_appointmentUpdateOneRequiredWithoutPhy_adminNestedInput
  }

  export type phy_adminUncheckedUpdateInput = {
    phy_admin_id?: IntFieldUpdateOperationsInput | number
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type phy_adminCreateManyInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    physician_id: number
    active?: number
    is_visible?: number
    role_id?: number
  }

  export type phy_adminUpdateManyMutationInput = {
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type phy_adminUncheckedUpdateManyInput = {
    phy_admin_id?: IntFieldUpdateOperationsInput | number
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type physician_appointmentCreateInput = {
    physician_id?: number
    firstname?: string | null
    lastname?: string | null
    phone_num?: string
    alternate_phone_number: string
    mail_id?: string
    pincode?: number | null
    clinic_name?: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization?: string | null
    address?: string | null
    consultation_fee_validity: string
    city?: string | null
    state?: string | null
    active?: boolean
    created_by?: string | null
    created_on?: Date | string | null
    updated_on?: Date | string | null
    password?: string | null
    role_id?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    qualification_id?: number | null
    registration_number?: string | null
    time_span?: string | null
    status?: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
    phy_admin?: phy_adminCreateNestedManyWithoutPhysician_appointmentInput
  }

  export type physician_appointmentUncheckedCreateInput = {
    physician_id?: number
    firstname?: string | null
    lastname?: string | null
    phone_num?: string
    alternate_phone_number: string
    mail_id?: string
    pincode?: number | null
    clinic_name?: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization?: string | null
    address?: string | null
    consultation_fee_validity: string
    city?: string | null
    state?: string | null
    active?: boolean
    created_by?: string | null
    created_on?: Date | string | null
    updated_on?: Date | string | null
    password?: string | null
    role_id?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    qualification_id?: number | null
    registration_number?: string | null
    time_span?: string | null
    status?: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
    phy_admin?: phy_adminUncheckedCreateNestedManyWithoutPhysician_appointmentInput
  }

  export type physician_appointmentUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
    phy_admin?: phy_adminUpdateManyWithoutPhysician_appointmentNestedInput
  }

  export type physician_appointmentUncheckedUpdateInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
    phy_admin?: phy_adminUncheckedUpdateManyWithoutPhysician_appointmentNestedInput
  }

  export type physician_appointmentCreateManyInput = {
    physician_id?: number
    firstname?: string | null
    lastname?: string | null
    phone_num?: string
    alternate_phone_number: string
    mail_id?: string
    pincode?: number | null
    clinic_name?: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization?: string | null
    address?: string | null
    consultation_fee_validity: string
    city?: string | null
    state?: string | null
    active?: boolean
    created_by?: string | null
    created_on?: Date | string | null
    updated_on?: Date | string | null
    password?: string | null
    role_id?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    qualification_id?: number | null
    registration_number?: string | null
    time_span?: string | null
    status?: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
  }

  export type physician_appointmentUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
  }

  export type physician_appointmentUncheckedUpdateManyInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
  }

  export type physician_clinic_timingsCreateInput = {
    physician_id: number
    theday: string
    work_type?: $Enums.physician_clinic_timings_work_type
    clinic?: string | null
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_clinic_timingsUncheckedCreateInput = {
    id?: number
    physician_id: number
    theday: string
    work_type?: $Enums.physician_clinic_timings_work_type
    clinic?: string | null
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_clinic_timingsUpdateInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_clinic_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_clinic_timings_work_type
    clinic?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_clinic_timingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_clinic_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_clinic_timings_work_type
    clinic?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_clinic_timingsCreateManyInput = {
    id?: number
    physician_id: number
    theday: string
    work_type?: $Enums.physician_clinic_timings_work_type
    clinic?: string | null
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_clinic_timingsUpdateManyMutationInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_clinic_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_clinic_timings_work_type
    clinic?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_clinic_timingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_clinic_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_clinic_timings_work_type
    clinic?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_leavesCreateInput = {
    physician_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type physician_leavesUncheckedCreateInput = {
    id?: number
    physician_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type physician_leavesUpdateInput = {
    physician_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type physician_leavesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type physician_leavesCreateManyInput = {
    id?: number
    physician_id: bigint | number
    dates: string
    start_time?: string | null
    end_time?: string | null
    reason?: string | null
    created_time: string
  }

  export type physician_leavesUpdateManyMutationInput = {
    physician_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type physician_leavesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: BigIntFieldUpdateOperationsInput | bigint | number
    dates?: StringFieldUpdateOperationsInput | string
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: StringFieldUpdateOperationsInput | string
  }

  export type physician_timingsCreateInput = {
    physician_id: number
    theday: string
    work_type?: $Enums.physician_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_timingsUncheckedCreateInput = {
    id?: number
    physician_id: number
    theday: string
    work_type?: $Enums.physician_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_timingsUpdateInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_timingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_timingsCreateManyInput = {
    id?: number
    physician_id: number
    theday: string
    work_type?: $Enums.physician_timings_work_type
    start_time?: string | null
    end_time?: string | null
    created_time?: string | null
    updated_time?: string | null
  }

  export type physician_timingsUpdateManyMutationInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type physician_timingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    theday?: StringFieldUpdateOperationsInput | string
    work_type?: Enumphysician_timings_work_typeFieldUpdateOperationsInput | $Enums.physician_timings_work_type
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    created_time?: NullableStringFieldUpdateOperationsInput | string | null
    updated_time?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type preferredlabsCreateInput = {
    laboratory_id: number
    physician_id: number
    is_active?: number
  }

  export type preferredlabsUncheckedCreateInput = {
    preferredlabs_id?: number
    laboratory_id: number
    physician_id: number
    is_active?: number
  }

  export type preferredlabsUpdateInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type preferredlabsUncheckedUpdateInput = {
    preferredlabs_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type preferredlabsCreateManyInput = {
    preferredlabs_id?: number
    laboratory_id: number
    physician_id: number
    is_active?: number
  }

  export type preferredlabsUpdateManyMutationInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type preferredlabsUncheckedUpdateManyInput = {
    preferredlabs_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type prescriptionCreateInput = {
    prescription_num: string
    patient_id: number
    dependent_id: number
    doctor_id?: number | null
    symptoms?: string | null
    type?: string | null
    med_name?: string | null
    mg?: string | null
    dose?: string | null
    num_days?: string | null
    instruction: string
    advice?: string | null
    created_on?: Date | string | null
  }

  export type prescriptionUncheckedCreateInput = {
    prescription_id?: number
    prescription_num: string
    patient_id: number
    dependent_id: number
    doctor_id?: number | null
    symptoms?: string | null
    type?: string | null
    med_name?: string | null
    mg?: string | null
    dose?: string | null
    num_days?: string | null
    instruction: string
    advice?: string | null
    created_on?: Date | string | null
  }

  export type prescriptionUpdateInput = {
    prescription_num?: StringFieldUpdateOperationsInput | string
    patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: NullableIntFieldUpdateOperationsInput | number | null
    symptoms?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    num_days?: NullableStringFieldUpdateOperationsInput | string | null
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionUncheckedUpdateInput = {
    prescription_id?: IntFieldUpdateOperationsInput | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: NullableIntFieldUpdateOperationsInput | number | null
    symptoms?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    num_days?: NullableStringFieldUpdateOperationsInput | string | null
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionCreateManyInput = {
    prescription_id?: number
    prescription_num: string
    patient_id: number
    dependent_id: number
    doctor_id?: number | null
    symptoms?: string | null
    type?: string | null
    med_name?: string | null
    mg?: string | null
    dose?: string | null
    num_days?: string | null
    instruction: string
    advice?: string | null
    created_on?: Date | string | null
  }

  export type prescriptionUpdateManyMutationInput = {
    prescription_num?: StringFieldUpdateOperationsInput | string
    patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: NullableIntFieldUpdateOperationsInput | number | null
    symptoms?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    num_days?: NullableStringFieldUpdateOperationsInput | string | null
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionUncheckedUpdateManyInput = {
    prescription_id?: IntFieldUpdateOperationsInput | number
    prescription_num?: StringFieldUpdateOperationsInput | string
    patient_id?: IntFieldUpdateOperationsInput | number
    dependent_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: NullableIntFieldUpdateOperationsInput | number | null
    symptoms?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: NullableStringFieldUpdateOperationsInput | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    num_days?: NullableStringFieldUpdateOperationsInput | string | null
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescription_medicineCreateInput = {
    type?: string | null
    med_name?: string | null
    mg: string
    dose: string
    num_days: string
    instruction: string
    advice: string
    prescription_id?: number | null
  }

  export type prescription_medicineUncheckedCreateInput = {
    medicine_id?: number
    type?: string | null
    med_name?: string | null
    mg: string
    dose: string
    num_days: string
    instruction: string
    advice: string
    prescription_id?: number | null
  }

  export type prescription_medicineUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    num_days?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: StringFieldUpdateOperationsInput | string
    prescription_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescription_medicineUncheckedUpdateInput = {
    medicine_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    num_days?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: StringFieldUpdateOperationsInput | string
    prescription_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescription_medicineCreateManyInput = {
    medicine_id?: number
    type?: string | null
    med_name?: string | null
    mg: string
    dose: string
    num_days: string
    instruction: string
    advice: string
    prescription_id?: number | null
  }

  export type prescription_medicineUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    num_days?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: StringFieldUpdateOperationsInput | string
    prescription_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescription_medicineUncheckedUpdateManyInput = {
    medicine_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    med_name?: NullableStringFieldUpdateOperationsInput | string | null
    mg?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    num_days?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    advice?: StringFieldUpdateOperationsInput | string
    prescription_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type qualificationCreateInput = {
    qualification_name: string
    is_active?: number
  }

  export type qualificationUncheckedCreateInput = {
    qualification_id?: number
    qualification_name: string
    is_active?: number
  }

  export type qualificationUpdateInput = {
    qualification_name?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type qualificationUncheckedUpdateInput = {
    qualification_id?: IntFieldUpdateOperationsInput | number
    qualification_name?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type qualificationCreateManyInput = {
    qualification_id?: number
    qualification_name: string
    is_active?: number
  }

  export type qualificationUpdateManyMutationInput = {
    qualification_name?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type qualificationUncheckedUpdateManyInput = {
    qualification_id?: IntFieldUpdateOperationsInput | number
    qualification_name?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
  }

  export type qualification_mappingCreateInput = {
    qualification_id: number
    physician_id: number
  }

  export type qualification_mappingUncheckedCreateInput = {
    qualification_mapping_id?: number
    qualification_id: number
    physician_id: number
  }

  export type qualification_mappingUpdateInput = {
    qualification_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
  }

  export type qualification_mappingUncheckedUpdateInput = {
    qualification_mapping_id?: IntFieldUpdateOperationsInput | number
    qualification_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
  }

  export type qualification_mappingCreateManyInput = {
    qualification_mapping_id?: number
    qualification_id: number
    physician_id: number
  }

  export type qualification_mappingUpdateManyMutationInput = {
    qualification_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
  }

  export type qualification_mappingUncheckedUpdateManyInput = {
    qualification_mapping_id?: IntFieldUpdateOperationsInput | number
    qualification_id?: IntFieldUpdateOperationsInput | number
    physician_id?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_detailsCreateInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details_ref_type
    lab_test_status: number
    billing_status: number
  }

  export type referral_confirmation_detailsUncheckedCreateInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details_ref_type
    lab_test_status: number
    billing_status: number
  }

  export type referral_confirmation_detailsUpdateInput = {
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_detailsUncheckedUpdateInput = {
    referred_id?: IntFieldUpdateOperationsInput | number
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_detailsCreateManyInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details_ref_type
    lab_test_status: number
    billing_status: number
  }

  export type referral_confirmation_detailsUpdateManyMutationInput = {
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_detailsUncheckedUpdateManyInput = {
    referred_id?: IntFieldUpdateOperationsInput | number
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
    billing_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_details1CreateInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: number
  }

  export type referral_confirmation_details1UncheckedCreateInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: number
  }

  export type referral_confirmation_details1UpdateInput = {
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_details1UncheckedUpdateInput = {
    referred_id?: IntFieldUpdateOperationsInput | number
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_details1CreateManyInput = {
    referred_id?: number
    medical_num?: string
    relationship?: string | null
    referral_pat_id?: number | null
    password?: string | null
    patient_unique_id?: string | null
    attempts?: number | null
    brief_history?: string | null
    phy_advice?: string | null
    refer_date?: Date | string | null
    created_by?: string | null
    login_id: number
    created_on?: Date | string
    ref_type: $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: number
  }

  export type referral_confirmation_details1UpdateManyMutationInput = {
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_confirmation_details1UncheckedUpdateManyInput = {
    referred_id?: IntFieldUpdateOperationsInput | number
    medical_num?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    referral_pat_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    brief_history?: NullableStringFieldUpdateOperationsInput | string | null
    phy_advice?: NullableStringFieldUpdateOperationsInput | string | null
    refer_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_type?: Enumreferral_confirmation_details1_ref_typeFieldUpdateOperationsInput | $Enums.referral_confirmation_details1_ref_type
    lab_test_status?: IntFieldUpdateOperationsInput | number
  }

  export type referral_patient_detailsCreateInput = {
    referral_patient_id?: number
    firstname?: string | null
    lastname?: string | null
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    pincode?: string | null
    mailid?: string
    phonenum?: string
    alt_phonenum?: string | null
    password?: string | null
    relationship?: string
    created_on?: string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id?: string | null
    physician_id: string
    status?: string
    r_count?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    main_pat_id?: string | null
    patient_dep_id?: number | null
    count: number
    prescribe_receipt: number
  }

  export type referral_patient_detailsUncheckedCreateInput = {
    referral_patient_id?: number
    firstname?: string | null
    lastname?: string | null
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    pincode?: string | null
    mailid?: string
    phonenum?: string
    alt_phonenum?: string | null
    password?: string | null
    relationship?: string
    created_on?: string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id?: string | null
    physician_id: string
    status?: string
    r_count?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    main_pat_id?: string | null
    patient_dep_id?: number | null
    count: number
    prescribe_receipt: number
  }

  export type referral_patient_detailsUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    alt_phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    main_pat_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type referral_patient_detailsUncheckedUpdateInput = {
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    alt_phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    main_pat_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type referral_patient_detailsCreateManyInput = {
    referral_patient_id?: number
    firstname?: string | null
    lastname?: string | null
    gender?: string | null
    date_of_birth: Date | string
    age?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    pincode?: string | null
    mailid?: string
    phonenum?: string
    alt_phonenum?: string | null
    password?: string | null
    relationship?: string
    created_on?: string | null
    updated_on?: Date | string | null
    active?: number | null
    role_id?: number
    patient_unique_id?: string | null
    physician_id: string
    status?: string
    r_count?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    main_pat_id?: string | null
    patient_dep_id?: number | null
    count: number
    prescribe_receipt: number
  }

  export type referral_patient_detailsUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    alt_phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    main_pat_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type referral_patient_detailsUncheckedUpdateManyInput = {
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mailid?: StringFieldUpdateOperationsInput | string
    phonenum?: StringFieldUpdateOperationsInput | string
    alt_phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
    role_id?: IntFieldUpdateOperationsInput | number
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    r_count?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    main_pat_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    prescribe_receipt?: IntFieldUpdateOperationsInput | number
  }

  export type referral_patient_test_detailsCreateInput = {
    ID?: number
    medical_num?: string | null
    laboratory_tests?: string | null
    parse_parent_id: number
    has_child: number
    time?: string | null
    date?: Date | string | null
    instruction?: string | null
    patient_unique_id?: string | null
    physician_id?: number | null
    laboratory_id?: number | null
    dependent_id?: number | null
    main_patient_id?: number | null
    billing_id: number
    billing_datetime: Date | string
    sample_collected_id: number
    sample_datetime: Date | string
    labapproval_id: number
    labapproval_datetime: Date | string
    pat_status?: number
    report_filename?: string | null
    report_fullpath?: string | null
    approved_lab_doc_id: number
    editor: string
    created_on?: Date | string
  }

  export type referral_patient_test_detailsUncheckedCreateInput = {
    ID?: number
    medical_num?: string | null
    laboratory_tests?: string | null
    parse_parent_id: number
    has_child: number
    time?: string | null
    date?: Date | string | null
    instruction?: string | null
    patient_unique_id?: string | null
    physician_id?: number | null
    laboratory_id?: number | null
    dependent_id?: number | null
    main_patient_id?: number | null
    billing_id: number
    billing_datetime: Date | string
    sample_collected_id: number
    sample_datetime: Date | string
    labapproval_id: number
    labapproval_datetime: Date | string
    pat_status?: number
    report_filename?: string | null
    report_fullpath?: string | null
    approved_lab_doc_id: number
    editor: string
    created_on?: Date | string
  }

  export type referral_patient_test_detailsUpdateInput = {
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_tests?: NullableStringFieldUpdateOperationsInput | string | null
    parse_parent_id?: IntFieldUpdateOperationsInput | number
    has_child?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    dependent_id?: NullableIntFieldUpdateOperationsInput | number | null
    main_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    billing_id?: IntFieldUpdateOperationsInput | number
    billing_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    sample_collected_id?: IntFieldUpdateOperationsInput | number
    sample_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    labapproval_id?: IntFieldUpdateOperationsInput | number
    labapproval_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    pat_status?: IntFieldUpdateOperationsInput | number
    report_filename?: NullableStringFieldUpdateOperationsInput | string | null
    report_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    approved_lab_doc_id?: IntFieldUpdateOperationsInput | number
    editor?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_patient_test_detailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_tests?: NullableStringFieldUpdateOperationsInput | string | null
    parse_parent_id?: IntFieldUpdateOperationsInput | number
    has_child?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    dependent_id?: NullableIntFieldUpdateOperationsInput | number | null
    main_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    billing_id?: IntFieldUpdateOperationsInput | number
    billing_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    sample_collected_id?: IntFieldUpdateOperationsInput | number
    sample_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    labapproval_id?: IntFieldUpdateOperationsInput | number
    labapproval_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    pat_status?: IntFieldUpdateOperationsInput | number
    report_filename?: NullableStringFieldUpdateOperationsInput | string | null
    report_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    approved_lab_doc_id?: IntFieldUpdateOperationsInput | number
    editor?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_patient_test_detailsCreateManyInput = {
    ID?: number
    medical_num?: string | null
    laboratory_tests?: string | null
    parse_parent_id: number
    has_child: number
    time?: string | null
    date?: Date | string | null
    instruction?: string | null
    patient_unique_id?: string | null
    physician_id?: number | null
    laboratory_id?: number | null
    dependent_id?: number | null
    main_patient_id?: number | null
    billing_id: number
    billing_datetime: Date | string
    sample_collected_id: number
    sample_datetime: Date | string
    labapproval_id: number
    labapproval_datetime: Date | string
    pat_status?: number
    report_filename?: string | null
    report_fullpath?: string | null
    approved_lab_doc_id: number
    editor: string
    created_on?: Date | string
  }

  export type referral_patient_test_detailsUpdateManyMutationInput = {
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_tests?: NullableStringFieldUpdateOperationsInput | string | null
    parse_parent_id?: IntFieldUpdateOperationsInput | number
    has_child?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    dependent_id?: NullableIntFieldUpdateOperationsInput | number | null
    main_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    billing_id?: IntFieldUpdateOperationsInput | number
    billing_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    sample_collected_id?: IntFieldUpdateOperationsInput | number
    sample_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    labapproval_id?: IntFieldUpdateOperationsInput | number
    labapproval_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    pat_status?: IntFieldUpdateOperationsInput | number
    report_filename?: NullableStringFieldUpdateOperationsInput | string | null
    report_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    approved_lab_doc_id?: IntFieldUpdateOperationsInput | number
    editor?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_patient_test_detailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    medical_num?: NullableStringFieldUpdateOperationsInput | string | null
    laboratory_tests?: NullableStringFieldUpdateOperationsInput | string | null
    parse_parent_id?: IntFieldUpdateOperationsInput | number
    has_child?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    patient_unique_id?: NullableStringFieldUpdateOperationsInput | string | null
    physician_id?: NullableIntFieldUpdateOperationsInput | number | null
    laboratory_id?: NullableIntFieldUpdateOperationsInput | number | null
    dependent_id?: NullableIntFieldUpdateOperationsInput | number | null
    main_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    billing_id?: IntFieldUpdateOperationsInput | number
    billing_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    sample_collected_id?: IntFieldUpdateOperationsInput | number
    sample_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    labapproval_id?: IntFieldUpdateOperationsInput | number
    labapproval_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    pat_status?: IntFieldUpdateOperationsInput | number
    report_filename?: NullableStringFieldUpdateOperationsInput | string | null
    report_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    approved_lab_doc_id?: IntFieldUpdateOperationsInput | number
    editor?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type relationshipCreateInput = {
    rel_id?: number
    rel_name: string
    active?: number
  }

  export type relationshipUncheckedCreateInput = {
    rel_id?: number
    rel_name: string
    active?: number
  }

  export type relationshipUpdateInput = {
    rel_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type relationshipUncheckedUpdateInput = {
    rel_id?: IntFieldUpdateOperationsInput | number
    rel_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type relationshipCreateManyInput = {
    rel_id?: number
    rel_name: string
    active?: number
  }

  export type relationshipUpdateManyMutationInput = {
    rel_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type relationshipUncheckedUpdateManyInput = {
    rel_id?: IntFieldUpdateOperationsInput | number
    rel_name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type report_templateCreateInput = {
    header: number
    footer: number
    print_size: number
    lab_id: number
    created_on: string
    status?: string
  }

  export type report_templateUncheckedCreateInput = {
    template_id?: number
    header: number
    footer: number
    print_size: number
    lab_id: number
    created_on: string
    status?: string
  }

  export type report_templateUpdateInput = {
    header?: IntFieldUpdateOperationsInput | number
    footer?: IntFieldUpdateOperationsInput | number
    print_size?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    created_on?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type report_templateUncheckedUpdateInput = {
    template_id?: IntFieldUpdateOperationsInput | number
    header?: IntFieldUpdateOperationsInput | number
    footer?: IntFieldUpdateOperationsInput | number
    print_size?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    created_on?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type report_templateCreateManyInput = {
    template_id?: number
    header: number
    footer: number
    print_size: number
    lab_id: number
    created_on: string
    status?: string
  }

  export type report_templateUpdateManyMutationInput = {
    header?: IntFieldUpdateOperationsInput | number
    footer?: IntFieldUpdateOperationsInput | number
    print_size?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    created_on?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type report_templateUncheckedUpdateManyInput = {
    template_id?: IntFieldUpdateOperationsInput | number
    header?: IntFieldUpdateOperationsInput | number
    footer?: IntFieldUpdateOperationsInput | number
    print_size?: IntFieldUpdateOperationsInput | number
    lab_id?: IntFieldUpdateOperationsInput | number
    created_on?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type sample_resultsCreateInput = {
    sample_value: string
    referral_test_ID: number
    created_on: Date | string
  }

  export type sample_resultsUncheckedCreateInput = {
    result_id?: number
    sample_value: string
    referral_test_ID: number
    created_on: Date | string
  }

  export type sample_resultsUpdateInput = {
    sample_value?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sample_resultsUncheckedUpdateInput = {
    result_id?: IntFieldUpdateOperationsInput | number
    sample_value?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sample_resultsCreateManyInput = {
    result_id?: number
    sample_value: string
    referral_test_ID: number
    created_on: Date | string
  }

  export type sample_resultsUpdateManyMutationInput = {
    sample_value?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sample_resultsUncheckedUpdateManyInput = {
    result_id?: IntFieldUpdateOperationsInput | number
    sample_value?: StringFieldUpdateOperationsInput | string
    referral_test_ID?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ssconsultation_billingCreateInput = {
    ss_id: number
    tot_amt?: string | null
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type ssconsultation_billingUncheckedCreateInput = {
    ssbilling_id?: number
    ss_id: number
    tot_amt?: string | null
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type ssconsultation_billingUpdateInput = {
    ss_id?: IntFieldUpdateOperationsInput | number
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ssconsultation_billingUncheckedUpdateInput = {
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    ss_id?: IntFieldUpdateOperationsInput | number
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ssconsultation_billingCreateManyInput = {
    ssbilling_id?: number
    ss_id: number
    tot_amt?: string | null
    lab_id: number
    unique_billid: string
    created_on?: string | null
  }

  export type ssconsultation_billingUpdateManyMutationInput = {
    ss_id?: IntFieldUpdateOperationsInput | number
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ssconsultation_billingUncheckedUpdateManyInput = {
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    ss_id?: IntFieldUpdateOperationsInput | number
    tot_amt?: NullableStringFieldUpdateOperationsInput | string | null
    lab_id?: IntFieldUpdateOperationsInput | number
    unique_billid?: StringFieldUpdateOperationsInput | string
    created_on?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ssconsultation_logCreateInput = {
    ssbilling_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type ssconsultation_logUncheckedCreateInput = {
    ssconsultation_log_id?: number
    ssbilling_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type ssconsultation_logUpdateInput = {
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ssconsultation_logUncheckedUpdateInput = {
    ssconsultation_log_id?: IntFieldUpdateOperationsInput | number
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ssconsultation_logCreateManyInput = {
    ssconsultation_log_id?: number
    ssbilling_id: number
    amt: string
    payment_method: number
    added_date?: Date | string
  }

  export type ssconsultation_logUpdateManyMutationInput = {
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ssconsultation_logUncheckedUpdateManyInput = {
    ssconsultation_log_id?: IntFieldUpdateOperationsInput | number
    ssbilling_id?: IntFieldUpdateOperationsInput | number
    amt?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stateCreateInput = {
    state_name: string
    country_id: number
    active?: boolean
  }

  export type stateUncheckedCreateInput = {
    state_id?: number
    state_name: string
    country_id: number
    active?: boolean
  }

  export type stateUpdateInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    country_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type stateUncheckedUpdateInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    country_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type stateCreateManyInput = {
    state_id?: number
    state_name: string
    country_id: number
    active?: boolean
  }

  export type stateUpdateManyMutationInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    country_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type stateUncheckedUpdateManyInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    country_id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type status_masterCreateInput = {
    status_id?: number
    status: string
  }

  export type status_masterUncheckedCreateInput = {
    status_id?: number
    status: string
  }

  export type status_masterUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type status_masterUncheckedUpdateInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type status_masterCreateManyInput = {
    status_id?: number
    status: string
  }

  export type status_masterUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type status_masterUncheckedUpdateManyInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type super_specialityCreateInput = {
    superspeciality_id?: number
    superspeciality_name?: string | null
    created_on?: Date | string | null
    active?: number
  }

  export type super_specialityUncheckedCreateInput = {
    superspeciality_id?: number
    superspeciality_name?: string | null
    created_on?: Date | string | null
    active?: number
  }

  export type super_specialityUpdateInput = {
    superspeciality_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: IntFieldUpdateOperationsInput | number
  }

  export type super_specialityUncheckedUpdateInput = {
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    superspeciality_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: IntFieldUpdateOperationsInput | number
  }

  export type super_specialityCreateManyInput = {
    superspeciality_id?: number
    superspeciality_name?: string | null
    created_on?: Date | string | null
    active?: number
  }

  export type super_specialityUpdateManyMutationInput = {
    superspeciality_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: IntFieldUpdateOperationsInput | number
  }

  export type super_specialityUncheckedUpdateManyInput = {
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    superspeciality_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_consultationCreateInput = {
    laboratory_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: string
    by_assign: number
    to_assign: number
    referdate: Date | string
    refertime: string
    referclinic_name: string
    consultationId: number
    consultationDate?: Date | string | null
    consultationAmount?: number | null
    miscellaneousAmount?: number | null
    totalAmount?: number | null
    status?: number
  }

  export type superspeciality_consultationUncheckedCreateInput = {
    ss_id?: number
    laboratory_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: string
    by_assign: number
    to_assign: number
    referdate: Date | string
    refertime: string
    referclinic_name: string
    consultationId: number
    consultationDate?: Date | string | null
    consultationAmount?: number | null
    miscellaneousAmount?: number | null
    totalAmount?: number | null
    status?: number
  }

  export type superspeciality_consultationUpdateInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    by_assign?: IntFieldUpdateOperationsInput | number
    to_assign?: IntFieldUpdateOperationsInput | number
    referdate?: DateTimeFieldUpdateOperationsInput | Date | string
    refertime?: StringFieldUpdateOperationsInput | string
    referclinic_name?: StringFieldUpdateOperationsInput | string
    consultationId?: IntFieldUpdateOperationsInput | number
    consultationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultationAmount?: NullableIntFieldUpdateOperationsInput | number | null
    miscellaneousAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_consultationUncheckedUpdateInput = {
    ss_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    by_assign?: IntFieldUpdateOperationsInput | number
    to_assign?: IntFieldUpdateOperationsInput | number
    referdate?: DateTimeFieldUpdateOperationsInput | Date | string
    refertime?: StringFieldUpdateOperationsInput | string
    referclinic_name?: StringFieldUpdateOperationsInput | string
    consultationId?: IntFieldUpdateOperationsInput | number
    consultationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultationAmount?: NullableIntFieldUpdateOperationsInput | number | null
    miscellaneousAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_consultationCreateManyInput = {
    ss_id?: number
    laboratory_id: number
    referral_patient_id: number
    patient_dep_id: number
    superspeciality_id: number
    comments: string
    by_assign: number
    to_assign: number
    referdate: Date | string
    refertime: string
    referclinic_name: string
    consultationId: number
    consultationDate?: Date | string | null
    consultationAmount?: number | null
    miscellaneousAmount?: number | null
    totalAmount?: number | null
    status?: number
  }

  export type superspeciality_consultationUpdateManyMutationInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    by_assign?: IntFieldUpdateOperationsInput | number
    to_assign?: IntFieldUpdateOperationsInput | number
    referdate?: DateTimeFieldUpdateOperationsInput | Date | string
    refertime?: StringFieldUpdateOperationsInput | string
    referclinic_name?: StringFieldUpdateOperationsInput | string
    consultationId?: IntFieldUpdateOperationsInput | number
    consultationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultationAmount?: NullableIntFieldUpdateOperationsInput | number | null
    miscellaneousAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_consultationUncheckedUpdateManyInput = {
    ss_id?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: IntFieldUpdateOperationsInput | number
    patient_dep_id?: IntFieldUpdateOperationsInput | number
    superspeciality_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    by_assign?: IntFieldUpdateOperationsInput | number
    to_assign?: IntFieldUpdateOperationsInput | number
    referdate?: DateTimeFieldUpdateOperationsInput | Date | string
    refertime?: StringFieldUpdateOperationsInput | string
    referclinic_name?: StringFieldUpdateOperationsInput | string
    consultationId?: IntFieldUpdateOperationsInput | number
    consultationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultationAmount?: NullableIntFieldUpdateOperationsInput | number | null
    miscellaneousAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_detailsCreateInput = {
    speciality_id?: number
    referral_patient_id?: number | null
    patient_dep_id?: number | null
    superspeciality_id?: number | null
    comments?: string | null
    by_assign?: number | null
    to_assign?: number | null
    referdate?: Date | string | null
    refertime?: string | null
    referclinic_name?: string | null
    created_on?: Date | string
    active?: number
    laboratory_id?: number
  }

  export type superspeciality_detailsUncheckedCreateInput = {
    speciality_id?: number
    referral_patient_id?: number | null
    patient_dep_id?: number | null
    superspeciality_id?: number | null
    comments?: string | null
    by_assign?: number | null
    to_assign?: number | null
    referdate?: Date | string | null
    refertime?: string | null
    referclinic_name?: string | null
    created_on?: Date | string
    active?: number
    laboratory_id?: number
  }

  export type superspeciality_detailsUpdateInput = {
    referral_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    superspeciality_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    by_assign?: NullableIntFieldUpdateOperationsInput | number | null
    to_assign?: NullableIntFieldUpdateOperationsInput | number | null
    referdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refertime?: NullableStringFieldUpdateOperationsInput | string | null
    referclinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_detailsUncheckedUpdateInput = {
    speciality_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    superspeciality_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    by_assign?: NullableIntFieldUpdateOperationsInput | number | null
    to_assign?: NullableIntFieldUpdateOperationsInput | number | null
    referdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refertime?: NullableStringFieldUpdateOperationsInput | string | null
    referclinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_detailsCreateManyInput = {
    speciality_id?: number
    referral_patient_id?: number | null
    patient_dep_id?: number | null
    superspeciality_id?: number | null
    comments?: string | null
    by_assign?: number | null
    to_assign?: number | null
    referdate?: Date | string | null
    refertime?: string | null
    referclinic_name?: string | null
    created_on?: Date | string
    active?: number
    laboratory_id?: number
  }

  export type superspeciality_detailsUpdateManyMutationInput = {
    referral_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    superspeciality_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    by_assign?: NullableIntFieldUpdateOperationsInput | number | null
    to_assign?: NullableIntFieldUpdateOperationsInput | number | null
    referdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refertime?: NullableStringFieldUpdateOperationsInput | string | null
    referclinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
  }

  export type superspeciality_detailsUncheckedUpdateManyInput = {
    speciality_id?: IntFieldUpdateOperationsInput | number
    referral_patient_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_dep_id?: NullableIntFieldUpdateOperationsInput | number | null
    superspeciality_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    by_assign?: NullableIntFieldUpdateOperationsInput | number | null
    to_assign?: NullableIntFieldUpdateOperationsInput | number | null
    referdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refertime?: NullableStringFieldUpdateOperationsInput | string | null
    referclinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
  }

  export type test_report_notesCreateInput = {
    laboratory_tests: string
    medical_num: string
    referral_patient_test_details_id: number
    title?: string | null
    description: string
    added_date?: Date | string
  }

  export type test_report_notesUncheckedCreateInput = {
    test_report_notes_id?: number
    laboratory_tests: string
    medical_num: string
    referral_patient_test_details_id: number
    title?: string | null
    description: string
    added_date?: Date | string
  }

  export type test_report_notesUpdateInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    referral_patient_test_details_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_report_notesUncheckedUpdateInput = {
    test_report_notes_id?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    referral_patient_test_details_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_report_notesCreateManyInput = {
    test_report_notes_id?: number
    laboratory_tests: string
    medical_num: string
    referral_patient_test_details_id: number
    title?: string | null
    description: string
    added_date?: Date | string
  }

  export type test_report_notesUpdateManyMutationInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    referral_patient_test_details_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_report_notesUncheckedUpdateManyInput = {
    test_report_notes_id?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    medical_num?: StringFieldUpdateOperationsInput | string
    referral_patient_test_details_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    added_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type update_labsCreateInput = {
    laboratory_id: number
    phonenum_doesnt_exist: number
    print_billing: number
    collection_report: number
    test_report: number
    active?: number
  }

  export type update_labsUncheckedCreateInput = {
    update_labid?: number
    laboratory_id: number
    phonenum_doesnt_exist: number
    print_billing: number
    collection_report: number
    test_report: number
    active?: number
  }

  export type update_labsUpdateInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    phonenum_doesnt_exist?: IntFieldUpdateOperationsInput | number
    print_billing?: IntFieldUpdateOperationsInput | number
    collection_report?: IntFieldUpdateOperationsInput | number
    test_report?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type update_labsUncheckedUpdateInput = {
    update_labid?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    phonenum_doesnt_exist?: IntFieldUpdateOperationsInput | number
    print_billing?: IntFieldUpdateOperationsInput | number
    collection_report?: IntFieldUpdateOperationsInput | number
    test_report?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type update_labsCreateManyInput = {
    update_labid?: number
    laboratory_id: number
    phonenum_doesnt_exist: number
    print_billing: number
    collection_report: number
    test_report: number
    active?: number
  }

  export type update_labsUpdateManyMutationInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    phonenum_doesnt_exist?: IntFieldUpdateOperationsInput | number
    print_billing?: IntFieldUpdateOperationsInput | number
    collection_report?: IntFieldUpdateOperationsInput | number
    test_report?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type update_labsUncheckedUpdateManyInput = {
    update_labid?: IntFieldUpdateOperationsInput | number
    laboratory_id?: IntFieldUpdateOperationsInput | number
    phonenum_doesnt_exist?: IntFieldUpdateOperationsInput | number
    print_billing?: IntFieldUpdateOperationsInput | number
    collection_report?: IntFieldUpdateOperationsInput | number
    test_report?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    name: string
    active?: number
    created_on: Date | string
  }

  export type userUncheckedCreateInput = {
    role_id?: number
    name: string
    active?: number
    created_on: Date | string
  }

  export type userUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    role_id?: number
    name: string
    active?: number
    created_on: Date | string
  }

  export type userUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type barcodeCountOrderByAggregateInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
    barcode?: SortOrder
    barcode_image?: SortOrder
    created_date?: SortOrder
  }

  export type barcodeAvgOrderByAggregateInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
  }

  export type barcodeMaxOrderByAggregateInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
    barcode?: SortOrder
    barcode_image?: SortOrder
    created_date?: SortOrder
  }

  export type barcodeMinOrderByAggregateInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
    barcode?: SortOrder
    barcode_image?: SortOrder
    created_date?: SortOrder
  }

  export type barcodeSumOrderByAggregateInput = {
    barcode_id?: SortOrder
    billing_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type billingCountOrderByAggregateInput = {
    billing_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    tot_amt?: SortOrder
    discount?: SortOrder
    discount_type?: SortOrder
    net_amt?: SortOrder
    adv_amt?: SortOrder
    balance_amt?: SortOrder
    balance_pymnt2?: SortOrder
    final_balance?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type billingAvgOrderByAggregateInput = {
    billing_id?: SortOrder
    discount_type?: SortOrder
    lab_id?: SortOrder
  }

  export type billingMaxOrderByAggregateInput = {
    billing_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    tot_amt?: SortOrder
    discount?: SortOrder
    discount_type?: SortOrder
    net_amt?: SortOrder
    adv_amt?: SortOrder
    balance_amt?: SortOrder
    balance_pymnt2?: SortOrder
    final_balance?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type billingMinOrderByAggregateInput = {
    billing_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    tot_amt?: SortOrder
    discount?: SortOrder
    discount_type?: SortOrder
    net_amt?: SortOrder
    adv_amt?: SortOrder
    balance_amt?: SortOrder
    balance_pymnt2?: SortOrder
    final_balance?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type billingSumOrderByAggregateInput = {
    billing_id?: SortOrder
    discount_type?: SortOrder
    lab_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type billing_logCountOrderByAggregateInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type billing_logAvgOrderByAggregateInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    payment_method?: SortOrder
  }

  export type billing_logMaxOrderByAggregateInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type billing_logMinOrderByAggregateInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type billing_logSumOrderByAggregateInput = {
    billing_log_id?: SortOrder
    billing_id?: SortOrder
    payment_method?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type bloodgroup_detailsCountOrderByAggregateInput = {
    bloodgroup_id?: SortOrder
    bloodgroup_name?: SortOrder
    active?: SortOrder
  }

  export type bloodgroup_detailsAvgOrderByAggregateInput = {
    bloodgroup_id?: SortOrder
    active?: SortOrder
  }

  export type bloodgroup_detailsMaxOrderByAggregateInput = {
    bloodgroup_id?: SortOrder
    bloodgroup_name?: SortOrder
    active?: SortOrder
  }

  export type bloodgroup_detailsMinOrderByAggregateInput = {
    bloodgroup_id?: SortOrder
    bloodgroup_name?: SortOrder
    active?: SortOrder
  }

  export type bloodgroup_detailsSumOrderByAggregateInput = {
    bloodgroup_id?: SortOrder
    active?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type cityCountOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    active?: SortOrder
  }

  export type cityAvgOrderByAggregateInput = {
    city_id?: SortOrder
    state_id?: SortOrder
  }

  export type cityMaxOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    active?: SortOrder
  }

  export type cityMinOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    active?: SortOrder
  }

  export type citySumOrderByAggregateInput = {
    city_id?: SortOrder
    state_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type clinic_module_activation_requestCountOrderByAggregateInput = {
    clinic_module_activation_request_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_num?: SortOrder
    physicianid?: SortOrder
    message?: SortOrder
    is_activated?: SortOrder
    added_date?: SortOrder
  }

  export type clinic_module_activation_requestAvgOrderByAggregateInput = {
    clinic_module_activation_request_id?: SortOrder
    physicianid?: SortOrder
    is_activated?: SortOrder
  }

  export type clinic_module_activation_requestMaxOrderByAggregateInput = {
    clinic_module_activation_request_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_num?: SortOrder
    physicianid?: SortOrder
    message?: SortOrder
    is_activated?: SortOrder
    added_date?: SortOrder
  }

  export type clinic_module_activation_requestMinOrderByAggregateInput = {
    clinic_module_activation_request_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_num?: SortOrder
    physicianid?: SortOrder
    message?: SortOrder
    is_activated?: SortOrder
    added_date?: SortOrder
  }

  export type clinic_module_activation_requestSumOrderByAggregateInput = {
    clinic_module_activation_request_id?: SortOrder
    physicianid?: SortOrder
    is_activated?: SortOrder
  }

  export type clinical_parametersCountOrderByAggregateInput = {
    clinical_parameterid?: SortOrder
    blood_pressure?: SortOrder
    systolic_blood_pressure?: SortOrder
    diastolic_blood_pressure?: SortOrder
    sugar?: SortOrder
    pulse?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    temperature?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type clinical_parametersAvgOrderByAggregateInput = {
    clinical_parameterid?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
  }

  export type clinical_parametersMaxOrderByAggregateInput = {
    clinical_parameterid?: SortOrder
    blood_pressure?: SortOrder
    systolic_blood_pressure?: SortOrder
    diastolic_blood_pressure?: SortOrder
    sugar?: SortOrder
    pulse?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    temperature?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type clinical_parametersMinOrderByAggregateInput = {
    clinical_parameterid?: SortOrder
    blood_pressure?: SortOrder
    systolic_blood_pressure?: SortOrder
    diastolic_blood_pressure?: SortOrder
    sugar?: SortOrder
    pulse?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    temperature?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type clinical_parametersSumOrderByAggregateInput = {
    clinical_parameterid?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
  }

  export type contactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emailid?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_date?: SortOrder
  }

  export type contactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type contactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emailid?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_date?: SortOrder
  }

  export type contactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emailid?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    created_date?: SortOrder
  }

  export type contactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type countryCountOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    active?: SortOrder
  }

  export type countryAvgOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type countryMaxOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    active?: SortOrder
  }

  export type countryMinOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    active?: SortOrder
  }

  export type countrySumOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type Enumfiles_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.files_status | Enumfiles_statusFieldRefInput<$PrismaModel>
    in?: $Enums.files_status[]
    notIn?: $Enums.files_status[]
    not?: NestedEnumfiles_statusFilter<$PrismaModel> | $Enums.files_status
  }

  export type filesCountOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    type?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    referral_id?: SortOrder
    uploaded_on?: SortOrder
    status?: SortOrder
  }

  export type filesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filesMaxOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    type?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    referral_id?: SortOrder
    uploaded_on?: SortOrder
    status?: SortOrder
  }

  export type filesMinOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    type?: SortOrder
    medical_num?: SortOrder
    patient_unique_id?: SortOrder
    referral_id?: SortOrder
    uploaded_on?: SortOrder
    status?: SortOrder
  }

  export type filesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumfiles_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.files_status | Enumfiles_statusFieldRefInput<$PrismaModel>
    in?: $Enums.files_status[]
    notIn?: $Enums.files_status[]
    not?: NestedEnumfiles_statusWithAggregatesFilter<$PrismaModel> | $Enums.files_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfiles_statusFilter<$PrismaModel>
    _max?: NestedEnumfiles_statusFilter<$PrismaModel>
  }

  export type Investigation_test_detailsListRelationFilter = {
    every?: investigation_test_detailsWhereInput
    some?: investigation_test_detailsWhereInput
    none?: investigation_test_detailsWhereInput
  }

  export type investigation_test_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type investigation_detailsCountOrderByAggregateInput = {
    investigation_id?: SortOrder
    investigation_name?: SortOrder
    active?: SortOrder
  }

  export type investigation_detailsAvgOrderByAggregateInput = {
    investigation_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_detailsMaxOrderByAggregateInput = {
    investigation_id?: SortOrder
    investigation_name?: SortOrder
    active?: SortOrder
  }

  export type investigation_detailsMinOrderByAggregateInput = {
    investigation_id?: SortOrder
    investigation_name?: SortOrder
    active?: SortOrder
  }

  export type investigation_detailsSumOrderByAggregateInput = {
    investigation_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_fileCountOrderByAggregateInput = {
    file_id?: SortOrder
    investigation_file?: SortOrder
    referral_test_ID?: SortOrder
    uploaded_on?: SortOrder
  }

  export type investigation_fileAvgOrderByAggregateInput = {
    file_id?: SortOrder
    referral_test_ID?: SortOrder
  }

  export type investigation_fileMaxOrderByAggregateInput = {
    file_id?: SortOrder
    investigation_file?: SortOrder
    referral_test_ID?: SortOrder
    uploaded_on?: SortOrder
  }

  export type investigation_fileMinOrderByAggregateInput = {
    file_id?: SortOrder
    investigation_file?: SortOrder
    referral_test_ID?: SortOrder
    uploaded_on?: SortOrder
  }

  export type investigation_fileSumOrderByAggregateInput = {
    file_id?: SortOrder
    referral_test_ID?: SortOrder
  }

  export type Investigation_detailsRelationFilter = {
    is?: investigation_detailsWhereInput
    isNot?: investigation_detailsWhereInput
  }

  export type investigation_test_detailsCountOrderByAggregateInput = {
    parse_id?: SortOrder
    test_name?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_test_detailsAvgOrderByAggregateInput = {
    parse_id?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_test_detailsMaxOrderByAggregateInput = {
    parse_id?: SortOrder
    test_name?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_test_detailsMinOrderByAggregateInput = {
    parse_id?: SortOrder
    test_name?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
  }

  export type investigation_test_detailsSumOrderByAggregateInput = {
    parse_id?: SortOrder
    investigation_id?: SortOrder
    parent_parse_id?: SortOrder
    active?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type lab_leavesCountOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type lab_leavesAvgOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type lab_leavesMaxOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type lab_leavesMinOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type lab_leavesSumOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type lab_tests_price_updatesCountOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    test_id?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    created_date?: SortOrder
    created_by?: SortOrder
    created_by_phone_num?: SortOrder
  }

  export type lab_tests_price_updatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type lab_tests_price_updatesMaxOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    test_id?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    created_date?: SortOrder
    created_by?: SortOrder
    created_by_phone_num?: SortOrder
  }

  export type lab_tests_price_updatesMinOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    test_id?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    created_date?: SortOrder
    created_by?: SortOrder
    created_by_phone_num?: SortOrder
  }

  export type lab_tests_price_updatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumlab_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.lab_timings_work_type | Enumlab_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.lab_timings_work_type[]
    notIn?: $Enums.lab_timings_work_type[]
    not?: NestedEnumlab_timings_work_typeFilter<$PrismaModel> | $Enums.lab_timings_work_type
  }

  export type lab_timingsCountOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type lab_timingsAvgOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type lab_timingsMaxOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type lab_timingsMinOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type lab_timingsSumOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type Enumlab_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.lab_timings_work_type | Enumlab_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.lab_timings_work_type[]
    notIn?: $Enums.lab_timings_work_type[]
    not?: NestedEnumlab_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.lab_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlab_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumlab_timings_work_typeFilter<$PrismaModel>
  }

  export type Laboratory_test_detailsListRelationFilter = {
    every?: laboratory_test_detailsWhereInput
    some?: laboratory_test_detailsWhereInput
    none?: laboratory_test_detailsWhereInput
  }

  export type laboratory_test_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type laboratory_detailsLaboratory_phoneLaboratory_emailCompoundUniqueInput = {
    laboratory_phone: string
    laboratory_email: string
  }

  export type laboratory_detailsCountOrderByAggregateInput = {
    laboratory_id?: SortOrder
    laboratory_name?: SortOrder
    laboratory_address?: SortOrder
    locality?: SortOrder
    laboratory_phone?: SortOrder
    laboratory_email?: SortOrder
    laboratory_password?: SortOrder
    lab_state?: SortOrder
    lab_city?: SortOrder
    lab_pincode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
  }

  export type laboratory_detailsAvgOrderByAggregateInput = {
    laboratory_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
  }

  export type laboratory_detailsMaxOrderByAggregateInput = {
    laboratory_id?: SortOrder
    laboratory_name?: SortOrder
    laboratory_address?: SortOrder
    locality?: SortOrder
    laboratory_phone?: SortOrder
    laboratory_email?: SortOrder
    laboratory_password?: SortOrder
    lab_state?: SortOrder
    lab_city?: SortOrder
    lab_pincode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
  }

  export type laboratory_detailsMinOrderByAggregateInput = {
    laboratory_id?: SortOrder
    laboratory_name?: SortOrder
    laboratory_address?: SortOrder
    locality?: SortOrder
    laboratory_phone?: SortOrder
    laboratory_email?: SortOrder
    laboratory_password?: SortOrder
    lab_state?: SortOrder
    lab_city?: SortOrder
    lab_pincode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
  }

  export type laboratory_detailsSumOrderByAggregateInput = {
    laboratory_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
  }

  export type laboratory_doctorsCountOrderByAggregateInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_firstname?: SortOrder
    doc_lastname?: SortOrder
    doc_password?: SortOrder
    doc_phone_number?: SortOrder
    doc_email?: SortOrder
    doc_dept?: SortOrder
    doc_signature?: SortOrder
    added_date?: SortOrder
    doc_designation?: SortOrder
    is_active?: SortOrder
  }

  export type laboratory_doctorsAvgOrderByAggregateInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_dept?: SortOrder
    is_active?: SortOrder
  }

  export type laboratory_doctorsMaxOrderByAggregateInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_firstname?: SortOrder
    doc_lastname?: SortOrder
    doc_password?: SortOrder
    doc_phone_number?: SortOrder
    doc_email?: SortOrder
    doc_dept?: SortOrder
    doc_signature?: SortOrder
    added_date?: SortOrder
    doc_designation?: SortOrder
    is_active?: SortOrder
  }

  export type laboratory_doctorsMinOrderByAggregateInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_firstname?: SortOrder
    doc_lastname?: SortOrder
    doc_password?: SortOrder
    doc_phone_number?: SortOrder
    doc_email?: SortOrder
    doc_dept?: SortOrder
    doc_signature?: SortOrder
    added_date?: SortOrder
    doc_designation?: SortOrder
    is_active?: SortOrder
  }

  export type laboratory_doctorsSumOrderByAggregateInput = {
    laboratory_doctors_id?: SortOrder
    laboratory_id?: SortOrder
    doc_dept?: SortOrder
    is_active?: SortOrder
  }

  export type Enumlaboratory_test_details_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.laboratory_test_details_status | Enumlaboratory_test_details_statusFieldRefInput<$PrismaModel>
    in?: $Enums.laboratory_test_details_status[]
    notIn?: $Enums.laboratory_test_details_status[]
    not?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel> | $Enums.laboratory_test_details_status
  }

  export type Laboratory_detailsRelationFilter = {
    is?: laboratory_detailsWhereInput
    isNot?: laboratory_detailsWhereInput
  }

  export type laboratory_test_detailsCountOrderByAggregateInput = {
    laboratory_testid?: SortOrder
    laboratory_tests?: SortOrder
    code?: SortOrder
    display_order?: SortOrder
    mnemonics?: SortOrder
    test_type?: SortOrder
    sub_department?: SortOrder
    sample_type?: SortOrder
    container_type?: SortOrder
    confidential?: SortOrder
    methodology?: SortOrder
    transport_temperature?: SortOrder
    tat?: SortOrder
    outsourcing_status?: SortOrder
    instrument?: SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    custom_test_name?: SortOrder
    instruction?: SortOrder
    test_method?: SortOrder
    status?: SortOrder
    status_changed_by?: SortOrder
    status_changed_on?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    age_gender_specific?: SortOrder
    critical_alert?: SortOrder
    interpretation?: SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
  }

  export type laboratory_test_detailsAvgOrderByAggregateInput = {
    laboratory_testid?: SortOrder
    display_order?: SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
  }

  export type laboratory_test_detailsMaxOrderByAggregateInput = {
    laboratory_testid?: SortOrder
    laboratory_tests?: SortOrder
    code?: SortOrder
    display_order?: SortOrder
    mnemonics?: SortOrder
    test_type?: SortOrder
    sub_department?: SortOrder
    sample_type?: SortOrder
    container_type?: SortOrder
    confidential?: SortOrder
    methodology?: SortOrder
    transport_temperature?: SortOrder
    tat?: SortOrder
    outsourcing_status?: SortOrder
    instrument?: SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    custom_test_name?: SortOrder
    instruction?: SortOrder
    test_method?: SortOrder
    status?: SortOrder
    status_changed_by?: SortOrder
    status_changed_on?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    age_gender_specific?: SortOrder
    critical_alert?: SortOrder
    interpretation?: SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
  }

  export type laboratory_test_detailsMinOrderByAggregateInput = {
    laboratory_testid?: SortOrder
    laboratory_tests?: SortOrder
    code?: SortOrder
    display_order?: SortOrder
    mnemonics?: SortOrder
    test_type?: SortOrder
    sub_department?: SortOrder
    sample_type?: SortOrder
    container_type?: SortOrder
    confidential?: SortOrder
    methodology?: SortOrder
    transport_temperature?: SortOrder
    tat?: SortOrder
    outsourcing_status?: SortOrder
    instrument?: SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    custom_test_name?: SortOrder
    instruction?: SortOrder
    test_method?: SortOrder
    status?: SortOrder
    status_changed_by?: SortOrder
    status_changed_on?: SortOrder
    unit?: SortOrder
    reference_range?: SortOrder
    age_gender_specific?: SortOrder
    critical_alert?: SortOrder
    interpretation?: SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
  }

  export type laboratory_test_detailsSumOrderByAggregateInput = {
    laboratory_testid?: SortOrder
    display_order?: SortOrder
    laboratory_id?: SortOrder
    test_price?: SortOrder
    sort_order?: SortOrder
    title_required?: SortOrder
  }

  export type Enumlaboratory_test_details_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.laboratory_test_details_status | Enumlaboratory_test_details_statusFieldRefInput<$PrismaModel>
    in?: $Enums.laboratory_test_details_status[]
    notIn?: $Enums.laboratory_test_details_status[]
    not?: NestedEnumlaboratory_test_details_statusWithAggregatesFilter<$PrismaModel> | $Enums.laboratory_test_details_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel>
    _max?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel>
  }

  export type localityCountOrderByAggregateInput = {
    locality_id?: SortOrder
    locality_name?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type localityAvgOrderByAggregateInput = {
    locality_id?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type localityMaxOrderByAggregateInput = {
    locality_id?: SortOrder
    locality_name?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type localityMinOrderByAggregateInput = {
    locality_id?: SortOrder
    locality_name?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type localitySumOrderByAggregateInput = {
    locality_id?: SortOrder
    city_id?: SortOrder
    active?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type login_detailsCountOrderByAggregateInput = {
    login_id?: SortOrder
    firstname?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    patient_id?: SortOrder
    phy_admin_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phone_num?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    last_login?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    otp?: SortOrder
    device_id?: SortOrder
    player_id?: SortOrder
  }

  export type login_detailsAvgOrderByAggregateInput = {
    login_id?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    patient_id?: SortOrder
    phy_admin_id?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    otp?: SortOrder
  }

  export type login_detailsMaxOrderByAggregateInput = {
    login_id?: SortOrder
    firstname?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    patient_id?: SortOrder
    phy_admin_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phone_num?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    last_login?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    otp?: SortOrder
    device_id?: SortOrder
    player_id?: SortOrder
  }

  export type login_detailsMinOrderByAggregateInput = {
    login_id?: SortOrder
    firstname?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    patient_id?: SortOrder
    phy_admin_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    phone_num?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    last_login?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    otp?: SortOrder
    device_id?: SortOrder
    player_id?: SortOrder
  }

  export type login_detailsSumOrderByAggregateInput = {
    login_id?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    patient_id?: SortOrder
    phy_admin_id?: SortOrder
    state?: SortOrder
    city?: SortOrder
    count?: SortOrder
    role_id?: SortOrder
    active?: SortOrder
    otp?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type medicineCountOrderByAggregateInput = {
    ID?: SortOrder
    medicine_name?: SortOrder
    active?: SortOrder
  }

  export type medicineAvgOrderByAggregateInput = {
    ID?: SortOrder
    active?: SortOrder
  }

  export type medicineMaxOrderByAggregateInput = {
    ID?: SortOrder
    medicine_name?: SortOrder
    active?: SortOrder
  }

  export type medicineMinOrderByAggregateInput = {
    ID?: SortOrder
    medicine_name?: SortOrder
    active?: SortOrder
  }

  export type medicineSumOrderByAggregateInput = {
    ID?: SortOrder
    active?: SortOrder
  }

  export type notification_keysCountOrderByAggregateInput = {
    notification_keys_id?: SortOrder
    app_id?: SortOrder
    rest_api_key?: SortOrder
  }

  export type notification_keysAvgOrderByAggregateInput = {
    notification_keys_id?: SortOrder
  }

  export type notification_keysMaxOrderByAggregateInput = {
    notification_keys_id?: SortOrder
    app_id?: SortOrder
    rest_api_key?: SortOrder
  }

  export type notification_keysMinOrderByAggregateInput = {
    notification_keys_id?: SortOrder
    app_id?: SortOrder
    rest_api_key?: SortOrder
  }

  export type notification_keysSumOrderByAggregateInput = {
    notification_keys_id?: SortOrder
  }

  export type notificationattemptCountOrderByAggregateInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_heading?: SortOrder
    notification_message?: SortOrder
    notification_type?: SortOrder
    CreatedDateTime?: SortOrder
    notification_medium?: SortOrder
    SendDateTime?: SortOrder
    status?: SortOrder
  }

  export type notificationattemptAvgOrderByAggregateInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_medium?: SortOrder
    status?: SortOrder
  }

  export type notificationattemptMaxOrderByAggregateInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_heading?: SortOrder
    notification_message?: SortOrder
    notification_type?: SortOrder
    CreatedDateTime?: SortOrder
    notification_medium?: SortOrder
    SendDateTime?: SortOrder
    status?: SortOrder
  }

  export type notificationattemptMinOrderByAggregateInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_heading?: SortOrder
    notification_message?: SortOrder
    notification_type?: SortOrder
    CreatedDateTime?: SortOrder
    notification_medium?: SortOrder
    SendDateTime?: SortOrder
    status?: SortOrder
  }

  export type notificationattemptSumOrderByAggregateInput = {
    notificationattempt_id?: SortOrder
    login_id?: SortOrder
    notification_medium?: SortOrder
    status?: SortOrder
  }

  export type RenamedpackageCountOrderByAggregateInput = {
    id?: SortOrder
    package_name?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type RenamedpackageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RenamedpackageMaxOrderByAggregateInput = {
    id?: SortOrder
    package_name?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type RenamedpackageMinOrderByAggregateInput = {
    id?: SortOrder
    package_name?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type RenamedpackageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type package_containsCountOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    test_id?: SortOrder
    created_on?: SortOrder
    is_active?: SortOrder
  }

  export type package_containsAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
  }

  export type package_containsMaxOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    test_id?: SortOrder
    created_on?: SortOrder
    is_active?: SortOrder
  }

  export type package_containsMinOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    test_id?: SortOrder
    created_on?: SortOrder
    is_active?: SortOrder
  }

  export type package_containsSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
  }

  export type package_labsCountOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    package_price?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type package_labsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type package_labsMaxOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    package_price?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type package_labsMinOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    package_price?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type package_labsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type package_queueCountOrderByAggregateInput = {
    id?: SortOrder
    medical_num?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    referdate?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    package_status?: SortOrder
  }

  export type package_queueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type package_queueMaxOrderByAggregateInput = {
    id?: SortOrder
    medical_num?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    referdate?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    package_status?: SortOrder
  }

  export type package_queueMinOrderByAggregateInput = {
    id?: SortOrder
    medical_num?: SortOrder
    package_id?: SortOrder
    lab_id?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    referdate?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    package_status?: SortOrder
  }

  export type package_queueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type patient_dep_detailsCountOrderByAggregateInput = {
    patient_dep_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    relationship?: SortOrder
    main_pat_id?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_dep_detailsAvgOrderByAggregateInput = {
    patient_dep_id?: SortOrder
    main_pat_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_dep_detailsMaxOrderByAggregateInput = {
    patient_dep_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    relationship?: SortOrder
    main_pat_id?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_dep_detailsMinOrderByAggregateInput = {
    patient_dep_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    relationship?: SortOrder
    main_pat_id?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_dep_detailsSumOrderByAggregateInput = {
    patient_dep_id?: SortOrder
    main_pat_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    r_count?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type patient_doctor_mappingCountOrderByAggregateInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
    patient_unique_id?: SortOrder
    added_date?: SortOrder
  }

  export type patient_doctor_mappingAvgOrderByAggregateInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
  }

  export type patient_doctor_mappingMaxOrderByAggregateInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
    patient_unique_id?: SortOrder
    added_date?: SortOrder
  }

  export type patient_doctor_mappingMinOrderByAggregateInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
    patient_unique_id?: SortOrder
    added_date?: SortOrder
  }

  export type patient_doctor_mappingSumOrderByAggregateInput = {
    patient_doctor_mapping_id?: SortOrder
    referral_patient_id?: SortOrder
    prev_physician_id?: SortOrder
    new_physician_id?: SortOrder
  }

  export type patient_parameterCountOrderByAggregateInput = {
    parameter_id?: SortOrder
    date_of_birth?: SortOrder
    known_allergies?: SortOrder
    previous_medical_history?: SortOrder
    blood_group?: SortOrder
    diabetic?: SortOrder
    hypertension?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type patient_parameterAvgOrderByAggregateInput = {
    parameter_id?: SortOrder
    blood_group?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
  }

  export type patient_parameterMaxOrderByAggregateInput = {
    parameter_id?: SortOrder
    date_of_birth?: SortOrder
    known_allergies?: SortOrder
    previous_medical_history?: SortOrder
    blood_group?: SortOrder
    diabetic?: SortOrder
    hypertension?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type patient_parameterMinOrderByAggregateInput = {
    parameter_id?: SortOrder
    date_of_birth?: SortOrder
    known_allergies?: SortOrder
    previous_medical_history?: SortOrder
    blood_group?: SortOrder
    diabetic?: SortOrder
    hypertension?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    created_on?: SortOrder
  }

  export type patient_parameterSumOrderByAggregateInput = {
    parameter_id?: SortOrder
    blood_group?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
  }

  export type patientqueueCountOrderByAggregateInput = {
    patientqueue_id?: SortOrder
    BillId?: SortOrder
    medical_num?: SortOrder
    firstname?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    refer_date?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    phyfname?: SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
    created_on?: SortOrder
  }

  export type patientqueueAvgOrderByAggregateInput = {
    patientqueue_id?: SortOrder
    physician_id?: SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
  }

  export type patientqueueMaxOrderByAggregateInput = {
    patientqueue_id?: SortOrder
    BillId?: SortOrder
    medical_num?: SortOrder
    firstname?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    refer_date?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    phyfname?: SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
    created_on?: SortOrder
  }

  export type patientqueueMinOrderByAggregateInput = {
    patientqueue_id?: SortOrder
    BillId?: SortOrder
    medical_num?: SortOrder
    firstname?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    refer_date?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    phyfname?: SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
    created_on?: SortOrder
  }

  export type patientqueueSumOrderByAggregateInput = {
    patientqueue_id?: SortOrder
    physician_id?: SortOrder
    referred_id?: SortOrder
    ID?: SortOrder
    billing_id?: SortOrder
    laboratory_id?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
    is_sync?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    prescription_num?: SortOrder
    reg_fee?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    mode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    submitted?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    submitted?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    prescription_num?: SortOrder
    reg_fee?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    mode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    submitted?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    prescription_num?: SortOrder
    reg_fee?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    mode?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    submitted?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    ID?: SortOrder
    doctor_id?: SortOrder
    referral_patient_id?: SortOrder
    dependent_id?: SortOrder
    Receipt_id?: SortOrder
    con_price?: SortOrder
    med_price?: SortOrder
    inv_price?: SortOrder
    admin_price?: SortOrder
    total_price?: SortOrder
    submitted?: SortOrder
  }

  export type Physician_appointmentRelationFilter = {
    is?: physician_appointmentWhereInput
    isNot?: physician_appointmentWhereInput
  }

  export type phy_adminCountOrderByAggregateInput = {
    phy_admin_id?: SortOrder
    phy_admin_name?: SortOrder
    phy_admin_phone?: SortOrder
    phy_admin_mail_id?: SortOrder
    phy_admin_password?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    created_by?: SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
  }

  export type phy_adminAvgOrderByAggregateInput = {
    phy_admin_id?: SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
  }

  export type phy_adminMaxOrderByAggregateInput = {
    phy_admin_id?: SortOrder
    phy_admin_name?: SortOrder
    phy_admin_phone?: SortOrder
    phy_admin_mail_id?: SortOrder
    phy_admin_password?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    created_by?: SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
  }

  export type phy_adminMinOrderByAggregateInput = {
    phy_admin_id?: SortOrder
    phy_admin_name?: SortOrder
    phy_admin_phone?: SortOrder
    phy_admin_mail_id?: SortOrder
    phy_admin_password?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    created_by?: SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
  }

  export type phy_adminSumOrderByAggregateInput = {
    phy_admin_id?: SortOrder
    physician_id?: SortOrder
    active?: SortOrder
    is_visible?: SortOrder
    role_id?: SortOrder
  }

  export type Phy_adminListRelationFilter = {
    every?: phy_adminWhereInput
    some?: phy_adminWhereInput
    none?: phy_adminWhereInput
  }

  export type phy_adminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type physician_appointmentMail_idPhone_numCompoundUniqueInput = {
    mail_id: string
    phone_num: string
  }

  export type physician_appointmentCountOrderByAggregateInput = {
    physician_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone_num?: SortOrder
    alternate_phone_number?: SortOrder
    mail_id?: SortOrder
    pincode?: SortOrder
    clinic_name?: SortOrder
    clinic_phonenum?: SortOrder
    clinic_alternate_phonenum?: SortOrder
    clinic_manager?: SortOrder
    specialization?: SortOrder
    address?: SortOrder
    consultation_fee_validity?: SortOrder
    city?: SortOrder
    state?: SortOrder
    active?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    qualification_id?: SortOrder
    registration_number?: SortOrder
    time_span?: SortOrder
    status?: SortOrder
    locality?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
    Signature_image?: SortOrder
  }

  export type physician_appointmentAvgOrderByAggregateInput = {
    physician_id?: SortOrder
    pincode?: SortOrder
    role_id?: SortOrder
    qualification_id?: SortOrder
    status?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
  }

  export type physician_appointmentMaxOrderByAggregateInput = {
    physician_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone_num?: SortOrder
    alternate_phone_number?: SortOrder
    mail_id?: SortOrder
    pincode?: SortOrder
    clinic_name?: SortOrder
    clinic_phonenum?: SortOrder
    clinic_alternate_phonenum?: SortOrder
    clinic_manager?: SortOrder
    specialization?: SortOrder
    address?: SortOrder
    consultation_fee_validity?: SortOrder
    city?: SortOrder
    state?: SortOrder
    active?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    qualification_id?: SortOrder
    registration_number?: SortOrder
    time_span?: SortOrder
    status?: SortOrder
    locality?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
    Signature_image?: SortOrder
  }

  export type physician_appointmentMinOrderByAggregateInput = {
    physician_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone_num?: SortOrder
    alternate_phone_number?: SortOrder
    mail_id?: SortOrder
    pincode?: SortOrder
    clinic_name?: SortOrder
    clinic_phonenum?: SortOrder
    clinic_alternate_phonenum?: SortOrder
    clinic_manager?: SortOrder
    specialization?: SortOrder
    address?: SortOrder
    consultation_fee_validity?: SortOrder
    city?: SortOrder
    state?: SortOrder
    active?: SortOrder
    created_by?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    qualification_id?: SortOrder
    registration_number?: SortOrder
    time_span?: SortOrder
    status?: SortOrder
    locality?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
    Signature_image?: SortOrder
  }

  export type physician_appointmentSumOrderByAggregateInput = {
    physician_id?: SortOrder
    pincode?: SortOrder
    role_id?: SortOrder
    qualification_id?: SortOrder
    status?: SortOrder
    created_by_id?: SortOrder
    clinic_module_activated?: SortOrder
  }

  export type Enumphysician_clinic_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_clinic_timings_work_type | Enumphysician_clinic_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_clinic_timings_work_type[]
    notIn?: $Enums.physician_clinic_timings_work_type[]
    not?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel> | $Enums.physician_clinic_timings_work_type
  }

  export type physician_clinic_timingsCountOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    clinic?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_clinic_timingsAvgOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type physician_clinic_timingsMaxOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    clinic?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_clinic_timingsMinOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    clinic?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_clinic_timingsSumOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type Enumphysician_clinic_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_clinic_timings_work_type | Enumphysician_clinic_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_clinic_timings_work_type[]
    notIn?: $Enums.physician_clinic_timings_work_type[]
    not?: NestedEnumphysician_clinic_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.physician_clinic_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel>
  }

  export type physician_leavesCountOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type physician_leavesAvgOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type physician_leavesMaxOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type physician_leavesMinOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    dates?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    reason?: SortOrder
    created_time?: SortOrder
  }

  export type physician_leavesSumOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type Enumphysician_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_timings_work_type | Enumphysician_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_timings_work_type[]
    notIn?: $Enums.physician_timings_work_type[]
    not?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel> | $Enums.physician_timings_work_type
  }

  export type physician_timingsCountOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_timingsAvgOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type physician_timingsMaxOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_timingsMinOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
    theday?: SortOrder
    work_type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_time?: SortOrder
    updated_time?: SortOrder
  }

  export type physician_timingsSumOrderByAggregateInput = {
    id?: SortOrder
    physician_id?: SortOrder
  }

  export type Enumphysician_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_timings_work_type | Enumphysician_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_timings_work_type[]
    notIn?: $Enums.physician_timings_work_type[]
    not?: NestedEnumphysician_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.physician_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel>
  }

  export type preferredlabsCountOrderByAggregateInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type preferredlabsAvgOrderByAggregateInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type preferredlabsMaxOrderByAggregateInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type preferredlabsMinOrderByAggregateInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type preferredlabsSumOrderByAggregateInput = {
    preferredlabs_id?: SortOrder
    laboratory_id?: SortOrder
    physician_id?: SortOrder
    is_active?: SortOrder
  }

  export type prescriptionCountOrderByAggregateInput = {
    prescription_id?: SortOrder
    prescription_num?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    created_on?: SortOrder
  }

  export type prescriptionAvgOrderByAggregateInput = {
    prescription_id?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type prescriptionMaxOrderByAggregateInput = {
    prescription_id?: SortOrder
    prescription_num?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    created_on?: SortOrder
  }

  export type prescriptionMinOrderByAggregateInput = {
    prescription_id?: SortOrder
    prescription_num?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    created_on?: SortOrder
  }

  export type prescriptionSumOrderByAggregateInput = {
    prescription_id?: SortOrder
    patient_id?: SortOrder
    dependent_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type prescription_medicineCountOrderByAggregateInput = {
    medicine_id?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    prescription_id?: SortOrder
  }

  export type prescription_medicineAvgOrderByAggregateInput = {
    medicine_id?: SortOrder
    prescription_id?: SortOrder
  }

  export type prescription_medicineMaxOrderByAggregateInput = {
    medicine_id?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    prescription_id?: SortOrder
  }

  export type prescription_medicineMinOrderByAggregateInput = {
    medicine_id?: SortOrder
    type?: SortOrder
    med_name?: SortOrder
    mg?: SortOrder
    dose?: SortOrder
    num_days?: SortOrder
    instruction?: SortOrder
    advice?: SortOrder
    prescription_id?: SortOrder
  }

  export type prescription_medicineSumOrderByAggregateInput = {
    medicine_id?: SortOrder
    prescription_id?: SortOrder
  }

  export type qualificationCountOrderByAggregateInput = {
    qualification_id?: SortOrder
    qualification_name?: SortOrder
    is_active?: SortOrder
  }

  export type qualificationAvgOrderByAggregateInput = {
    qualification_id?: SortOrder
    is_active?: SortOrder
  }

  export type qualificationMaxOrderByAggregateInput = {
    qualification_id?: SortOrder
    qualification_name?: SortOrder
    is_active?: SortOrder
  }

  export type qualificationMinOrderByAggregateInput = {
    qualification_id?: SortOrder
    qualification_name?: SortOrder
    is_active?: SortOrder
  }

  export type qualificationSumOrderByAggregateInput = {
    qualification_id?: SortOrder
    is_active?: SortOrder
  }

  export type qualification_mappingCountOrderByAggregateInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type qualification_mappingAvgOrderByAggregateInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type qualification_mappingMaxOrderByAggregateInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type qualification_mappingMinOrderByAggregateInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type qualification_mappingSumOrderByAggregateInput = {
    qualification_mapping_id?: SortOrder
    qualification_id?: SortOrder
    physician_id?: SortOrder
  }

  export type Enumreferral_confirmation_details_ref_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details_ref_type | Enumreferral_confirmation_details_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details_ref_type[]
    notIn?: $Enums.referral_confirmation_details_ref_type[]
    not?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel> | $Enums.referral_confirmation_details_ref_type
  }

  export type referral_confirmation_detailsCountOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type referral_confirmation_detailsAvgOrderByAggregateInput = {
    referred_id?: SortOrder
    referral_pat_id?: SortOrder
    attempts?: SortOrder
    login_id?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type referral_confirmation_detailsMaxOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type referral_confirmation_detailsMinOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type referral_confirmation_detailsSumOrderByAggregateInput = {
    referred_id?: SortOrder
    referral_pat_id?: SortOrder
    attempts?: SortOrder
    login_id?: SortOrder
    lab_test_status?: SortOrder
    billing_status?: SortOrder
  }

  export type Enumreferral_confirmation_details_ref_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details_ref_type | Enumreferral_confirmation_details_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details_ref_type[]
    notIn?: $Enums.referral_confirmation_details_ref_type[]
    not?: NestedEnumreferral_confirmation_details_ref_typeWithAggregatesFilter<$PrismaModel> | $Enums.referral_confirmation_details_ref_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel>
    _max?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel>
  }

  export type Enumreferral_confirmation_details1_ref_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details1_ref_type | Enumreferral_confirmation_details1_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details1_ref_type[]
    notIn?: $Enums.referral_confirmation_details1_ref_type[]
    not?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel> | $Enums.referral_confirmation_details1_ref_type
  }

  export type referral_confirmation_details1CountOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
  }

  export type referral_confirmation_details1AvgOrderByAggregateInput = {
    referred_id?: SortOrder
    referral_pat_id?: SortOrder
    attempts?: SortOrder
    login_id?: SortOrder
    lab_test_status?: SortOrder
  }

  export type referral_confirmation_details1MaxOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
  }

  export type referral_confirmation_details1MinOrderByAggregateInput = {
    referred_id?: SortOrder
    medical_num?: SortOrder
    relationship?: SortOrder
    referral_pat_id?: SortOrder
    password?: SortOrder
    patient_unique_id?: SortOrder
    attempts?: SortOrder
    brief_history?: SortOrder
    phy_advice?: SortOrder
    refer_date?: SortOrder
    created_by?: SortOrder
    login_id?: SortOrder
    created_on?: SortOrder
    ref_type?: SortOrder
    lab_test_status?: SortOrder
  }

  export type referral_confirmation_details1SumOrderByAggregateInput = {
    referred_id?: SortOrder
    referral_pat_id?: SortOrder
    attempts?: SortOrder
    login_id?: SortOrder
    lab_test_status?: SortOrder
  }

  export type Enumreferral_confirmation_details1_ref_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details1_ref_type | Enumreferral_confirmation_details1_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details1_ref_type[]
    notIn?: $Enums.referral_confirmation_details1_ref_type[]
    not?: NestedEnumreferral_confirmation_details1_ref_typeWithAggregatesFilter<$PrismaModel> | $Enums.referral_confirmation_details1_ref_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel>
    _max?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel>
  }

  export type referral_patient_detailsCountOrderByAggregateInput = {
    referral_patient_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    password?: SortOrder
    relationship?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    main_pat_id?: SortOrder
    patient_dep_id?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_detailsAvgOrderByAggregateInput = {
    referral_patient_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    r_count?: SortOrder
    patient_dep_id?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_detailsMaxOrderByAggregateInput = {
    referral_patient_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    password?: SortOrder
    relationship?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    main_pat_id?: SortOrder
    patient_dep_id?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_detailsMinOrderByAggregateInput = {
    referral_patient_id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    age?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    mailid?: SortOrder
    phonenum?: SortOrder
    alt_phonenum?: SortOrder
    password?: SortOrder
    relationship?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    status?: SortOrder
    r_count?: SortOrder
    profile_filename?: SortOrder
    profile_fullpath?: SortOrder
    main_pat_id?: SortOrder
    patient_dep_id?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_detailsSumOrderByAggregateInput = {
    referral_patient_id?: SortOrder
    active?: SortOrder
    role_id?: SortOrder
    r_count?: SortOrder
    patient_dep_id?: SortOrder
    count?: SortOrder
    prescribe_receipt?: SortOrder
  }

  export type referral_patient_test_detailsCountOrderByAggregateInput = {
    ID?: SortOrder
    medical_num?: SortOrder
    laboratory_tests?: SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    time?: SortOrder
    date?: SortOrder
    instruction?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    dependent_id?: SortOrder
    main_patient_id?: SortOrder
    billing_id?: SortOrder
    billing_datetime?: SortOrder
    sample_collected_id?: SortOrder
    sample_datetime?: SortOrder
    labapproval_id?: SortOrder
    labapproval_datetime?: SortOrder
    pat_status?: SortOrder
    report_filename?: SortOrder
    report_fullpath?: SortOrder
    approved_lab_doc_id?: SortOrder
    editor?: SortOrder
    created_on?: SortOrder
  }

  export type referral_patient_test_detailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    dependent_id?: SortOrder
    main_patient_id?: SortOrder
    billing_id?: SortOrder
    sample_collected_id?: SortOrder
    labapproval_id?: SortOrder
    pat_status?: SortOrder
    approved_lab_doc_id?: SortOrder
  }

  export type referral_patient_test_detailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    medical_num?: SortOrder
    laboratory_tests?: SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    time?: SortOrder
    date?: SortOrder
    instruction?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    dependent_id?: SortOrder
    main_patient_id?: SortOrder
    billing_id?: SortOrder
    billing_datetime?: SortOrder
    sample_collected_id?: SortOrder
    sample_datetime?: SortOrder
    labapproval_id?: SortOrder
    labapproval_datetime?: SortOrder
    pat_status?: SortOrder
    report_filename?: SortOrder
    report_fullpath?: SortOrder
    approved_lab_doc_id?: SortOrder
    editor?: SortOrder
    created_on?: SortOrder
  }

  export type referral_patient_test_detailsMinOrderByAggregateInput = {
    ID?: SortOrder
    medical_num?: SortOrder
    laboratory_tests?: SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    time?: SortOrder
    date?: SortOrder
    instruction?: SortOrder
    patient_unique_id?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    dependent_id?: SortOrder
    main_patient_id?: SortOrder
    billing_id?: SortOrder
    billing_datetime?: SortOrder
    sample_collected_id?: SortOrder
    sample_datetime?: SortOrder
    labapproval_id?: SortOrder
    labapproval_datetime?: SortOrder
    pat_status?: SortOrder
    report_filename?: SortOrder
    report_fullpath?: SortOrder
    approved_lab_doc_id?: SortOrder
    editor?: SortOrder
    created_on?: SortOrder
  }

  export type referral_patient_test_detailsSumOrderByAggregateInput = {
    ID?: SortOrder
    parse_parent_id?: SortOrder
    has_child?: SortOrder
    physician_id?: SortOrder
    laboratory_id?: SortOrder
    dependent_id?: SortOrder
    main_patient_id?: SortOrder
    billing_id?: SortOrder
    sample_collected_id?: SortOrder
    labapproval_id?: SortOrder
    pat_status?: SortOrder
    approved_lab_doc_id?: SortOrder
  }

  export type relationshipCountOrderByAggregateInput = {
    rel_id?: SortOrder
    rel_name?: SortOrder
    active?: SortOrder
  }

  export type relationshipAvgOrderByAggregateInput = {
    rel_id?: SortOrder
    active?: SortOrder
  }

  export type relationshipMaxOrderByAggregateInput = {
    rel_id?: SortOrder
    rel_name?: SortOrder
    active?: SortOrder
  }

  export type relationshipMinOrderByAggregateInput = {
    rel_id?: SortOrder
    rel_name?: SortOrder
    active?: SortOrder
  }

  export type relationshipSumOrderByAggregateInput = {
    rel_id?: SortOrder
    active?: SortOrder
  }

  export type report_templateCountOrderByAggregateInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
    created_on?: SortOrder
    status?: SortOrder
  }

  export type report_templateAvgOrderByAggregateInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
  }

  export type report_templateMaxOrderByAggregateInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
    created_on?: SortOrder
    status?: SortOrder
  }

  export type report_templateMinOrderByAggregateInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
    created_on?: SortOrder
    status?: SortOrder
  }

  export type report_templateSumOrderByAggregateInput = {
    template_id?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    print_size?: SortOrder
    lab_id?: SortOrder
  }

  export type sample_resultsCountOrderByAggregateInput = {
    result_id?: SortOrder
    sample_value?: SortOrder
    referral_test_ID?: SortOrder
    created_on?: SortOrder
  }

  export type sample_resultsAvgOrderByAggregateInput = {
    result_id?: SortOrder
    referral_test_ID?: SortOrder
  }

  export type sample_resultsMaxOrderByAggregateInput = {
    result_id?: SortOrder
    sample_value?: SortOrder
    referral_test_ID?: SortOrder
    created_on?: SortOrder
  }

  export type sample_resultsMinOrderByAggregateInput = {
    result_id?: SortOrder
    sample_value?: SortOrder
    referral_test_ID?: SortOrder
    created_on?: SortOrder
  }

  export type sample_resultsSumOrderByAggregateInput = {
    result_id?: SortOrder
    referral_test_ID?: SortOrder
  }

  export type ssconsultation_billingCountOrderByAggregateInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    tot_amt?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type ssconsultation_billingAvgOrderByAggregateInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    lab_id?: SortOrder
  }

  export type ssconsultation_billingMaxOrderByAggregateInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    tot_amt?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type ssconsultation_billingMinOrderByAggregateInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    tot_amt?: SortOrder
    lab_id?: SortOrder
    unique_billid?: SortOrder
    created_on?: SortOrder
  }

  export type ssconsultation_billingSumOrderByAggregateInput = {
    ssbilling_id?: SortOrder
    ss_id?: SortOrder
    lab_id?: SortOrder
  }

  export type ssconsultation_logCountOrderByAggregateInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type ssconsultation_logAvgOrderByAggregateInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    payment_method?: SortOrder
  }

  export type ssconsultation_logMaxOrderByAggregateInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type ssconsultation_logMinOrderByAggregateInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    amt?: SortOrder
    payment_method?: SortOrder
    added_date?: SortOrder
  }

  export type ssconsultation_logSumOrderByAggregateInput = {
    ssconsultation_log_id?: SortOrder
    ssbilling_id?: SortOrder
    payment_method?: SortOrder
  }

  export type stateCountOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    country_id?: SortOrder
    active?: SortOrder
  }

  export type stateAvgOrderByAggregateInput = {
    state_id?: SortOrder
    country_id?: SortOrder
  }

  export type stateMaxOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    country_id?: SortOrder
    active?: SortOrder
  }

  export type stateMinOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    country_id?: SortOrder
    active?: SortOrder
  }

  export type stateSumOrderByAggregateInput = {
    state_id?: SortOrder
    country_id?: SortOrder
  }

  export type status_masterCountOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type status_masterAvgOrderByAggregateInput = {
    status_id?: SortOrder
  }

  export type status_masterMaxOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type status_masterMinOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type status_masterSumOrderByAggregateInput = {
    status_id?: SortOrder
  }

  export type super_specialityCountOrderByAggregateInput = {
    superspeciality_id?: SortOrder
    superspeciality_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
  }

  export type super_specialityAvgOrderByAggregateInput = {
    superspeciality_id?: SortOrder
    active?: SortOrder
  }

  export type super_specialityMaxOrderByAggregateInput = {
    superspeciality_id?: SortOrder
    superspeciality_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
  }

  export type super_specialityMinOrderByAggregateInput = {
    superspeciality_id?: SortOrder
    superspeciality_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
  }

  export type super_specialitySumOrderByAggregateInput = {
    superspeciality_id?: SortOrder
    active?: SortOrder
  }

  export type superspeciality_consultationCountOrderByAggregateInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    consultationId?: SortOrder
    consultationDate?: SortOrder
    consultationAmount?: SortOrder
    miscellaneousAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
  }

  export type superspeciality_consultationAvgOrderByAggregateInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    consultationId?: SortOrder
    consultationAmount?: SortOrder
    miscellaneousAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
  }

  export type superspeciality_consultationMaxOrderByAggregateInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    consultationId?: SortOrder
    consultationDate?: SortOrder
    consultationAmount?: SortOrder
    miscellaneousAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
  }

  export type superspeciality_consultationMinOrderByAggregateInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    consultationId?: SortOrder
    consultationDate?: SortOrder
    consultationAmount?: SortOrder
    miscellaneousAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
  }

  export type superspeciality_consultationSumOrderByAggregateInput = {
    ss_id?: SortOrder
    laboratory_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    consultationId?: SortOrder
    consultationAmount?: SortOrder
    miscellaneousAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
  }

  export type superspeciality_detailsCountOrderByAggregateInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type superspeciality_detailsAvgOrderByAggregateInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type superspeciality_detailsMaxOrderByAggregateInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type superspeciality_detailsMinOrderByAggregateInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    comments?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    referdate?: SortOrder
    refertime?: SortOrder
    referclinic_name?: SortOrder
    created_on?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type superspeciality_detailsSumOrderByAggregateInput = {
    speciality_id?: SortOrder
    referral_patient_id?: SortOrder
    patient_dep_id?: SortOrder
    superspeciality_id?: SortOrder
    by_assign?: SortOrder
    to_assign?: SortOrder
    active?: SortOrder
    laboratory_id?: SortOrder
  }

  export type test_report_notesCountOrderByAggregateInput = {
    test_report_notes_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    referral_patient_test_details_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    added_date?: SortOrder
  }

  export type test_report_notesAvgOrderByAggregateInput = {
    test_report_notes_id?: SortOrder
    referral_patient_test_details_id?: SortOrder
  }

  export type test_report_notesMaxOrderByAggregateInput = {
    test_report_notes_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    referral_patient_test_details_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    added_date?: SortOrder
  }

  export type test_report_notesMinOrderByAggregateInput = {
    test_report_notes_id?: SortOrder
    laboratory_tests?: SortOrder
    medical_num?: SortOrder
    referral_patient_test_details_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    added_date?: SortOrder
  }

  export type test_report_notesSumOrderByAggregateInput = {
    test_report_notes_id?: SortOrder
    referral_patient_test_details_id?: SortOrder
  }

  export type update_labsCountOrderByAggregateInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type update_labsAvgOrderByAggregateInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type update_labsMaxOrderByAggregateInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type update_labsMinOrderByAggregateInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type update_labsSumOrderByAggregateInput = {
    update_labid?: SortOrder
    laboratory_id?: SortOrder
    phonenum_doesnt_exist?: SortOrder
    print_billing?: SortOrder
    collection_report?: SortOrder
    test_report?: SortOrder
    active?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    created_on?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    role_id?: SortOrder
    active?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    created_on?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    created_on?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    role_id?: SortOrder
    active?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Enumfiles_statusFieldUpdateOperationsInput = {
    set?: $Enums.files_status
  }

  export type investigation_test_detailsCreateNestedManyWithoutInvestigation_detailsInput = {
    create?: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput> | investigation_test_detailsCreateWithoutInvestigation_detailsInput[] | investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput[]
    connectOrCreate?: investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput | investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput[]
    createMany?: investigation_test_detailsCreateManyInvestigation_detailsInputEnvelope
    connect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
  }

  export type investigation_test_detailsUncheckedCreateNestedManyWithoutInvestigation_detailsInput = {
    create?: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput> | investigation_test_detailsCreateWithoutInvestigation_detailsInput[] | investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput[]
    connectOrCreate?: investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput | investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput[]
    createMany?: investigation_test_detailsCreateManyInvestigation_detailsInputEnvelope
    connect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
  }

  export type investigation_test_detailsUpdateManyWithoutInvestigation_detailsNestedInput = {
    create?: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput> | investigation_test_detailsCreateWithoutInvestigation_detailsInput[] | investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput[]
    connectOrCreate?: investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput | investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput[]
    upsert?: investigation_test_detailsUpsertWithWhereUniqueWithoutInvestigation_detailsInput | investigation_test_detailsUpsertWithWhereUniqueWithoutInvestigation_detailsInput[]
    createMany?: investigation_test_detailsCreateManyInvestigation_detailsInputEnvelope
    set?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    disconnect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    delete?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    connect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    update?: investigation_test_detailsUpdateWithWhereUniqueWithoutInvestigation_detailsInput | investigation_test_detailsUpdateWithWhereUniqueWithoutInvestigation_detailsInput[]
    updateMany?: investigation_test_detailsUpdateManyWithWhereWithoutInvestigation_detailsInput | investigation_test_detailsUpdateManyWithWhereWithoutInvestigation_detailsInput[]
    deleteMany?: investigation_test_detailsScalarWhereInput | investigation_test_detailsScalarWhereInput[]
  }

  export type investigation_test_detailsUncheckedUpdateManyWithoutInvestigation_detailsNestedInput = {
    create?: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput> | investigation_test_detailsCreateWithoutInvestigation_detailsInput[] | investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput[]
    connectOrCreate?: investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput | investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput[]
    upsert?: investigation_test_detailsUpsertWithWhereUniqueWithoutInvestigation_detailsInput | investigation_test_detailsUpsertWithWhereUniqueWithoutInvestigation_detailsInput[]
    createMany?: investigation_test_detailsCreateManyInvestigation_detailsInputEnvelope
    set?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    disconnect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    delete?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    connect?: investigation_test_detailsWhereUniqueInput | investigation_test_detailsWhereUniqueInput[]
    update?: investigation_test_detailsUpdateWithWhereUniqueWithoutInvestigation_detailsInput | investigation_test_detailsUpdateWithWhereUniqueWithoutInvestigation_detailsInput[]
    updateMany?: investigation_test_detailsUpdateManyWithWhereWithoutInvestigation_detailsInput | investigation_test_detailsUpdateManyWithWhereWithoutInvestigation_detailsInput[]
    deleteMany?: investigation_test_detailsScalarWhereInput | investigation_test_detailsScalarWhereInput[]
  }

  export type investigation_detailsCreateNestedOneWithoutInvestigation_test_detailsInput = {
    create?: XOR<investigation_detailsCreateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedCreateWithoutInvestigation_test_detailsInput>
    connectOrCreate?: investigation_detailsCreateOrConnectWithoutInvestigation_test_detailsInput
    connect?: investigation_detailsWhereUniqueInput
  }

  export type investigation_detailsUpdateOneRequiredWithoutInvestigation_test_detailsNestedInput = {
    create?: XOR<investigation_detailsCreateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedCreateWithoutInvestigation_test_detailsInput>
    connectOrCreate?: investigation_detailsCreateOrConnectWithoutInvestigation_test_detailsInput
    upsert?: investigation_detailsUpsertWithoutInvestigation_test_detailsInput
    connect?: investigation_detailsWhereUniqueInput
    update?: XOR<XOR<investigation_detailsUpdateToOneWithWhereWithoutInvestigation_test_detailsInput, investigation_detailsUpdateWithoutInvestigation_test_detailsInput>, investigation_detailsUncheckedUpdateWithoutInvestigation_test_detailsInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type Enumlab_timings_work_typeFieldUpdateOperationsInput = {
    set?: $Enums.lab_timings_work_type
  }

  export type laboratory_test_detailsCreateNestedManyWithoutLaboratory_detailsInput = {
    create?: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput> | laboratory_test_detailsCreateWithoutLaboratory_detailsInput[] | laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput[]
    connectOrCreate?: laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput | laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput[]
    createMany?: laboratory_test_detailsCreateManyLaboratory_detailsInputEnvelope
    connect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
  }

  export type laboratory_test_detailsUncheckedCreateNestedManyWithoutLaboratory_detailsInput = {
    create?: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput> | laboratory_test_detailsCreateWithoutLaboratory_detailsInput[] | laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput[]
    connectOrCreate?: laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput | laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput[]
    createMany?: laboratory_test_detailsCreateManyLaboratory_detailsInputEnvelope
    connect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
  }

  export type laboratory_test_detailsUpdateManyWithoutLaboratory_detailsNestedInput = {
    create?: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput> | laboratory_test_detailsCreateWithoutLaboratory_detailsInput[] | laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput[]
    connectOrCreate?: laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput | laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput[]
    upsert?: laboratory_test_detailsUpsertWithWhereUniqueWithoutLaboratory_detailsInput | laboratory_test_detailsUpsertWithWhereUniqueWithoutLaboratory_detailsInput[]
    createMany?: laboratory_test_detailsCreateManyLaboratory_detailsInputEnvelope
    set?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    disconnect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    delete?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    connect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    update?: laboratory_test_detailsUpdateWithWhereUniqueWithoutLaboratory_detailsInput | laboratory_test_detailsUpdateWithWhereUniqueWithoutLaboratory_detailsInput[]
    updateMany?: laboratory_test_detailsUpdateManyWithWhereWithoutLaboratory_detailsInput | laboratory_test_detailsUpdateManyWithWhereWithoutLaboratory_detailsInput[]
    deleteMany?: laboratory_test_detailsScalarWhereInput | laboratory_test_detailsScalarWhereInput[]
  }

  export type laboratory_test_detailsUncheckedUpdateManyWithoutLaboratory_detailsNestedInput = {
    create?: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput> | laboratory_test_detailsCreateWithoutLaboratory_detailsInput[] | laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput[]
    connectOrCreate?: laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput | laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput[]
    upsert?: laboratory_test_detailsUpsertWithWhereUniqueWithoutLaboratory_detailsInput | laboratory_test_detailsUpsertWithWhereUniqueWithoutLaboratory_detailsInput[]
    createMany?: laboratory_test_detailsCreateManyLaboratory_detailsInputEnvelope
    set?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    disconnect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    delete?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    connect?: laboratory_test_detailsWhereUniqueInput | laboratory_test_detailsWhereUniqueInput[]
    update?: laboratory_test_detailsUpdateWithWhereUniqueWithoutLaboratory_detailsInput | laboratory_test_detailsUpdateWithWhereUniqueWithoutLaboratory_detailsInput[]
    updateMany?: laboratory_test_detailsUpdateManyWithWhereWithoutLaboratory_detailsInput | laboratory_test_detailsUpdateManyWithWhereWithoutLaboratory_detailsInput[]
    deleteMany?: laboratory_test_detailsScalarWhereInput | laboratory_test_detailsScalarWhereInput[]
  }

  export type laboratory_detailsCreateNestedOneWithoutLaboratory_test_detailsInput = {
    create?: XOR<laboratory_detailsCreateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedCreateWithoutLaboratory_test_detailsInput>
    connectOrCreate?: laboratory_detailsCreateOrConnectWithoutLaboratory_test_detailsInput
    connect?: laboratory_detailsWhereUniqueInput
  }

  export type Enumlaboratory_test_details_statusFieldUpdateOperationsInput = {
    set?: $Enums.laboratory_test_details_status
  }

  export type laboratory_detailsUpdateOneRequiredWithoutLaboratory_test_detailsNestedInput = {
    create?: XOR<laboratory_detailsCreateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedCreateWithoutLaboratory_test_detailsInput>
    connectOrCreate?: laboratory_detailsCreateOrConnectWithoutLaboratory_test_detailsInput
    upsert?: laboratory_detailsUpsertWithoutLaboratory_test_detailsInput
    connect?: laboratory_detailsWhereUniqueInput
    update?: XOR<XOR<laboratory_detailsUpdateToOneWithWhereWithoutLaboratory_test_detailsInput, laboratory_detailsUpdateWithoutLaboratory_test_detailsInput>, laboratory_detailsUncheckedUpdateWithoutLaboratory_test_detailsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type physician_appointmentCreateNestedOneWithoutPhy_adminInput = {
    create?: XOR<physician_appointmentCreateWithoutPhy_adminInput, physician_appointmentUncheckedCreateWithoutPhy_adminInput>
    connectOrCreate?: physician_appointmentCreateOrConnectWithoutPhy_adminInput
    connect?: physician_appointmentWhereUniqueInput
  }

  export type physician_appointmentUpdateOneRequiredWithoutPhy_adminNestedInput = {
    create?: XOR<physician_appointmentCreateWithoutPhy_adminInput, physician_appointmentUncheckedCreateWithoutPhy_adminInput>
    connectOrCreate?: physician_appointmentCreateOrConnectWithoutPhy_adminInput
    upsert?: physician_appointmentUpsertWithoutPhy_adminInput
    connect?: physician_appointmentWhereUniqueInput
    update?: XOR<XOR<physician_appointmentUpdateToOneWithWhereWithoutPhy_adminInput, physician_appointmentUpdateWithoutPhy_adminInput>, physician_appointmentUncheckedUpdateWithoutPhy_adminInput>
  }

  export type phy_adminCreateNestedManyWithoutPhysician_appointmentInput = {
    create?: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput> | phy_adminCreateWithoutPhysician_appointmentInput[] | phy_adminUncheckedCreateWithoutPhysician_appointmentInput[]
    connectOrCreate?: phy_adminCreateOrConnectWithoutPhysician_appointmentInput | phy_adminCreateOrConnectWithoutPhysician_appointmentInput[]
    createMany?: phy_adminCreateManyPhysician_appointmentInputEnvelope
    connect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
  }

  export type phy_adminUncheckedCreateNestedManyWithoutPhysician_appointmentInput = {
    create?: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput> | phy_adminCreateWithoutPhysician_appointmentInput[] | phy_adminUncheckedCreateWithoutPhysician_appointmentInput[]
    connectOrCreate?: phy_adminCreateOrConnectWithoutPhysician_appointmentInput | phy_adminCreateOrConnectWithoutPhysician_appointmentInput[]
    createMany?: phy_adminCreateManyPhysician_appointmentInputEnvelope
    connect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
  }

  export type phy_adminUpdateManyWithoutPhysician_appointmentNestedInput = {
    create?: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput> | phy_adminCreateWithoutPhysician_appointmentInput[] | phy_adminUncheckedCreateWithoutPhysician_appointmentInput[]
    connectOrCreate?: phy_adminCreateOrConnectWithoutPhysician_appointmentInput | phy_adminCreateOrConnectWithoutPhysician_appointmentInput[]
    upsert?: phy_adminUpsertWithWhereUniqueWithoutPhysician_appointmentInput | phy_adminUpsertWithWhereUniqueWithoutPhysician_appointmentInput[]
    createMany?: phy_adminCreateManyPhysician_appointmentInputEnvelope
    set?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    disconnect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    delete?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    connect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    update?: phy_adminUpdateWithWhereUniqueWithoutPhysician_appointmentInput | phy_adminUpdateWithWhereUniqueWithoutPhysician_appointmentInput[]
    updateMany?: phy_adminUpdateManyWithWhereWithoutPhysician_appointmentInput | phy_adminUpdateManyWithWhereWithoutPhysician_appointmentInput[]
    deleteMany?: phy_adminScalarWhereInput | phy_adminScalarWhereInput[]
  }

  export type phy_adminUncheckedUpdateManyWithoutPhysician_appointmentNestedInput = {
    create?: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput> | phy_adminCreateWithoutPhysician_appointmentInput[] | phy_adminUncheckedCreateWithoutPhysician_appointmentInput[]
    connectOrCreate?: phy_adminCreateOrConnectWithoutPhysician_appointmentInput | phy_adminCreateOrConnectWithoutPhysician_appointmentInput[]
    upsert?: phy_adminUpsertWithWhereUniqueWithoutPhysician_appointmentInput | phy_adminUpsertWithWhereUniqueWithoutPhysician_appointmentInput[]
    createMany?: phy_adminCreateManyPhysician_appointmentInputEnvelope
    set?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    disconnect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    delete?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    connect?: phy_adminWhereUniqueInput | phy_adminWhereUniqueInput[]
    update?: phy_adminUpdateWithWhereUniqueWithoutPhysician_appointmentInput | phy_adminUpdateWithWhereUniqueWithoutPhysician_appointmentInput[]
    updateMany?: phy_adminUpdateManyWithWhereWithoutPhysician_appointmentInput | phy_adminUpdateManyWithWhereWithoutPhysician_appointmentInput[]
    deleteMany?: phy_adminScalarWhereInput | phy_adminScalarWhereInput[]
  }

  export type Enumphysician_clinic_timings_work_typeFieldUpdateOperationsInput = {
    set?: $Enums.physician_clinic_timings_work_type
  }

  export type Enumphysician_timings_work_typeFieldUpdateOperationsInput = {
    set?: $Enums.physician_timings_work_type
  }

  export type Enumreferral_confirmation_details_ref_typeFieldUpdateOperationsInput = {
    set?: $Enums.referral_confirmation_details_ref_type
  }

  export type Enumreferral_confirmation_details1_ref_typeFieldUpdateOperationsInput = {
    set?: $Enums.referral_confirmation_details1_ref_type
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumfiles_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.files_status | Enumfiles_statusFieldRefInput<$PrismaModel>
    in?: $Enums.files_status[]
    notIn?: $Enums.files_status[]
    not?: NestedEnumfiles_statusFilter<$PrismaModel> | $Enums.files_status
  }

  export type NestedEnumfiles_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.files_status | Enumfiles_statusFieldRefInput<$PrismaModel>
    in?: $Enums.files_status[]
    notIn?: $Enums.files_status[]
    not?: NestedEnumfiles_statusWithAggregatesFilter<$PrismaModel> | $Enums.files_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfiles_statusFilter<$PrismaModel>
    _max?: NestedEnumfiles_statusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumlab_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.lab_timings_work_type | Enumlab_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.lab_timings_work_type[]
    notIn?: $Enums.lab_timings_work_type[]
    not?: NestedEnumlab_timings_work_typeFilter<$PrismaModel> | $Enums.lab_timings_work_type
  }

  export type NestedEnumlab_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.lab_timings_work_type | Enumlab_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.lab_timings_work_type[]
    notIn?: $Enums.lab_timings_work_type[]
    not?: NestedEnumlab_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.lab_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlab_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumlab_timings_work_typeFilter<$PrismaModel>
  }

  export type NestedEnumlaboratory_test_details_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.laboratory_test_details_status | Enumlaboratory_test_details_statusFieldRefInput<$PrismaModel>
    in?: $Enums.laboratory_test_details_status[]
    notIn?: $Enums.laboratory_test_details_status[]
    not?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel> | $Enums.laboratory_test_details_status
  }

  export type NestedEnumlaboratory_test_details_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.laboratory_test_details_status | Enumlaboratory_test_details_statusFieldRefInput<$PrismaModel>
    in?: $Enums.laboratory_test_details_status[]
    notIn?: $Enums.laboratory_test_details_status[]
    not?: NestedEnumlaboratory_test_details_statusWithAggregatesFilter<$PrismaModel> | $Enums.laboratory_test_details_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel>
    _max?: NestedEnumlaboratory_test_details_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_clinic_timings_work_type | Enumphysician_clinic_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_clinic_timings_work_type[]
    notIn?: $Enums.physician_clinic_timings_work_type[]
    not?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel> | $Enums.physician_clinic_timings_work_type
  }

  export type NestedEnumphysician_clinic_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_clinic_timings_work_type | Enumphysician_clinic_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_clinic_timings_work_type[]
    notIn?: $Enums.physician_clinic_timings_work_type[]
    not?: NestedEnumphysician_clinic_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.physician_clinic_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumphysician_clinic_timings_work_typeFilter<$PrismaModel>
  }

  export type NestedEnumphysician_timings_work_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_timings_work_type | Enumphysician_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_timings_work_type[]
    notIn?: $Enums.physician_timings_work_type[]
    not?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel> | $Enums.physician_timings_work_type
  }

  export type NestedEnumphysician_timings_work_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.physician_timings_work_type | Enumphysician_timings_work_typeFieldRefInput<$PrismaModel>
    in?: $Enums.physician_timings_work_type[]
    notIn?: $Enums.physician_timings_work_type[]
    not?: NestedEnumphysician_timings_work_typeWithAggregatesFilter<$PrismaModel> | $Enums.physician_timings_work_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel>
    _max?: NestedEnumphysician_timings_work_typeFilter<$PrismaModel>
  }

  export type NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details_ref_type | Enumreferral_confirmation_details_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details_ref_type[]
    notIn?: $Enums.referral_confirmation_details_ref_type[]
    not?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel> | $Enums.referral_confirmation_details_ref_type
  }

  export type NestedEnumreferral_confirmation_details_ref_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details_ref_type | Enumreferral_confirmation_details_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details_ref_type[]
    notIn?: $Enums.referral_confirmation_details_ref_type[]
    not?: NestedEnumreferral_confirmation_details_ref_typeWithAggregatesFilter<$PrismaModel> | $Enums.referral_confirmation_details_ref_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel>
    _max?: NestedEnumreferral_confirmation_details_ref_typeFilter<$PrismaModel>
  }

  export type NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details1_ref_type | Enumreferral_confirmation_details1_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details1_ref_type[]
    notIn?: $Enums.referral_confirmation_details1_ref_type[]
    not?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel> | $Enums.referral_confirmation_details1_ref_type
  }

  export type NestedEnumreferral_confirmation_details1_ref_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.referral_confirmation_details1_ref_type | Enumreferral_confirmation_details1_ref_typeFieldRefInput<$PrismaModel>
    in?: $Enums.referral_confirmation_details1_ref_type[]
    notIn?: $Enums.referral_confirmation_details1_ref_type[]
    not?: NestedEnumreferral_confirmation_details1_ref_typeWithAggregatesFilter<$PrismaModel> | $Enums.referral_confirmation_details1_ref_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel>
    _max?: NestedEnumreferral_confirmation_details1_ref_typeFilter<$PrismaModel>
  }

  export type investigation_test_detailsCreateWithoutInvestigation_detailsInput = {
    parse_id?: number
    test_name: string
    parent_parse_id: number
    active?: number
  }

  export type investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput = {
    parse_id?: number
    test_name: string
    parent_parse_id: number
    active?: number
  }

  export type investigation_test_detailsCreateOrConnectWithoutInvestigation_detailsInput = {
    where: investigation_test_detailsWhereUniqueInput
    create: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput>
  }

  export type investigation_test_detailsCreateManyInvestigation_detailsInputEnvelope = {
    data: investigation_test_detailsCreateManyInvestigation_detailsInput | investigation_test_detailsCreateManyInvestigation_detailsInput[]
    skipDuplicates?: boolean
  }

  export type investigation_test_detailsUpsertWithWhereUniqueWithoutInvestigation_detailsInput = {
    where: investigation_test_detailsWhereUniqueInput
    update: XOR<investigation_test_detailsUpdateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedUpdateWithoutInvestigation_detailsInput>
    create: XOR<investigation_test_detailsCreateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedCreateWithoutInvestigation_detailsInput>
  }

  export type investigation_test_detailsUpdateWithWhereUniqueWithoutInvestigation_detailsInput = {
    where: investigation_test_detailsWhereUniqueInput
    data: XOR<investigation_test_detailsUpdateWithoutInvestigation_detailsInput, investigation_test_detailsUncheckedUpdateWithoutInvestigation_detailsInput>
  }

  export type investigation_test_detailsUpdateManyWithWhereWithoutInvestigation_detailsInput = {
    where: investigation_test_detailsScalarWhereInput
    data: XOR<investigation_test_detailsUpdateManyMutationInput, investigation_test_detailsUncheckedUpdateManyWithoutInvestigation_detailsInput>
  }

  export type investigation_test_detailsScalarWhereInput = {
    AND?: investigation_test_detailsScalarWhereInput | investigation_test_detailsScalarWhereInput[]
    OR?: investigation_test_detailsScalarWhereInput[]
    NOT?: investigation_test_detailsScalarWhereInput | investigation_test_detailsScalarWhereInput[]
    parse_id?: IntFilter<"investigation_test_details"> | number
    test_name?: StringFilter<"investigation_test_details"> | string
    investigation_id?: IntFilter<"investigation_test_details"> | number
    parent_parse_id?: IntFilter<"investigation_test_details"> | number
    active?: IntFilter<"investigation_test_details"> | number
  }

  export type investigation_detailsCreateWithoutInvestigation_test_detailsInput = {
    investigation_name?: string | null
    active?: number | null
  }

  export type investigation_detailsUncheckedCreateWithoutInvestigation_test_detailsInput = {
    investigation_id?: number
    investigation_name?: string | null
    active?: number | null
  }

  export type investigation_detailsCreateOrConnectWithoutInvestigation_test_detailsInput = {
    where: investigation_detailsWhereUniqueInput
    create: XOR<investigation_detailsCreateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedCreateWithoutInvestigation_test_detailsInput>
  }

  export type investigation_detailsUpsertWithoutInvestigation_test_detailsInput = {
    update: XOR<investigation_detailsUpdateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedUpdateWithoutInvestigation_test_detailsInput>
    create: XOR<investigation_detailsCreateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedCreateWithoutInvestigation_test_detailsInput>
    where?: investigation_detailsWhereInput
  }

  export type investigation_detailsUpdateToOneWithWhereWithoutInvestigation_test_detailsInput = {
    where?: investigation_detailsWhereInput
    data: XOR<investigation_detailsUpdateWithoutInvestigation_test_detailsInput, investigation_detailsUncheckedUpdateWithoutInvestigation_test_detailsInput>
  }

  export type investigation_detailsUpdateWithoutInvestigation_test_detailsInput = {
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type investigation_detailsUncheckedUpdateWithoutInvestigation_test_detailsInput = {
    investigation_id?: IntFieldUpdateOperationsInput | number
    investigation_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type laboratory_test_detailsCreateWithoutLaboratory_detailsInput = {
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
  }

  export type laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput = {
    laboratory_testid?: number
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
  }

  export type laboratory_test_detailsCreateOrConnectWithoutLaboratory_detailsInput = {
    where: laboratory_test_detailsWhereUniqueInput
    create: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput>
  }

  export type laboratory_test_detailsCreateManyLaboratory_detailsInputEnvelope = {
    data: laboratory_test_detailsCreateManyLaboratory_detailsInput | laboratory_test_detailsCreateManyLaboratory_detailsInput[]
    skipDuplicates?: boolean
  }

  export type laboratory_test_detailsUpsertWithWhereUniqueWithoutLaboratory_detailsInput = {
    where: laboratory_test_detailsWhereUniqueInput
    update: XOR<laboratory_test_detailsUpdateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedUpdateWithoutLaboratory_detailsInput>
    create: XOR<laboratory_test_detailsCreateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedCreateWithoutLaboratory_detailsInput>
  }

  export type laboratory_test_detailsUpdateWithWhereUniqueWithoutLaboratory_detailsInput = {
    where: laboratory_test_detailsWhereUniqueInput
    data: XOR<laboratory_test_detailsUpdateWithoutLaboratory_detailsInput, laboratory_test_detailsUncheckedUpdateWithoutLaboratory_detailsInput>
  }

  export type laboratory_test_detailsUpdateManyWithWhereWithoutLaboratory_detailsInput = {
    where: laboratory_test_detailsScalarWhereInput
    data: XOR<laboratory_test_detailsUpdateManyMutationInput, laboratory_test_detailsUncheckedUpdateManyWithoutLaboratory_detailsInput>
  }

  export type laboratory_test_detailsScalarWhereInput = {
    AND?: laboratory_test_detailsScalarWhereInput | laboratory_test_detailsScalarWhereInput[]
    OR?: laboratory_test_detailsScalarWhereInput[]
    NOT?: laboratory_test_detailsScalarWhereInput | laboratory_test_detailsScalarWhereInput[]
    laboratory_testid?: IntFilter<"laboratory_test_details"> | number
    laboratory_tests?: StringFilter<"laboratory_test_details"> | string
    code?: StringFilter<"laboratory_test_details"> | string
    display_order?: IntNullableFilter<"laboratory_test_details"> | number | null
    mnemonics?: StringNullableFilter<"laboratory_test_details"> | string | null
    test_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    sub_department?: StringNullableFilter<"laboratory_test_details"> | string | null
    sample_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    container_type?: StringNullableFilter<"laboratory_test_details"> | string | null
    confidential?: StringNullableFilter<"laboratory_test_details"> | string | null
    methodology?: StringNullableFilter<"laboratory_test_details"> | string | null
    transport_temperature?: StringNullableFilter<"laboratory_test_details"> | string | null
    tat?: StringNullableFilter<"laboratory_test_details"> | string | null
    outsourcing_status?: StringNullableFilter<"laboratory_test_details"> | string | null
    instrument?: StringNullableFilter<"laboratory_test_details"> | string | null
    laboratory_id?: IntFilter<"laboratory_test_details"> | number
    test_price?: BigIntFilter<"laboratory_test_details"> | bigint | number
    custom_test_name?: StringFilter<"laboratory_test_details"> | string
    instruction?: StringFilter<"laboratory_test_details"> | string
    test_method?: StringFilter<"laboratory_test_details"> | string
    status?: Enumlaboratory_test_details_statusFilter<"laboratory_test_details"> | $Enums.laboratory_test_details_status
    status_changed_by?: StringFilter<"laboratory_test_details"> | string
    status_changed_on?: StringFilter<"laboratory_test_details"> | string
    unit?: StringFilter<"laboratory_test_details"> | string
    reference_range?: StringFilter<"laboratory_test_details"> | string
    age_gender_specific?: StringNullableFilter<"laboratory_test_details"> | string | null
    critical_alert?: StringNullableFilter<"laboratory_test_details"> | string | null
    interpretation?: StringNullableFilter<"laboratory_test_details"> | string | null
    sort_order?: IntFilter<"laboratory_test_details"> | number
    title_required?: IntFilter<"laboratory_test_details"> | number
  }

  export type laboratory_detailsCreateWithoutLaboratory_test_detailsInput = {
    laboratory_id?: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date | string
    updated_on: Date | string
    active?: number
    role_id?: number
    profile_filename: string
    profile_fullpath: string
  }

  export type laboratory_detailsUncheckedCreateWithoutLaboratory_test_detailsInput = {
    laboratory_id?: number
    laboratory_name: string
    laboratory_address: string
    locality: string
    laboratory_phone: string
    laboratory_email: string
    laboratory_password: string
    lab_state: string
    lab_city: string
    lab_pincode: string
    created_on: Date | string
    updated_on: Date | string
    active?: number
    role_id?: number
    profile_filename: string
    profile_fullpath: string
  }

  export type laboratory_detailsCreateOrConnectWithoutLaboratory_test_detailsInput = {
    where: laboratory_detailsWhereUniqueInput
    create: XOR<laboratory_detailsCreateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedCreateWithoutLaboratory_test_detailsInput>
  }

  export type laboratory_detailsUpsertWithoutLaboratory_test_detailsInput = {
    update: XOR<laboratory_detailsUpdateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedUpdateWithoutLaboratory_test_detailsInput>
    create: XOR<laboratory_detailsCreateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedCreateWithoutLaboratory_test_detailsInput>
    where?: laboratory_detailsWhereInput
  }

  export type laboratory_detailsUpdateToOneWithWhereWithoutLaboratory_test_detailsInput = {
    where?: laboratory_detailsWhereInput
    data: XOR<laboratory_detailsUpdateWithoutLaboratory_test_detailsInput, laboratory_detailsUncheckedUpdateWithoutLaboratory_test_detailsInput>
  }

  export type laboratory_detailsUpdateWithoutLaboratory_test_detailsInput = {
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
  }

  export type laboratory_detailsUncheckedUpdateWithoutLaboratory_test_detailsInput = {
    laboratory_id?: IntFieldUpdateOperationsInput | number
    laboratory_name?: StringFieldUpdateOperationsInput | string
    laboratory_address?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    laboratory_phone?: StringFieldUpdateOperationsInput | string
    laboratory_email?: StringFieldUpdateOperationsInput | string
    laboratory_password?: StringFieldUpdateOperationsInput | string
    lab_state?: StringFieldUpdateOperationsInput | string
    lab_city?: StringFieldUpdateOperationsInput | string
    lab_pincode?: StringFieldUpdateOperationsInput | string
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: StringFieldUpdateOperationsInput | string
    profile_fullpath?: StringFieldUpdateOperationsInput | string
  }

  export type physician_appointmentCreateWithoutPhy_adminInput = {
    physician_id?: number
    firstname?: string | null
    lastname?: string | null
    phone_num?: string
    alternate_phone_number: string
    mail_id?: string
    pincode?: number | null
    clinic_name?: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization?: string | null
    address?: string | null
    consultation_fee_validity: string
    city?: string | null
    state?: string | null
    active?: boolean
    created_by?: string | null
    created_on?: Date | string | null
    updated_on?: Date | string | null
    password?: string | null
    role_id?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    qualification_id?: number | null
    registration_number?: string | null
    time_span?: string | null
    status?: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
  }

  export type physician_appointmentUncheckedCreateWithoutPhy_adminInput = {
    physician_id?: number
    firstname?: string | null
    lastname?: string | null
    phone_num?: string
    alternate_phone_number: string
    mail_id?: string
    pincode?: number | null
    clinic_name?: string | null
    clinic_phonenum: string
    clinic_alternate_phonenum: string
    clinic_manager: string
    specialization?: string | null
    address?: string | null
    consultation_fee_validity: string
    city?: string | null
    state?: string | null
    active?: boolean
    created_by?: string | null
    created_on?: Date | string | null
    updated_on?: Date | string | null
    password?: string | null
    role_id?: number
    profile_filename?: string | null
    profile_fullpath?: string | null
    qualification_id?: number | null
    registration_number?: string | null
    time_span?: string | null
    status?: number | null
    locality: string
    created_by_id: number
    clinic_module_activated: number
    Signature_image: string
  }

  export type physician_appointmentCreateOrConnectWithoutPhy_adminInput = {
    where: physician_appointmentWhereUniqueInput
    create: XOR<physician_appointmentCreateWithoutPhy_adminInput, physician_appointmentUncheckedCreateWithoutPhy_adminInput>
  }

  export type physician_appointmentUpsertWithoutPhy_adminInput = {
    update: XOR<physician_appointmentUpdateWithoutPhy_adminInput, physician_appointmentUncheckedUpdateWithoutPhy_adminInput>
    create: XOR<physician_appointmentCreateWithoutPhy_adminInput, physician_appointmentUncheckedCreateWithoutPhy_adminInput>
    where?: physician_appointmentWhereInput
  }

  export type physician_appointmentUpdateToOneWithWhereWithoutPhy_adminInput = {
    where?: physician_appointmentWhereInput
    data: XOR<physician_appointmentUpdateWithoutPhy_adminInput, physician_appointmentUncheckedUpdateWithoutPhy_adminInput>
  }

  export type physician_appointmentUpdateWithoutPhy_adminInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
  }

  export type physician_appointmentUncheckedUpdateWithoutPhy_adminInput = {
    physician_id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phone_num?: StringFieldUpdateOperationsInput | string
    alternate_phone_number?: StringFieldUpdateOperationsInput | string
    mail_id?: StringFieldUpdateOperationsInput | string
    pincode?: NullableIntFieldUpdateOperationsInput | number | null
    clinic_name?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_alternate_phonenum?: StringFieldUpdateOperationsInput | string
    clinic_manager?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consultation_fee_validity?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: IntFieldUpdateOperationsInput | number
    profile_filename?: NullableStringFieldUpdateOperationsInput | string | null
    profile_fullpath?: NullableStringFieldUpdateOperationsInput | string | null
    qualification_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_number?: NullableStringFieldUpdateOperationsInput | string | null
    time_span?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    locality?: StringFieldUpdateOperationsInput | string
    created_by_id?: IntFieldUpdateOperationsInput | number
    clinic_module_activated?: IntFieldUpdateOperationsInput | number
    Signature_image?: StringFieldUpdateOperationsInput | string
  }

  export type phy_adminCreateWithoutPhysician_appointmentInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    active?: number
    is_visible?: number
    role_id?: number
  }

  export type phy_adminUncheckedCreateWithoutPhysician_appointmentInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    active?: number
    is_visible?: number
    role_id?: number
  }

  export type phy_adminCreateOrConnectWithoutPhysician_appointmentInput = {
    where: phy_adminWhereUniqueInput
    create: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput>
  }

  export type phy_adminCreateManyPhysician_appointmentInputEnvelope = {
    data: phy_adminCreateManyPhysician_appointmentInput | phy_adminCreateManyPhysician_appointmentInput[]
    skipDuplicates?: boolean
  }

  export type phy_adminUpsertWithWhereUniqueWithoutPhysician_appointmentInput = {
    where: phy_adminWhereUniqueInput
    update: XOR<phy_adminUpdateWithoutPhysician_appointmentInput, phy_adminUncheckedUpdateWithoutPhysician_appointmentInput>
    create: XOR<phy_adminCreateWithoutPhysician_appointmentInput, phy_adminUncheckedCreateWithoutPhysician_appointmentInput>
  }

  export type phy_adminUpdateWithWhereUniqueWithoutPhysician_appointmentInput = {
    where: phy_adminWhereUniqueInput
    data: XOR<phy_adminUpdateWithoutPhysician_appointmentInput, phy_adminUncheckedUpdateWithoutPhysician_appointmentInput>
  }

  export type phy_adminUpdateManyWithWhereWithoutPhysician_appointmentInput = {
    where: phy_adminScalarWhereInput
    data: XOR<phy_adminUpdateManyMutationInput, phy_adminUncheckedUpdateManyWithoutPhysician_appointmentInput>
  }

  export type phy_adminScalarWhereInput = {
    AND?: phy_adminScalarWhereInput | phy_adminScalarWhereInput[]
    OR?: phy_adminScalarWhereInput[]
    NOT?: phy_adminScalarWhereInput | phy_adminScalarWhereInput[]
    phy_admin_id?: IntFilter<"phy_admin"> | number
    phy_admin_name?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_phone?: StringNullableFilter<"phy_admin"> | string | null
    phy_admin_mail_id?: StringFilter<"phy_admin"> | string
    phy_admin_password?: StringNullableFilter<"phy_admin"> | string | null
    created_on?: DateTimeFilter<"phy_admin"> | Date | string
    updated_on?: DateTimeNullableFilter<"phy_admin"> | Date | string | null
    created_by?: StringNullableFilter<"phy_admin"> | string | null
    physician_id?: IntFilter<"phy_admin"> | number
    active?: IntFilter<"phy_admin"> | number
    is_visible?: IntFilter<"phy_admin"> | number
    role_id?: IntFilter<"phy_admin"> | number
  }

  export type investigation_test_detailsCreateManyInvestigation_detailsInput = {
    parse_id?: number
    test_name: string
    parent_parse_id: number
    active?: number
  }

  export type investigation_test_detailsUpdateWithoutInvestigation_detailsInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type investigation_test_detailsUncheckedUpdateWithoutInvestigation_detailsInput = {
    parse_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type investigation_test_detailsUncheckedUpdateManyWithoutInvestigation_detailsInput = {
    parse_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    parent_parse_id?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsCreateManyLaboratory_detailsInput = {
    laboratory_testid?: number
    laboratory_tests: string
    code?: string
    display_order?: number | null
    mnemonics?: string | null
    test_type?: string | null
    sub_department?: string | null
    sample_type?: string | null
    container_type?: string | null
    confidential?: string | null
    methodology?: string | null
    transport_temperature?: string | null
    tat?: string | null
    outsourcing_status?: string | null
    instrument?: string | null
    test_price: bigint | number
    custom_test_name: string
    instruction: string
    test_method: string
    status?: $Enums.laboratory_test_details_status
    status_changed_by: string
    status_changed_on: string
    unit: string
    reference_range: string
    age_gender_specific?: string | null
    critical_alert?: string | null
    interpretation?: string | null
    sort_order: number
    title_required: number
  }

  export type laboratory_test_detailsUpdateWithoutLaboratory_detailsInput = {
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsUncheckedUpdateWithoutLaboratory_detailsInput = {
    laboratory_testid?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type laboratory_test_detailsUncheckedUpdateManyWithoutLaboratory_detailsInput = {
    laboratory_testid?: IntFieldUpdateOperationsInput | number
    laboratory_tests?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    mnemonics?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    sub_department?: NullableStringFieldUpdateOperationsInput | string | null
    sample_type?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidential?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    transport_temperature?: NullableStringFieldUpdateOperationsInput | string | null
    tat?: NullableStringFieldUpdateOperationsInput | string | null
    outsourcing_status?: NullableStringFieldUpdateOperationsInput | string | null
    instrument?: NullableStringFieldUpdateOperationsInput | string | null
    test_price?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_test_name?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    test_method?: StringFieldUpdateOperationsInput | string
    status?: Enumlaboratory_test_details_statusFieldUpdateOperationsInput | $Enums.laboratory_test_details_status
    status_changed_by?: StringFieldUpdateOperationsInput | string
    status_changed_on?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    reference_range?: StringFieldUpdateOperationsInput | string
    age_gender_specific?: NullableStringFieldUpdateOperationsInput | string | null
    critical_alert?: NullableStringFieldUpdateOperationsInput | string | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    title_required?: IntFieldUpdateOperationsInput | number
  }

  export type phy_adminCreateManyPhysician_appointmentInput = {
    phy_admin_id?: number
    phy_admin_name?: string | null
    phy_admin_phone?: string | null
    phy_admin_mail_id?: string
    phy_admin_password?: string | null
    created_on?: Date | string
    updated_on?: Date | string | null
    created_by?: string | null
    active?: number
    is_visible?: number
    role_id?: number
  }

  export type phy_adminUpdateWithoutPhysician_appointmentInput = {
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type phy_adminUncheckedUpdateWithoutPhysician_appointmentInput = {
    phy_admin_id?: IntFieldUpdateOperationsInput | number
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type phy_adminUncheckedUpdateManyWithoutPhysician_appointmentInput = {
    phy_admin_id?: IntFieldUpdateOperationsInput | number
    phy_admin_name?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phy_admin_mail_id?: StringFieldUpdateOperationsInput | string
    phy_admin_password?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    active?: IntFieldUpdateOperationsInput | number
    is_visible?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Investigation_detailsCountOutputTypeDefaultArgs instead
     */
    export type Investigation_detailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Investigation_detailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Laboratory_detailsCountOutputTypeDefaultArgs instead
     */
    export type Laboratory_detailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Laboratory_detailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Physician_appointmentCountOutputTypeDefaultArgs instead
     */
    export type Physician_appointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Physician_appointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use barcodeDefaultArgs instead
     */
    export type barcodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = barcodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use billingDefaultArgs instead
     */
    export type billingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = billingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use billing_logDefaultArgs instead
     */
    export type billing_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = billing_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bloodgroup_detailsDefaultArgs instead
     */
    export type bloodgroup_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bloodgroup_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cityDefaultArgs instead
     */
    export type cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clinic_module_activation_requestDefaultArgs instead
     */
    export type clinic_module_activation_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clinic_module_activation_requestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clinical_parametersDefaultArgs instead
     */
    export type clinical_parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clinical_parametersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contactDefaultArgs instead
     */
    export type contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use countryDefaultArgs instead
     */
    export type countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = countryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use filesDefaultArgs instead
     */
    export type filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = filesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use investigation_detailsDefaultArgs instead
     */
    export type investigation_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = investigation_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use investigation_fileDefaultArgs instead
     */
    export type investigation_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = investigation_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use investigation_test_detailsDefaultArgs instead
     */
    export type investigation_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = investigation_test_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lab_leavesDefaultArgs instead
     */
    export type lab_leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lab_leavesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lab_tests_price_updatesDefaultArgs instead
     */
    export type lab_tests_price_updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lab_tests_price_updatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lab_timingsDefaultArgs instead
     */
    export type lab_timingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lab_timingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use laboratory_detailsDefaultArgs instead
     */
    export type laboratory_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = laboratory_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use laboratory_doctorsDefaultArgs instead
     */
    export type laboratory_doctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = laboratory_doctorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use laboratory_test_detailsDefaultArgs instead
     */
    export type laboratory_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = laboratory_test_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use localityDefaultArgs instead
     */
    export type localityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = localityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use login_detailsDefaultArgs instead
     */
    export type login_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = login_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medicineDefaultArgs instead
     */
    export type medicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medicineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notification_keysDefaultArgs instead
     */
    export type notification_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notification_keysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationattemptDefaultArgs instead
     */
    export type notificationattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationattemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RenamedpackageDefaultArgs instead
     */
    export type RenamedpackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RenamedpackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use package_containsDefaultArgs instead
     */
    export type package_containsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = package_containsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use package_labsDefaultArgs instead
     */
    export type package_labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = package_labsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use package_queueDefaultArgs instead
     */
    export type package_queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = package_queueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use patient_dep_detailsDefaultArgs instead
     */
    export type patient_dep_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = patient_dep_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use patient_doctor_mappingDefaultArgs instead
     */
    export type patient_doctor_mappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = patient_doctor_mappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use patient_parameterDefaultArgs instead
     */
    export type patient_parameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = patient_parameterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use patientqueueDefaultArgs instead
     */
    export type patientqueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = patientqueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paymentDefaultArgs instead
     */
    export type paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use phy_adminDefaultArgs instead
     */
    export type phy_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = phy_adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use physician_appointmentDefaultArgs instead
     */
    export type physician_appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = physician_appointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use physician_clinic_timingsDefaultArgs instead
     */
    export type physician_clinic_timingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = physician_clinic_timingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use physician_leavesDefaultArgs instead
     */
    export type physician_leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = physician_leavesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use physician_timingsDefaultArgs instead
     */
    export type physician_timingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = physician_timingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use preferredlabsDefaultArgs instead
     */
    export type preferredlabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = preferredlabsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prescriptionDefaultArgs instead
     */
    export type prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prescription_medicineDefaultArgs instead
     */
    export type prescription_medicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prescription_medicineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use qualificationDefaultArgs instead
     */
    export type qualificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = qualificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use qualification_mappingDefaultArgs instead
     */
    export type qualification_mappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = qualification_mappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use referral_confirmation_detailsDefaultArgs instead
     */
    export type referral_confirmation_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = referral_confirmation_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use referral_confirmation_details1DefaultArgs instead
     */
    export type referral_confirmation_details1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = referral_confirmation_details1DefaultArgs<ExtArgs>
    /**
     * @deprecated Use referral_patient_detailsDefaultArgs instead
     */
    export type referral_patient_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = referral_patient_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use referral_patient_test_detailsDefaultArgs instead
     */
    export type referral_patient_test_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = referral_patient_test_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use relationshipDefaultArgs instead
     */
    export type relationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = relationshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use report_templateDefaultArgs instead
     */
    export type report_templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = report_templateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sample_resultsDefaultArgs instead
     */
    export type sample_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sample_resultsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ssconsultation_billingDefaultArgs instead
     */
    export type ssconsultation_billingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ssconsultation_billingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ssconsultation_logDefaultArgs instead
     */
    export type ssconsultation_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ssconsultation_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use stateDefaultArgs instead
     */
    export type stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = stateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use status_masterDefaultArgs instead
     */
    export type status_masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = status_masterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use super_specialityDefaultArgs instead
     */
    export type super_specialityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = super_specialityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use superspeciality_consultationDefaultArgs instead
     */
    export type superspeciality_consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = superspeciality_consultationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use superspeciality_detailsDefaultArgs instead
     */
    export type superspeciality_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = superspeciality_detailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use test_report_notesDefaultArgs instead
     */
    export type test_report_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = test_report_notesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use update_labsDefaultArgs instead
     */
    export type update_labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = update_labsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}